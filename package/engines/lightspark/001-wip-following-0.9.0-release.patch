diff -u -r -N lightspark-0.9.0/ChangeLog lightspark-master/ChangeLog
--- lightspark-0.9.0/ChangeLog	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/ChangeLog	2025-03-05 20:13:02.053862456 +0100
@@ -1,5 +1,9 @@
 lightspark: An open source flash player implementation
 
+Version NEXT:
+
+	* improved focus support
+
 Version 0.9.0:
 
 	* improved support for html code in TextFields
diff -u -r -N lightspark-0.9.0/CMakeLists.txt lightspark-master/CMakeLists.txt
--- lightspark-0.9.0/CMakeLists.txt	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/CMakeLists.txt	2025-03-05 20:13:02.052862431 +0100
@@ -163,7 +163,7 @@
 ENDIF()
 
 #On mingw-cross-env, all depedencies are static libs
-IF(CROSSCOMPILING AND MINGW)
+IF(MINGW)
   SET(STATICDEPS TRUE)
 ELSE()
   SET(STATICDEPS FALSE)
@@ -536,6 +536,7 @@
 SET(CPACK_NSIS_URL_INFO_ABOUT "http:////www.lightspark.org")
 #-- SET(CPACK_PACKAGE_ICON ${PROJECT_SOURCE_DIR}/media/lightspark-logo.svg)
 IF(WIN32)
+
   SET(CPACK_PACKAGE_INSTALL_DIRECTORY "Lightspark")
   SET(CPACK_PACKAGE_EXECUTABLES "lightspark" "Lightspark")
   SET(CPACK_NSIS_EXTRA_INSTALL_COMMANDS "
diff -u -r -N lightspark-0.9.0/media/lightspark.desktop lightspark-master/media/lightspark.desktop
--- lightspark-0.9.0/media/lightspark.desktop	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/media/lightspark.desktop	2025-03-05 20:13:02.057862554 +0100
@@ -5,6 +5,6 @@
 Exec=lightspark
 Icon=lightspark
 Type=Application
-Categories=Multimedia;Game;AudioVideo;Video;Player;Viewer;
+Categories=Game;AudioVideo;Video;Player;Viewer;
 MimeType=application/x-shockwave-flash;
 StartupNotify=true
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/.clang-format lightspark-master/src/3rdparty/ordered-map/.clang-format
--- lightspark-0.9.0/src/3rdparty/ordered-map/.clang-format	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/.clang-format	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1 @@
+BasedOnStyle: Google
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/cmake/tsl-ordered-mapConfig.cmake.in lightspark-master/src/3rdparty/ordered-map/cmake/tsl-ordered-mapConfig.cmake.in
--- lightspark-0.9.0/src/3rdparty/ordered-map/cmake/tsl-ordered-mapConfig.cmake.in	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/cmake/tsl-ordered-mapConfig.cmake.in	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1,9 @@
+# This module sets the following variables:
+# * tsl-ordered-map_FOUND - true if tsl-ordered-map found on the system
+# * tsl-ordered-map_INCLUDE_DIRS - the directory containing tsl-ordered-map headers
+@PACKAGE_INIT@
+
+if(NOT TARGET tsl::ordered_map)
+  include("${CMAKE_CURRENT_LIST_DIR}/tsl-ordered-mapTargets.cmake")
+  get_target_property(tsl-ordered-map_INCLUDE_DIRS tsl::ordered_map INTERFACE_INCLUDE_DIRECTORIES)
+endif()
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/CMakeLists.txt lightspark-master/src/3rdparty/ordered-map/CMakeLists.txt
--- lightspark-0.9.0/src/3rdparty/ordered-map/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/CMakeLists.txt	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1,74 @@
+cmake_minimum_required(VERSION 3.5)
+include(GNUInstallDirs)
+
+
+project(tsl-ordered-map VERSION 1.1.0)
+
+add_library(ordered_map INTERFACE)
+# Use tsl::ordered_map as target, more consistent with other libraries conventions (Boost, Qt, ...)
+add_library(tsl::ordered_map ALIAS ordered_map)
+
+target_include_directories(ordered_map INTERFACE
+                           "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
+                           "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>")
+
+list(APPEND headers "${CMAKE_CURRENT_SOURCE_DIR}/include/tsl/ordered_hash.h"
+                    "${CMAKE_CURRENT_SOURCE_DIR}/include/tsl/ordered_map.h"
+                    "${CMAKE_CURRENT_SOURCE_DIR}/include/tsl/ordered_set.h")
+target_sources(ordered_map INTERFACE "$<BUILD_INTERFACE:${headers}>")
+
+if(MSVC)
+    target_sources(ordered_map INTERFACE
+                   "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/tsl-ordered-map.natvis>"
+                   "$<INSTALL_INTERFACE:${CMAKE_INSTALL_DATAROOTDIR}/tsl-ordered-map.natvis>")
+endif()
+
+
+
+
+include(CMakePackageConfigHelpers)
+
+## Install include directory and potential natvis file
+install(DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/include/tsl"
+        DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}")
+
+if(MSVC)
+install(FILES "${CMAKE_CURRENT_SOURCE_DIR}/tsl-ordered-map.natvis"
+        DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}")
+endif()
+
+
+
+## Create and install tsl-ordered-mapConfig.cmake
+configure_package_config_file("${CMAKE_CURRENT_SOURCE_DIR}/cmake/tsl-ordered-mapConfig.cmake.in"
+                                "${CMAKE_CURRENT_BINARY_DIR}/tsl-ordered-mapConfig.cmake"
+                                INSTALL_DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}/cmake/tsl-ordered-map")
+
+install(FILES "${CMAKE_CURRENT_BINARY_DIR}/tsl-ordered-mapConfig.cmake"
+        DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}/cmake/tsl-ordered-map")
+
+
+
+## Create and install tsl-ordered-mapTargets.cmake
+install(TARGETS ordered_map
+        EXPORT tsl-ordered-mapTargets)
+
+install(EXPORT tsl-ordered-mapTargets
+        NAMESPACE tsl::
+        DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}/cmake/tsl-ordered-map")
+
+
+
+## Create and install tsl-ordered-mapConfigVersion.cmake
+# tsl-ordered-map is header-only and does not depend on the architecture.
+# Remove CMAKE_SIZEOF_VOID_P from tsl-ordered-mapConfigVersion.cmake so that a
+# tsl-ordered-mapConfig.cmake generated for a 64 bit target can be used for 32 bit
+# targets and vice versa.
+set(CMAKE_SIZEOF_VOID_P_BACKUP ${CMAKE_SIZEOF_VOID_P})
+unset(CMAKE_SIZEOF_VOID_P)
+write_basic_package_version_file("${CMAKE_CURRENT_BINARY_DIR}/tsl-ordered-mapConfigVersion.cmake"
+                                COMPATIBILITY SameMajorVersion)
+set(CMAKE_SIZEOF_VOID_P ${CMAKE_SIZEOF_VOID_P_BACKUP})
+
+install(FILES "${CMAKE_CURRENT_BINARY_DIR}/tsl-ordered-mapConfigVersion.cmake"
+        DESTINATION "${CMAKE_INSTALL_DATAROOTDIR}/cmake/tsl-ordered-map")
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/.codecov.yml lightspark-master/src/3rdparty/ordered-map/.codecov.yml
--- lightspark-0.9.0/src/3rdparty/ordered-map/.codecov.yml	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/.codecov.yml	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1,5 @@
+comment: off
+coverage:
+  status:
+    project: off
+    patch: off
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/doxygen.conf lightspark-master/src/3rdparty/ordered-map/doxygen.conf
--- lightspark-0.9.0/src/3rdparty/ordered-map/doxygen.conf	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/doxygen.conf	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,2483 @@
+# Doxyfile 1.8.11
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+# for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = ordered-map
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         = 
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          = 
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           = 
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = doc/
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        = 
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    = 
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 4
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                = 
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              = 
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
+# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
+# Fortran. In the later case the parser tries to guess whether the code is fixed
+# or free formatted code, this is the default for Fortran type files), VHDL. For
+# instance to make doxygen treat .inc files as Fortran files (default is PHP),
+# and .f files as C (default is Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      = 
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO, these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       = 
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    = 
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            = 
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = include/tsl/ README.md
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: http://www.gnu.org/software/libiconv) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f, *.for, *.tcl,
+# *.vhd, *.vhdl, *.ucf, *.qsf, *.as and *.js.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf \
+                         *.as \
+                         *.js
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = YES
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = 
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       = 
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        = \
+tsl::detail_ordered_hash::has_is_transparent* \
+tsl::detail_ordered_hash::make_void \
+tsl::detail_ordered_hash::is_vector* \
+tsl::detail_ordered_hash::bucket_entry
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           = 
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             = 
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           = 
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        = 
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS = 
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE = README.md
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see http://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+# If the CLANG_ASSISTED_PARSING tag is set to YES then doxygen will use the
+# clang parser (see: http://clang.llvm.org/) for more accurate parsing at the
+# cost of reduced performance. This can be particularly helpful with template
+# rich C++ code for which doxygen's built-in parser lacks the necessary type
+# information.
+# Note: The availability of this option depends on whether or not doxygen was
+# generated with the -Duse-libclang=ON option for CMake.
+# The default value is: NO.
+
+CLANG_ASSISTED_PARSING = YES
+
+# If clang assisted parsing is enabled you can provide the compiler with command
+# line options that you would normally use when invoking the compiler. Note that
+# the include paths will already be set by doxygen for the files and directories
+# specified with INPUT and INCLUDE_PATH.
+# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.
+
+CLANG_OPTIONS          = -std=c++11
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            = 
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            = 
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        = 
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  = 
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       = 
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: http://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               = 
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           = 
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     = 
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               = 
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   = 
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  = 
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  = 
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           = 
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# http://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from http://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     = 
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       = 
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       = 
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     = 
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         = 
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           = 
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           = 
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET = 
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      = 
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    = 
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    = 
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             = 
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sf.net) file that captures the
+# structure of the code including all documentation. Note that this feature is
+# still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX = 
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           = 
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  = 
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             = 
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      = 
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               = 
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       = 
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = NO
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            = 
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               = 
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: YES.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           = 
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, png:cairo, png:cairo:cairo, png:cairo:gd, png:gd,
+# png:gd:gd, jpg, jpg:cairo, jpg:cairo:gd, jpg:gd, jpg:gd:gd, gif, gif:cairo,
+# gif:cairo:gd, gif:gd, gif:gd:gd, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               = 
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           = 
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           = 
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           = 
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      = 
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  = 
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_hash.h lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_hash.h
--- lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_hash.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_hash.h	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,1701 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef TSL_ORDERED_HASH_H
+#define TSL_ORDERED_HASH_H
+
+#include <algorithm>
+#include <cassert>
+#include <climits>
+#include <cmath>
+#include <cstddef>
+#include <cstdint>
+#include <exception>
+#include <functional>
+#include <iterator>
+#include <limits>
+#include <memory>
+#include <stdexcept>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+/**
+ * Macros for compatibility with GCC 4.8
+ */
+#if (defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ < 9))
+#define TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR
+#define TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
+#endif
+
+/**
+ * Only activate tsl_oh_assert if TSL_DEBUG is defined.
+ * This way we avoid the performance hit when NDEBUG is not defined with assert
+ * as tsl_oh_assert is used a lot (people usually compile with "-O3" and not
+ * "-O3 -DNDEBUG").
+ */
+#ifdef TSL_DEBUG
+#define tsl_oh_assert(expr) assert(expr)
+#else
+#define tsl_oh_assert(expr) (static_cast<void>(0))
+#endif
+
+/**
+ * If exceptions are enabled, throw the exception passed in parameter, otherwise
+ * call std::terminate.
+ */
+#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || \
+     (defined(_MSC_VER) && defined(_CPPUNWIND))) &&        \
+    !defined(TSL_NO_EXCEPTIONS)
+#define TSL_OH_THROW_OR_TERMINATE(ex, msg) throw ex(msg)
+#else
+#define TSL_OH_NO_EXCEPTIONS
+#ifdef TSL_DEBUG
+#include <iostream>
+#define TSL_OH_THROW_OR_TERMINATE(ex, msg) \
+  do {                                     \
+    std::cerr << msg << std::endl;         \
+    std::terminate();                      \
+  } while (0)
+#else
+#define TSL_OH_THROW_OR_TERMINATE(ex, msg) std::terminate()
+#endif
+#endif
+
+namespace tsl {
+
+namespace detail_ordered_hash {
+
+template <typename T>
+struct make_void {
+  using type = void;
+};
+
+template <typename T, typename = void>
+struct has_is_transparent : std::false_type {};
+
+template <typename T>
+struct has_is_transparent<T,
+                          typename make_void<typename T::is_transparent>::type>
+    : std::true_type {};
+
+template <typename T, typename = void>
+struct is_vector : std::false_type {};
+
+template <typename T>
+struct is_vector<T,
+                 typename std::enable_if<std::is_same<
+                     T, std::vector<typename T::value_type,
+                                    typename T::allocator_type>>::value>::type>
+    : std::true_type {};
+
+// Only available in C++17, we need to be compatible with C++11
+template <class T>
+const T& clamp(const T& v, const T& lo, const T& hi) {
+  return std::min(hi, std::max(lo, v));
+}
+
+template <typename T, typename U>
+static T numeric_cast(U value,
+                      const char* error_message = "numeric_cast() failed.") {
+  T ret = static_cast<T>(value);
+  if (static_cast<U>(ret) != value) {
+    TSL_OH_THROW_OR_TERMINATE(std::runtime_error, error_message);
+  }
+
+  const bool is_same_signedness =
+      (std::is_unsigned<T>::value && std::is_unsigned<U>::value) ||
+      (std::is_signed<T>::value && std::is_signed<U>::value);
+  if (!is_same_signedness && (ret < T{}) != (value < U{})) {
+    TSL_OH_THROW_OR_TERMINATE(std::runtime_error, error_message);
+  }
+
+  return ret;
+}
+
+/**
+ * Fixed size type used to represent size_type values on serialization. Need to
+ * be big enough to represent a std::size_t on 32 and 64 bits platforms, and
+ * must be the same size on both platforms.
+ */
+using slz_size_type = std::uint64_t;
+static_assert(std::numeric_limits<slz_size_type>::max() >=
+                  std::numeric_limits<std::size_t>::max(),
+              "slz_size_type must be >= std::size_t");
+
+template <class T, class Deserializer>
+static T deserialize_value(Deserializer& deserializer) {
+  // MSVC < 2017 is not conformant, circumvent the problem by removing the
+  // template keyword
+#if defined(_MSC_VER) && _MSC_VER < 1910
+  return deserializer.Deserializer::operator()<T>();
+#else
+  return deserializer.Deserializer::template operator()<T>();
+#endif
+}
+
+/**
+ * Each bucket entry stores an index which is the index in m_values
+ * corresponding to the bucket's value and a hash (which may be truncated to 32
+ * bits depending on IndexType) corresponding to the hash of the value.
+ *
+ * The size of IndexType limits the size of the hash table to
+ * std::numeric_limits<IndexType>::max() - 1 elements (-1 due to a reserved
+ * value used to mark a bucket as empty).
+ */
+template <class IndexType>
+class bucket_entry {
+  static_assert(std::is_unsigned<IndexType>::value,
+                "IndexType must be an unsigned value.");
+  static_assert(std::numeric_limits<IndexType>::max() <=
+                    std::numeric_limits<std::size_t>::max(),
+                "std::numeric_limits<IndexType>::max() must be <= "
+                "std::numeric_limits<std::size_t>::max().");
+
+ public:
+  using index_type = IndexType;
+  using truncated_hash_type = typename std::conditional<
+      std::numeric_limits<IndexType>::max() <=
+          std::numeric_limits<std::uint_least32_t>::max(),
+      std::uint_least32_t, std::size_t>::type;
+
+  bucket_entry() noexcept : m_index(EMPTY_MARKER_INDEX), m_hash(0) {}
+
+  bool empty() const noexcept { return m_index == EMPTY_MARKER_INDEX; }
+
+  void clear() noexcept { m_index = EMPTY_MARKER_INDEX; }
+
+  index_type index() const noexcept {
+    tsl_oh_assert(!empty());
+    return m_index;
+  }
+
+  index_type& index_ref() noexcept {
+    tsl_oh_assert(!empty());
+    return m_index;
+  }
+
+  void set_index(index_type index) noexcept {
+    tsl_oh_assert(index <= max_size());
+
+    m_index = index;
+  }
+
+  truncated_hash_type truncated_hash() const noexcept {
+    tsl_oh_assert(!empty());
+    return m_hash;
+  }
+
+  truncated_hash_type& truncated_hash_ref() noexcept {
+    tsl_oh_assert(!empty());
+    return m_hash;
+  }
+
+  void set_hash(std::size_t hash) noexcept { m_hash = truncate_hash(hash); }
+
+  template <class Serializer>
+  void serialize(Serializer& serializer) const {
+    const slz_size_type index = m_index;
+    serializer(index);
+
+    const slz_size_type hash = m_hash;
+    serializer(hash);
+  }
+
+  template <class Deserializer>
+  static bucket_entry deserialize(Deserializer& deserializer) {
+    const slz_size_type index = deserialize_value<slz_size_type>(deserializer);
+    const slz_size_type hash = deserialize_value<slz_size_type>(deserializer);
+
+    bucket_entry bentry;
+    bentry.m_index =
+        numeric_cast<index_type>(index, "Deserialized index is too big.");
+    bentry.m_hash = numeric_cast<truncated_hash_type>(
+        hash, "Deserialized hash is too big.");
+
+    return bentry;
+  }
+
+  static truncated_hash_type truncate_hash(std::size_t hash) noexcept {
+    return truncated_hash_type(hash);
+  }
+
+  static std::size_t max_size() noexcept {
+    return static_cast<std::size_t>(std::numeric_limits<index_type>::max()) -
+           NB_RESERVED_INDEXES;
+  }
+
+ private:
+  static const index_type EMPTY_MARKER_INDEX =
+      std::numeric_limits<index_type>::max();
+  static const std::size_t NB_RESERVED_INDEXES = 1;
+
+  index_type m_index;
+  truncated_hash_type m_hash;
+};
+
+/**
+ * Internal common class used by ordered_map and ordered_set.
+ *
+ * ValueType is what will be stored by ordered_hash (usually std::pair<Key, T>
+ * for map and Key for set).
+ *
+ * KeySelect should be a FunctionObject which takes a ValueType in parameter and
+ * return a reference to the key.
+ *
+ * ValueSelect should be a FunctionObject which takes a ValueType in parameter
+ * and return a reference to the value. ValueSelect should be void if there is
+ * no value (in set for example).
+ *
+ * ValueTypeContainer is the container which will be used to store ValueType
+ * values. Usually a std::deque<ValueType, Allocator> or std::vector<ValueType,
+ * Allocator>.
+ *
+ *
+ *
+ * The ordered_hash structure is a hash table which preserves the order of
+ * insertion of the elements. To do so, it stores the values in the
+ * ValueTypeContainer (m_values) using emplace_back at each insertion of a new
+ * element. Another structure (m_buckets of type std::vector<bucket_entry>) will
+ * serve as buckets array for the hash table part. Each bucket stores an index
+ * which corresponds to the index in m_values where the bucket's value is and
+ * the (truncated) hash of this value. An index is used instead of a pointer to
+ * the value to reduce the size of each bucket entry.
+ *
+ * To resolve collisions in the buckets array, the structures use robin hood
+ * linear probing with backward shift deletion.
+ */
+template <class ValueType, class KeySelect, class ValueSelect, class Hash,
+          class KeyEqual, class Allocator, class ValueTypeContainer,
+          class IndexType>
+class ordered_hash : private Hash, private KeyEqual {
+ private:
+  template <typename U>
+  using has_mapped_type =
+      typename std::integral_constant<bool, !std::is_same<U, void>::value>;
+
+  static_assert(
+      std::is_same<typename ValueTypeContainer::value_type, ValueType>::value,
+      "ValueTypeContainer::value_type != ValueType. "
+      "Check that the ValueTypeContainer has 'Key' as type for a set or "
+      "'std::pair<Key, T>' as type for a map.");
+
+  static_assert(std::is_same<typename ValueTypeContainer::allocator_type,
+                             Allocator>::value,
+                "ValueTypeContainer::allocator_type != Allocator. "
+                "Check that the allocator for ValueTypeContainer is the same "
+                "as Allocator.");
+
+  static_assert(std::is_same<typename Allocator::value_type, ValueType>::value,
+                "Allocator::value_type != ValueType. "
+                "Check that the allocator has 'Key' as type for a set or "
+                "'std::pair<Key, T>' as type for a map.");
+
+ public:
+  template <bool IsConst>
+  class ordered_iterator;
+
+  using key_type = typename KeySelect::key_type;
+  using value_type = ValueType;
+  using size_type = std::size_t;
+  using difference_type = std::ptrdiff_t;
+  using hasher = Hash;
+  using key_equal = KeyEqual;
+  using allocator_type = Allocator;
+  using reference = value_type&;
+  using const_reference = const value_type&;
+  using pointer = value_type*;
+  using const_pointer = const value_type*;
+  using iterator = ordered_iterator<false>;
+  using const_iterator = ordered_iterator<true>;
+  using reverse_iterator = std::reverse_iterator<iterator>;
+  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
+
+  using values_container_type = ValueTypeContainer;
+
+ public:
+  template <bool IsConst>
+  class ordered_iterator {
+    friend class ordered_hash;
+
+   private:
+    using iterator = typename std::conditional<
+        IsConst, typename values_container_type::const_iterator,
+        typename values_container_type::iterator>::type;
+
+    ordered_iterator(iterator it) noexcept : m_iterator(it) {}
+
+   public:
+    using iterator_category = std::random_access_iterator_tag;
+    using value_type = const typename ordered_hash::value_type;
+    using difference_type = typename iterator::difference_type;
+    using reference = value_type&;
+    using pointer = value_type*;
+
+    ordered_iterator() noexcept {}
+
+    // Copy constructor from iterator to const_iterator.
+    template <bool TIsConst = IsConst,
+              typename std::enable_if<TIsConst>::type* = nullptr>
+    ordered_iterator(const ordered_iterator<!TIsConst>& other) noexcept
+        : m_iterator(other.m_iterator) {}
+
+    ordered_iterator(const ordered_iterator& other) = default;
+    ordered_iterator(ordered_iterator&& other) = default;
+    ordered_iterator& operator=(const ordered_iterator& other) = default;
+    ordered_iterator& operator=(ordered_iterator&& other) = default;
+
+    const typename ordered_hash::key_type& key() const {
+      return KeySelect()(*m_iterator);
+    }
+
+    template <class U = ValueSelect,
+              typename std::enable_if<has_mapped_type<U>::value &&
+                                      IsConst>::type* = nullptr>
+    const typename U::value_type& value() const {
+      return U()(*m_iterator);
+    }
+
+    template <class U = ValueSelect,
+              typename std::enable_if<has_mapped_type<U>::value &&
+                                      !IsConst>::type* = nullptr>
+    typename U::value_type& value() {
+      return U()(*m_iterator);
+    }
+
+    reference operator*() const { return *m_iterator; }
+    pointer operator->() const { return m_iterator.operator->(); }
+
+    ordered_iterator& operator++() {
+      ++m_iterator;
+      return *this;
+    }
+    ordered_iterator& operator--() {
+      --m_iterator;
+      return *this;
+    }
+
+    ordered_iterator operator++(int) {
+      ordered_iterator tmp(*this);
+      ++(*this);
+      return tmp;
+    }
+    ordered_iterator operator--(int) {
+      ordered_iterator tmp(*this);
+      --(*this);
+      return tmp;
+    }
+
+    reference operator[](difference_type n) const { return m_iterator[n]; }
+
+    ordered_iterator& operator+=(difference_type n) {
+      m_iterator += n;
+      return *this;
+    }
+    ordered_iterator& operator-=(difference_type n) {
+      m_iterator -= n;
+      return *this;
+    }
+
+    ordered_iterator operator+(difference_type n) {
+      ordered_iterator tmp(*this);
+      tmp += n;
+      return tmp;
+    }
+    ordered_iterator operator-(difference_type n) {
+      ordered_iterator tmp(*this);
+      tmp -= n;
+      return tmp;
+    }
+
+    friend bool operator==(const ordered_iterator& lhs,
+                           const ordered_iterator& rhs) {
+      return lhs.m_iterator == rhs.m_iterator;
+    }
+
+    friend bool operator!=(const ordered_iterator& lhs,
+                           const ordered_iterator& rhs) {
+      return lhs.m_iterator != rhs.m_iterator;
+    }
+
+    friend bool operator<(const ordered_iterator& lhs,
+                          const ordered_iterator& rhs) {
+      return lhs.m_iterator < rhs.m_iterator;
+    }
+
+    friend bool operator>(const ordered_iterator& lhs,
+                          const ordered_iterator& rhs) {
+      return lhs.m_iterator > rhs.m_iterator;
+    }
+
+    friend bool operator<=(const ordered_iterator& lhs,
+                           const ordered_iterator& rhs) {
+      return lhs.m_iterator <= rhs.m_iterator;
+    }
+
+    friend bool operator>=(const ordered_iterator& lhs,
+                           const ordered_iterator& rhs) {
+      return lhs.m_iterator >= rhs.m_iterator;
+    }
+
+    friend ordered_iterator operator+(difference_type n,
+                                      const ordered_iterator& it) {
+      return n + it.m_iterator;
+    }
+
+    friend difference_type operator-(const ordered_iterator& lhs,
+                                     const ordered_iterator& rhs) {
+      return lhs.m_iterator - rhs.m_iterator;
+    }
+
+   private:
+    iterator m_iterator;
+  };
+
+ private:
+  using bucket_entry = tsl::detail_ordered_hash::bucket_entry<IndexType>;
+
+  using buckets_container_allocator = typename std::allocator_traits<
+      allocator_type>::template rebind_alloc<bucket_entry>;
+
+  using buckets_container_type =
+      std::vector<bucket_entry, buckets_container_allocator>;
+
+  using truncated_hash_type = typename bucket_entry::truncated_hash_type;
+  using index_type = typename bucket_entry::index_type;
+
+ public:
+  ordered_hash(size_type bucket_count, const Hash& hash, const KeyEqual& equal,
+               const Allocator& alloc, float max_load_factor)
+      : Hash(hash),
+        KeyEqual(equal),
+        m_buckets_data(alloc),
+        m_buckets(static_empty_bucket_ptr()),
+        m_hash_mask(0),
+        m_values(alloc),
+        m_grow_on_next_insert(false) {
+    if (bucket_count > max_bucket_count()) {
+      TSL_OH_THROW_OR_TERMINATE(std::length_error,
+                                "The map exceeds its maximum size.");
+    }
+
+    if (bucket_count > 0) {
+      bucket_count = round_up_to_power_of_two(bucket_count);
+
+      m_buckets_data.resize(bucket_count);
+      m_buckets = m_buckets_data.data(), m_hash_mask = bucket_count - 1;
+    }
+
+    this->max_load_factor(max_load_factor);
+  }
+
+  ordered_hash(const ordered_hash& other)
+      : Hash(other),
+        KeyEqual(other),
+        m_buckets_data(other.m_buckets_data),
+        m_buckets(m_buckets_data.empty() ? static_empty_bucket_ptr()
+                                         : m_buckets_data.data()),
+        m_hash_mask(other.m_hash_mask),
+        m_values(other.m_values),
+        m_load_threshold(other.m_load_threshold),
+        m_max_load_factor(other.m_max_load_factor),
+        m_grow_on_next_insert(other.m_grow_on_next_insert) {}
+
+  ordered_hash(ordered_hash&& other) noexcept(
+      std::is_nothrow_move_constructible<
+          Hash>::value&& std::is_nothrow_move_constructible<KeyEqual>::value&&
+          std::is_nothrow_move_constructible<buckets_container_type>::value&&
+              std::is_nothrow_move_constructible<values_container_type>::value)
+      : Hash(std::move(static_cast<Hash&>(other))),
+        KeyEqual(std::move(static_cast<KeyEqual&>(other))),
+        m_buckets_data(std::move(other.m_buckets_data)),
+        m_buckets(m_buckets_data.empty() ? static_empty_bucket_ptr()
+                                         : m_buckets_data.data()),
+        m_hash_mask(other.m_hash_mask),
+        m_values(std::move(other.m_values)),
+        m_load_threshold(other.m_load_threshold),
+        m_max_load_factor(other.m_max_load_factor),
+        m_grow_on_next_insert(other.m_grow_on_next_insert) {
+    other.m_buckets_data.clear();
+    other.m_buckets = static_empty_bucket_ptr();
+    other.m_hash_mask = 0;
+    other.m_values.clear();
+    other.m_load_threshold = 0;
+    other.m_grow_on_next_insert = false;
+  }
+
+  ordered_hash& operator=(const ordered_hash& other) {
+    if (&other != this) {
+      Hash::operator=(other);
+      KeyEqual::operator=(other);
+
+      m_buckets_data = other.m_buckets_data;
+      m_buckets = m_buckets_data.empty() ? static_empty_bucket_ptr()
+                                         : m_buckets_data.data();
+
+      m_hash_mask = other.m_hash_mask;
+      m_values = other.m_values;
+      m_load_threshold = other.m_load_threshold;
+      m_max_load_factor = other.m_max_load_factor;
+      m_grow_on_next_insert = other.m_grow_on_next_insert;
+    }
+
+    return *this;
+  }
+
+  ordered_hash& operator=(ordered_hash&& other) {
+    other.swap(*this);
+    other.clear();
+
+    return *this;
+  }
+
+  allocator_type get_allocator() const { return m_values.get_allocator(); }
+
+  /*
+   * Iterators
+   */
+  iterator begin() noexcept { return iterator(m_values.begin()); }
+
+  const_iterator begin() const noexcept { return cbegin(); }
+
+  const_iterator cbegin() const noexcept {
+    return const_iterator(m_values.cbegin());
+  }
+
+  iterator end() noexcept { return iterator(m_values.end()); }
+
+  const_iterator end() const noexcept { return cend(); }
+
+  const_iterator cend() const noexcept {
+    return const_iterator(m_values.cend());
+  }
+
+  reverse_iterator rbegin() noexcept {
+    return reverse_iterator(m_values.end());
+  }
+
+  const_reverse_iterator rbegin() const noexcept { return rcbegin(); }
+
+  const_reverse_iterator rcbegin() const noexcept {
+    return const_reverse_iterator(m_values.cend());
+  }
+
+  reverse_iterator rend() noexcept {
+    return reverse_iterator(m_values.begin());
+  }
+
+  const_reverse_iterator rend() const noexcept { return rcend(); }
+
+  const_reverse_iterator rcend() const noexcept {
+    return const_reverse_iterator(m_values.cbegin());
+  }
+
+  /*
+   * Capacity
+   */
+  bool empty() const noexcept { return m_values.empty(); }
+
+  size_type size() const noexcept { return m_values.size(); }
+
+  size_type max_size() const noexcept {
+    return std::min(bucket_entry::max_size(), m_values.max_size());
+  }
+
+  /*
+   * Modifiers
+   */
+  void clear() noexcept {
+    for (auto& bucket : m_buckets_data) {
+      bucket.clear();
+    }
+
+    m_values.clear();
+    m_grow_on_next_insert = false;
+  }
+
+  template <typename P>
+  std::pair<iterator, bool> insert(P&& value) {
+    return insert_impl(KeySelect()(value), std::forward<P>(value));
+  }
+
+  template <typename P>
+  iterator insert_hint(const_iterator hint, P&& value) {
+    if (hint != cend() &&
+        compare_keys(KeySelect()(*hint), KeySelect()(value))) {
+      return mutable_iterator(hint);
+    }
+
+    return insert(std::forward<P>(value)).first;
+  }
+
+  template <class InputIt>
+  void insert(InputIt first, InputIt last) {
+    if (std::is_base_of<
+            std::forward_iterator_tag,
+            typename std::iterator_traits<InputIt>::iterator_category>::value) {
+      const auto nb_elements_insert = std::distance(first, last);
+      const size_type nb_free_buckets = m_load_threshold - size();
+      tsl_oh_assert(m_load_threshold >= size());
+
+      if (nb_elements_insert > 0 &&
+          nb_free_buckets < size_type(nb_elements_insert)) {
+        reserve(size() + size_type(nb_elements_insert));
+      }
+    }
+
+    for (; first != last; ++first) {
+      insert(*first);
+    }
+  }
+
+  template <class K, class M>
+  std::pair<iterator, bool> insert_or_assign(K&& key, M&& value) {
+    auto it = try_emplace(std::forward<K>(key), std::forward<M>(value));
+    if (!it.second) {
+      it.first.value() = std::forward<M>(value);
+    }
+
+    return it;
+  }
+
+  template <class K, class M>
+  iterator insert_or_assign(const_iterator hint, K&& key, M&& obj) {
+    if (hint != cend() && compare_keys(KeySelect()(*hint), key)) {
+      auto it = mutable_iterator(hint);
+      it.value() = std::forward<M>(obj);
+
+      return it;
+    }
+
+    return insert_or_assign(std::forward<K>(key), std::forward<M>(obj)).first;
+  }
+
+  template <class... Args>
+  std::pair<iterator, bool> emplace(Args&&... args) {
+    return insert(value_type(std::forward<Args>(args)...));
+  }
+
+  template <class... Args>
+  iterator emplace_hint(const_iterator hint, Args&&... args) {
+    return insert_hint(hint, value_type(std::forward<Args>(args)...));
+  }
+
+  template <class K, class... Args>
+  std::pair<iterator, bool> try_emplace(K&& key, Args&&... value_args) {
+    return insert_impl(
+        key, std::piecewise_construct,
+        std::forward_as_tuple(std::forward<K>(key)),
+        std::forward_as_tuple(std::forward<Args>(value_args)...));
+  }
+
+  template <class K, class... Args>
+  iterator try_emplace_hint(const_iterator hint, K&& key, Args&&... args) {
+    if (hint != cend() && compare_keys(KeySelect()(*hint), key)) {
+      return mutable_iterator(hint);
+    }
+
+    return try_emplace(std::forward<K>(key), std::forward<Args>(args)...).first;
+  }
+
+  /**
+   * Here to avoid `template<class K> size_type erase(const K& key)` being used
+   * when we use an `iterator` instead of a `const_iterator`.
+   */
+  iterator erase(iterator pos) { return erase(const_iterator(pos)); }
+
+  iterator erase(const_iterator pos) {
+    tsl_oh_assert(pos != cend());
+
+    const std::size_t index_erase = iterator_to_index(pos);
+
+    auto it_bucket = find_key(pos.key(), hash_key(pos.key()));
+    tsl_oh_assert(it_bucket != m_buckets_data.end());
+
+    erase_value_from_bucket(it_bucket);
+
+    /*
+     * One element was removed from m_values, due to the left shift the next
+     * element is now at the position of the previous element (or end if none).
+     */
+    return begin() + index_erase;
+  }
+
+  iterator erase(const_iterator first, const_iterator last) {
+    if (first == last) {
+      return mutable_iterator(first);
+    }
+
+    tsl_oh_assert(std::distance(first, last) > 0);
+    const std::size_t start_index = iterator_to_index(first);
+    const std::size_t nb_values = std::size_t(std::distance(first, last));
+    const std::size_t end_index = start_index + nb_values;
+
+    // Delete all values
+#ifdef TSL_OH_NO_CONTAINER_ERASE_CONST_ITERATOR
+    auto next_it = m_values.erase(mutable_iterator(first).m_iterator,
+                                  mutable_iterator(last).m_iterator);
+#else
+    auto next_it = m_values.erase(first.m_iterator, last.m_iterator);
+#endif
+
+    /*
+     * Mark the buckets corresponding to the values as empty and do a backward
+     * shift.
+     *
+     * Also, the erase operation on m_values has shifted all the values on the
+     * right of last.m_iterator. Adapt the indexes for these values.
+     */
+    std::size_t ibucket = 0;
+    while (ibucket < m_buckets_data.size()) {
+      if (m_buckets[ibucket].empty()) {
+        ibucket++;
+      } else if (m_buckets[ibucket].index() >= start_index &&
+                 m_buckets[ibucket].index() < end_index) {
+        m_buckets[ibucket].clear();
+        backward_shift(ibucket);
+        // Don't increment ibucket, backward_shift may have replaced current
+        // bucket.
+      } else if (m_buckets[ibucket].index() >= end_index) {
+        m_buckets[ibucket].set_index(
+            index_type(m_buckets[ibucket].index() - nb_values));
+        ibucket++;
+      } else {
+        ibucket++;
+      }
+    }
+
+    return iterator(next_it);
+  }
+
+  template <class K>
+  size_type erase(const K& key) {
+    return erase(key, hash_key(key));
+  }
+
+  template <class K>
+  size_type erase(const K& key, std::size_t hash) {
+    return erase_impl(key, hash);
+  }
+
+  void swap(ordered_hash& other) {
+    using std::swap;
+
+    swap(static_cast<Hash&>(*this), static_cast<Hash&>(other));
+    swap(static_cast<KeyEqual&>(*this), static_cast<KeyEqual&>(other));
+    swap(m_buckets_data, other.m_buckets_data);
+    swap(m_buckets, other.m_buckets);
+    swap(m_hash_mask, other.m_hash_mask);
+    swap(m_values, other.m_values);
+    swap(m_load_threshold, other.m_load_threshold);
+    swap(m_max_load_factor, other.m_max_load_factor);
+    swap(m_grow_on_next_insert, other.m_grow_on_next_insert);
+  }
+
+  /*
+   * Lookup
+   */
+  template <class K, class U = ValueSelect,
+            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
+  typename U::value_type& at(const K& key) {
+    return at(key, hash_key(key));
+  }
+
+  template <class K, class U = ValueSelect,
+            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
+  typename U::value_type& at(const K& key, std::size_t hash) {
+    return const_cast<typename U::value_type&>(
+        static_cast<const ordered_hash*>(this)->at(key, hash));
+  }
+
+  template <class K, class U = ValueSelect,
+            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
+  const typename U::value_type& at(const K& key) const {
+    return at(key, hash_key(key));
+  }
+
+  template <class K, class U = ValueSelect,
+            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
+  const typename U::value_type& at(const K& key, std::size_t hash) const {
+    auto it = find(key, hash);
+    if (it != end()) {
+      return it.value();
+    } else {
+      TSL_OH_THROW_OR_TERMINATE(std::out_of_range, "Couldn't find the key.");
+    }
+  }
+
+  template <class K, class U = ValueSelect,
+            typename std::enable_if<has_mapped_type<U>::value>::type* = nullptr>
+  typename U::value_type& operator[](K&& key) {
+    return try_emplace(std::forward<K>(key)).first.value();
+  }
+
+  template <class K>
+  size_type count(const K& key) const {
+    return count(key, hash_key(key));
+  }
+
+  template <class K>
+  size_type count(const K& key, std::size_t hash) const {
+    if (find(key, hash) == cend()) {
+      return 0;
+    } else {
+      return 1;
+    }
+  }
+
+  template <class K>
+  iterator find(const K& key) {
+    return find(key, hash_key(key));
+  }
+
+  template <class K>
+  iterator find(const K& key, std::size_t hash) {
+    auto it_bucket = find_key(key, hash);
+    return (it_bucket != m_buckets_data.end())
+               ? iterator(m_values.begin() + it_bucket->index())
+               : end();
+  }
+
+  template <class K>
+  const_iterator find(const K& key) const {
+    return find(key, hash_key(key));
+  }
+
+  template <class K>
+  const_iterator find(const K& key, std::size_t hash) const {
+    auto it_bucket = find_key(key, hash);
+    return (it_bucket != m_buckets_data.cend())
+               ? const_iterator(m_values.begin() + it_bucket->index())
+               : end();
+  }
+
+  template <class K>
+  bool contains(const K& key) const {
+    return contains(key, hash_key(key));
+  }
+
+  template <class K>
+  bool contains(const K& key, std::size_t hash) const {
+    return find(key, hash) != cend();
+  }
+
+  template <class K>
+  std::pair<iterator, iterator> equal_range(const K& key) {
+    return equal_range(key, hash_key(key));
+  }
+
+  template <class K>
+  std::pair<iterator, iterator> equal_range(const K& key, std::size_t hash) {
+    iterator it = find(key, hash);
+    return std::make_pair(it, (it == end()) ? it : std::next(it));
+  }
+
+  template <class K>
+  std::pair<const_iterator, const_iterator> equal_range(const K& key) const {
+    return equal_range(key, hash_key(key));
+  }
+
+  template <class K>
+  std::pair<const_iterator, const_iterator> equal_range(
+      const K& key, std::size_t hash) const {
+    const_iterator it = find(key, hash);
+    return std::make_pair(it, (it == cend()) ? it : std::next(it));
+  }
+
+  /*
+   * Bucket interface
+   */
+  size_type bucket_count() const { return m_buckets_data.size(); }
+
+  size_type max_bucket_count() const { return m_buckets_data.max_size(); }
+
+  /*
+   *  Hash policy
+   */
+  float load_factor() const {
+    if (bucket_count() == 0) {
+      return 0;
+    }
+
+    return float(size()) / float(bucket_count());
+  }
+
+  float max_load_factor() const { return m_max_load_factor; }
+
+  void max_load_factor(float ml) {
+    m_max_load_factor = clamp(ml, float(MAX_LOAD_FACTOR__MINIMUM),
+                              float(MAX_LOAD_FACTOR__MAXIMUM));
+
+    m_max_load_factor = ml;
+    m_load_threshold = size_type(float(bucket_count()) * m_max_load_factor);
+  }
+
+  void rehash(size_type count) {
+    count = std::max(count,
+                     size_type(std::ceil(float(size()) / max_load_factor())));
+    rehash_impl(count);
+  }
+
+  void reserve(size_type count) {
+    reserve_space_for_values(count);
+
+    count = size_type(std::ceil(float(count) / max_load_factor()));
+    rehash(count);
+  }
+
+  /*
+   * Observers
+   */
+  hasher hash_function() const { return static_cast<const Hash&>(*this); }
+
+  key_equal key_eq() const { return static_cast<const KeyEqual&>(*this); }
+
+  /*
+   * Other
+   */
+  iterator mutable_iterator(const_iterator pos) {
+    return iterator(m_values.begin() + iterator_to_index(pos));
+  }
+
+  iterator nth(size_type index) {
+    tsl_oh_assert(index <= size());
+    return iterator(m_values.begin() + index);
+  }
+
+  const_iterator nth(size_type index) const {
+    tsl_oh_assert(index <= size());
+    return const_iterator(m_values.cbegin() + index);
+  }
+
+  const_reference front() const {
+    tsl_oh_assert(!empty());
+    return m_values.front();
+  }
+
+  const_reference back() const {
+    tsl_oh_assert(!empty());
+    return m_values.back();
+  }
+
+  const values_container_type& values_container() const noexcept {
+    return m_values;
+  }
+
+  values_container_type release() {
+    values_container_type ret;
+    for (auto& bucket : m_buckets_data) {
+      bucket.clear();
+    }
+    m_grow_on_next_insert = false;
+    std::swap(ret, m_values);
+    return ret;
+  }
+
+  template <class U = values_container_type,
+            typename std::enable_if<is_vector<U>::value>::type* = nullptr>
+  const typename values_container_type::value_type* data() const noexcept {
+    return m_values.data();
+  }
+
+  template <class U = values_container_type,
+            typename std::enable_if<is_vector<U>::value>::type* = nullptr>
+  size_type capacity() const noexcept {
+    return m_values.capacity();
+  }
+
+  void shrink_to_fit() { m_values.shrink_to_fit(); }
+
+  template <typename P>
+  std::pair<iterator, bool> insert_at_position(const_iterator pos, P&& value) {
+    return insert_at_position_impl(pos.m_iterator, KeySelect()(value),
+                                   std::forward<P>(value));
+  }
+
+  template <class... Args>
+  std::pair<iterator, bool> emplace_at_position(const_iterator pos,
+                                                Args&&... args) {
+    return insert_at_position(pos, value_type(std::forward<Args>(args)...));
+  }
+
+  template <class K, class... Args>
+  std::pair<iterator, bool> try_emplace_at_position(const_iterator pos, K&& key,
+                                                    Args&&... value_args) {
+    return insert_at_position_impl(
+        pos.m_iterator, key, std::piecewise_construct,
+        std::forward_as_tuple(std::forward<K>(key)),
+        std::forward_as_tuple(std::forward<Args>(value_args)...));
+  }
+
+  void pop_back() {
+    tsl_oh_assert(!empty());
+    erase(std::prev(end()));
+  }
+
+  /**
+   * Here to avoid `template<class K> size_type unordered_erase(const K& key)`
+   * being used when we use a iterator instead of a const_iterator.
+   */
+  iterator unordered_erase(iterator pos) {
+    return unordered_erase(const_iterator(pos));
+  }
+
+  iterator unordered_erase(const_iterator pos) {
+    const std::size_t index_erase = iterator_to_index(pos);
+    unordered_erase(pos.key());
+
+    /*
+     * One element was deleted, index_erase now points to the next element as
+     * the elements after the deleted value were shifted to the left in m_values
+     * (will be end() if we deleted the last element).
+     */
+    return begin() + index_erase;
+  }
+
+  template <class K>
+  size_type unordered_erase(const K& key) {
+    return unordered_erase(key, hash_key(key));
+  }
+
+  template <class K>
+  size_type unordered_erase(const K& key, std::size_t hash) {
+    auto it_bucket_key = find_key(key, hash);
+    if (it_bucket_key == m_buckets_data.end()) {
+      return 0;
+    }
+
+    /**
+     * If we are not erasing the last element in m_values, we swap
+     * the element we are erasing with the last element. We then would
+     * just have to do a pop_back() in m_values.
+     */
+    if (!compare_keys(key, KeySelect()(back()))) {
+      auto it_bucket_last_elem =
+          find_key(KeySelect()(back()), hash_key(KeySelect()(back())));
+      tsl_oh_assert(it_bucket_last_elem != m_buckets_data.end());
+      tsl_oh_assert(it_bucket_last_elem->index() == m_values.size() - 1);
+
+      using std::swap;
+      swap(m_values[it_bucket_key->index()],
+           m_values[it_bucket_last_elem->index()]);
+      swap(it_bucket_key->index_ref(), it_bucket_last_elem->index_ref());
+    }
+
+    erase_value_from_bucket(it_bucket_key);
+
+    return 1;
+  }
+
+  /**
+   * Remove all entries for which the given predicate matches.
+   */
+  template <class Predicate>
+  size_type erase_if(Predicate& pred) {
+    // Get the bucket associated with the given element.
+    auto get_bucket = [this](typename values_container_type::iterator it) {
+      return find_key(KeySelect()(*it), hash_key(KeySelect()(*it)));
+    };
+    // Clear a bucket without touching the container holding the values.
+    auto clear_bucket = [this](typename buckets_container_type::iterator it) {
+      tsl_oh_assert(it != m_buckets_data.end());
+      it->clear();
+      backward_shift(std::size_t(std::distance(m_buckets_data.begin(), it)));
+    };
+    // Ensure that only const references are passed to the predicate.
+    auto cpred = [&pred](typename values_container_type::const_reference x) {
+      return pred(x);
+    };
+
+    // Find first element that matches the predicate.
+    const auto last = m_values.end();
+    auto first = std::find_if(m_values.begin(), last, cpred);
+    if (first == last) {
+      return 0;
+    }
+    // Remove all elements that match the predicate.
+    clear_bucket(get_bucket(first));
+    for (auto it = std::next(first); it != last; ++it) {
+      auto it_bucket = get_bucket(it);
+      if (cpred(*it)) {
+        clear_bucket(it_bucket);
+      } else {
+        it_bucket->set_index(
+            static_cast<index_type>(std::distance(m_values.begin(), first)));
+        *first++ = std::move(*it);
+      }
+    }
+    // Resize the vector and return the number of deleted elements.
+    auto deleted = static_cast<size_type>(std::distance(first, last));
+    m_values.erase(first, last);
+    return deleted;
+  }
+
+  template <class Serializer>
+  void serialize(Serializer& serializer) const {
+    serialize_impl(serializer);
+  }
+
+  template <class Deserializer>
+  void deserialize(Deserializer& deserializer, bool hash_compatible) {
+    deserialize_impl(deserializer, hash_compatible);
+  }
+
+  friend bool operator==(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values == rhs.m_values;
+  }
+
+  friend bool operator!=(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values != rhs.m_values;
+  }
+
+  friend bool operator<(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values < rhs.m_values;
+  }
+
+  friend bool operator<=(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values <= rhs.m_values;
+  }
+
+  friend bool operator>(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values > rhs.m_values;
+  }
+
+  friend bool operator>=(const ordered_hash& lhs, const ordered_hash& rhs) {
+    return lhs.m_values >= rhs.m_values;
+  }
+
+ private:
+  template <class K>
+  std::size_t hash_key(const K& key) const {
+    return Hash::operator()(key);
+  }
+
+  template <class K1, class K2>
+  bool compare_keys(const K1& key1, const K2& key2) const {
+    return KeyEqual::operator()(key1, key2);
+  }
+
+  template <class K>
+  typename buckets_container_type::iterator find_key(const K& key,
+                                                     std::size_t hash) {
+    auto it = static_cast<const ordered_hash*>(this)->find_key(key, hash);
+    return m_buckets_data.begin() + std::distance(m_buckets_data.cbegin(), it);
+  }
+
+  /**
+   * Return bucket which has the key 'key' or m_buckets_data.end() if none.
+   *
+   * From the bucket_for_hash, search for the value until we either find an
+   * empty bucket or a bucket which has a value with a distance from its ideal
+   * bucket longer than the probe length for the value we are looking for.
+   */
+  template <class K>
+  typename buckets_container_type::const_iterator find_key(
+      const K& key, std::size_t hash) const {
+    for (std::size_t ibucket = bucket_for_hash(hash),
+                     dist_from_ideal_bucket = 0;
+         ; ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) {
+      if (m_buckets[ibucket].empty()) {
+        return m_buckets_data.end();
+      } else if (m_buckets[ibucket].truncated_hash() ==
+                     bucket_entry::truncate_hash(hash) &&
+                 compare_keys(
+                     key, KeySelect()(m_values[m_buckets[ibucket].index()]))) {
+        return m_buckets_data.begin() + ibucket;
+      } else if (dist_from_ideal_bucket > distance_from_ideal_bucket(ibucket)) {
+        return m_buckets_data.end();
+      }
+    }
+  }
+
+  void rehash_impl(size_type bucket_count) {
+    tsl_oh_assert(bucket_count >=
+                  size_type(std::ceil(float(size()) / max_load_factor())));
+
+    if (bucket_count > max_bucket_count()) {
+      TSL_OH_THROW_OR_TERMINATE(std::length_error,
+                                "The map exceeds its maximum size.");
+    }
+
+    if (bucket_count > 0) {
+      bucket_count = round_up_to_power_of_two(bucket_count);
+    }
+
+    if (bucket_count == this->bucket_count()) {
+      return;
+    }
+
+    buckets_container_type old_buckets(bucket_count);
+    m_buckets_data.swap(old_buckets);
+    m_buckets = m_buckets_data.empty() ? static_empty_bucket_ptr()
+                                       : m_buckets_data.data();
+    // Everything should be noexcept from here.
+
+    m_hash_mask = (bucket_count > 0) ? (bucket_count - 1) : 0;
+    this->max_load_factor(m_max_load_factor);
+    m_grow_on_next_insert = false;
+
+    for (const bucket_entry& old_bucket : old_buckets) {
+      if (old_bucket.empty()) {
+        continue;
+      }
+
+      truncated_hash_type insert_hash = old_bucket.truncated_hash();
+      index_type insert_index = old_bucket.index();
+
+      for (std::size_t ibucket = bucket_for_hash(insert_hash),
+                       dist_from_ideal_bucket = 0;
+           ; ibucket = next_bucket(ibucket), dist_from_ideal_bucket++) {
+        if (m_buckets[ibucket].empty()) {
+          m_buckets[ibucket].set_index(insert_index);
+          m_buckets[ibucket].set_hash(insert_hash);
+          break;
+        }
+
+        const std::size_t distance = distance_from_ideal_bucket(ibucket);
+        if (dist_from_ideal_bucket > distance) {
+          std::swap(insert_index, m_buckets[ibucket].index_ref());
+          std::swap(insert_hash, m_buckets[ibucket].truncated_hash_ref());
+          dist_from_ideal_bucket = distance;
+        }
+      }
+    }
+  }
+
+  template <class T = values_container_type,
+            typename std::enable_if<is_vector<T>::value>::type* = nullptr>
+  void reserve_space_for_values(size_type count) {
+    m_values.reserve(count);
+  }
+
+  template <class T = values_container_type,
+            typename std::enable_if<!is_vector<T>::value>::type* = nullptr>
+  void reserve_space_for_values(size_type /*count*/) {}
+
+  /**
+   * Swap the empty bucket with the values on its right until we cross another
+   * empty bucket or if the other bucket has a distance_from_ideal_bucket == 0.
+   */
+  void backward_shift(std::size_t empty_ibucket) noexcept {
+    tsl_oh_assert(m_buckets[empty_ibucket].empty());
+
+    std::size_t previous_ibucket = empty_ibucket;
+    for (std::size_t current_ibucket = next_bucket(previous_ibucket);
+         !m_buckets[current_ibucket].empty() &&
+         distance_from_ideal_bucket(current_ibucket) > 0;
+         previous_ibucket = current_ibucket,
+                     current_ibucket = next_bucket(current_ibucket)) {
+      std::swap(m_buckets[current_ibucket], m_buckets[previous_ibucket]);
+    }
+  }
+
+  void erase_value_from_bucket(
+      typename buckets_container_type::iterator it_bucket) {
+    tsl_oh_assert(it_bucket != m_buckets_data.end() && !it_bucket->empty());
+
+    m_values.erase(m_values.begin() + it_bucket->index());
+
+    /*
+     * m_values.erase shifted all the values on the right of the erased value,
+     * shift the indexes by -1 in the buckets array for these values.
+     */
+    if (it_bucket->index() != m_values.size()) {
+      shift_indexes_in_buckets(it_bucket->index() + 1, -1);
+    }
+
+    // Mark the bucket as empty and do a backward shift of the values on the
+    // right
+    it_bucket->clear();
+    backward_shift(
+        std::size_t(std::distance(m_buckets_data.begin(), it_bucket)));
+  }
+
+  /**
+   * Shift any index >= index_above_or_equal in m_buckets_data by delta.
+   *
+   * delta must be equal to 1 or -1.
+   */
+  void shift_indexes_in_buckets(index_type index_above_or_equal,
+                                int delta) noexcept {
+    tsl_oh_assert(delta == 1 || delta == -1);
+
+    for (bucket_entry& bucket : m_buckets_data) {
+      if (!bucket.empty() && bucket.index() >= index_above_or_equal) {
+        tsl_oh_assert(delta >= 0 ||
+                      bucket.index() >= static_cast<index_type>(-delta));
+        tsl_oh_assert(delta <= 0 ||
+                      (bucket_entry::max_size() - bucket.index()) >=
+                          static_cast<index_type>(delta));
+        bucket.set_index(static_cast<index_type>(bucket.index() + delta));
+      }
+    }
+  }
+
+  template <class K>
+  size_type erase_impl(const K& key, std::size_t hash) {
+    auto it_bucket = find_key(key, hash);
+    if (it_bucket != m_buckets_data.end()) {
+      erase_value_from_bucket(it_bucket);
+
+      return 1;
+    } else {
+      return 0;
+    }
+  }
+
+  /**
+   * Insert the element at the end.
+   */
+  template <class K, class... Args>
+  std::pair<iterator, bool> insert_impl(const K& key,
+                                        Args&&... value_type_args) {
+    const std::size_t hash = hash_key(key);
+
+    std::size_t ibucket = bucket_for_hash(hash);
+    std::size_t dist_from_ideal_bucket = 0;
+
+    while (!m_buckets[ibucket].empty() &&
+           dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
+      if (m_buckets[ibucket].truncated_hash() ==
+              bucket_entry::truncate_hash(hash) &&
+          compare_keys(key,
+                       KeySelect()(m_values[m_buckets[ibucket].index()]))) {
+        return std::make_pair(begin() + m_buckets[ibucket].index(), false);
+      }
+
+      ibucket = next_bucket(ibucket);
+      dist_from_ideal_bucket++;
+    }
+
+    if (size() >= max_size()) {
+      TSL_OH_THROW_OR_TERMINATE(
+          std::length_error, "We reached the maximum size for the hash table.");
+    }
+
+    if (grow_on_high_load()) {
+      ibucket = bucket_for_hash(hash);
+      dist_from_ideal_bucket = 0;
+    }
+
+    m_values.emplace_back(std::forward<Args>(value_type_args)...);
+    insert_index(ibucket, dist_from_ideal_bucket,
+                 index_type(m_values.size() - 1),
+                 bucket_entry::truncate_hash(hash));
+
+    return std::make_pair(std::prev(end()), true);
+  }
+
+  /**
+   * Insert the element before insert_position.
+   */
+  template <class K, class... Args>
+  std::pair<iterator, bool> insert_at_position_impl(
+      typename values_container_type::const_iterator insert_position,
+      const K& key, Args&&... value_type_args) {
+    const std::size_t hash = hash_key(key);
+
+    std::size_t ibucket = bucket_for_hash(hash);
+    std::size_t dist_from_ideal_bucket = 0;
+
+    while (!m_buckets[ibucket].empty() &&
+           dist_from_ideal_bucket <= distance_from_ideal_bucket(ibucket)) {
+      if (m_buckets[ibucket].truncated_hash() ==
+              bucket_entry::truncate_hash(hash) &&
+          compare_keys(key,
+                       KeySelect()(m_values[m_buckets[ibucket].index()]))) {
+        return std::make_pair(begin() + m_buckets[ibucket].index(), false);
+      }
+
+      ibucket = next_bucket(ibucket);
+      dist_from_ideal_bucket++;
+    }
+
+    if (size() >= max_size()) {
+      TSL_OH_THROW_OR_TERMINATE(
+          std::length_error, "We reached the maximum size for the hash table.");
+    }
+
+    if (grow_on_high_load()) {
+      ibucket = bucket_for_hash(hash);
+      dist_from_ideal_bucket = 0;
+    }
+
+    const index_type index_insert_position =
+        index_type(std::distance(m_values.cbegin(), insert_position));
+
+#ifdef TSL_OH_NO_CONTAINER_EMPLACE_CONST_ITERATOR
+    m_values.emplace(
+        m_values.begin() + std::distance(m_values.cbegin(), insert_position),
+        std::forward<Args>(value_type_args)...);
+#else
+    m_values.emplace(insert_position, std::forward<Args>(value_type_args)...);
+#endif
+
+    /*
+     * The insertion didn't happend at the end of the m_values container,
+     * we need to shift the indexes in m_buckets_data.
+     */
+    if (index_insert_position != m_values.size() - 1) {
+      shift_indexes_in_buckets(index_insert_position, 1);
+    }
+
+    insert_index(ibucket, dist_from_ideal_bucket, index_insert_position,
+                 bucket_entry::truncate_hash(hash));
+
+    return std::make_pair(iterator(m_values.begin() + index_insert_position),
+                          true);
+  }
+
+  void insert_index(std::size_t ibucket, std::size_t dist_from_ideal_bucket,
+                    index_type index_insert,
+                    truncated_hash_type hash_insert) noexcept {
+    while (!m_buckets[ibucket].empty()) {
+      const std::size_t distance = distance_from_ideal_bucket(ibucket);
+      if (dist_from_ideal_bucket > distance) {
+        std::swap(index_insert, m_buckets[ibucket].index_ref());
+        std::swap(hash_insert, m_buckets[ibucket].truncated_hash_ref());
+
+        dist_from_ideal_bucket = distance;
+      }
+
+      ibucket = next_bucket(ibucket);
+      dist_from_ideal_bucket++;
+
+      if (dist_from_ideal_bucket > REHASH_ON_HIGH_NB_PROBES__NPROBES &&
+          !m_grow_on_next_insert &&
+          load_factor() >= REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR) {
+        // We don't want to grow the map now as we need this method to be
+        // noexcept. Do it on next insert.
+        m_grow_on_next_insert = true;
+      }
+    }
+
+    m_buckets[ibucket].set_index(index_insert);
+    m_buckets[ibucket].set_hash(hash_insert);
+  }
+
+  std::size_t distance_from_ideal_bucket(std::size_t ibucket) const noexcept {
+    const std::size_t ideal_bucket =
+        bucket_for_hash(m_buckets[ibucket].truncated_hash());
+
+    if (ibucket >= ideal_bucket) {
+      return ibucket - ideal_bucket;
+    }
+    // If the bucket is smaller than the ideal bucket for the value, there was a
+    // wrapping at the end of the bucket array due to the modulo.
+    else {
+      return (bucket_count() + ibucket) - ideal_bucket;
+    }
+  }
+
+  std::size_t next_bucket(std::size_t index) const noexcept {
+    tsl_oh_assert(index < m_buckets_data.size());
+
+    index++;
+    return (index < m_buckets_data.size()) ? index : 0;
+  }
+
+  std::size_t bucket_for_hash(std::size_t hash) const noexcept {
+    return hash & m_hash_mask;
+  }
+
+  std::size_t iterator_to_index(const_iterator it) const noexcept {
+    const auto dist = std::distance(cbegin(), it);
+    tsl_oh_assert(dist >= 0);
+
+    return std::size_t(dist);
+  }
+
+  /**
+   * Return true if the map has been rehashed.
+   */
+  bool grow_on_high_load() {
+    if (m_grow_on_next_insert || size() >= m_load_threshold) {
+      rehash_impl(std::max(size_type(1), bucket_count() * 2));
+      m_grow_on_next_insert = false;
+
+      return true;
+    } else {
+      return false;
+    }
+  }
+
+  template <class Serializer>
+  void serialize_impl(Serializer& serializer) const {
+    const slz_size_type version = SERIALIZATION_PROTOCOL_VERSION;
+    serializer(version);
+
+    const slz_size_type nb_elements = m_values.size();
+    serializer(nb_elements);
+
+    const slz_size_type bucket_count = m_buckets_data.size();
+    serializer(bucket_count);
+
+    const float max_load_factor = m_max_load_factor;
+    serializer(max_load_factor);
+
+    for (const value_type& value : m_values) {
+      serializer(value);
+    }
+
+    for (const bucket_entry& bucket : m_buckets_data) {
+      bucket.serialize(serializer);
+    }
+  }
+
+  template <class Deserializer>
+  void deserialize_impl(Deserializer& deserializer, bool hash_compatible) {
+    tsl_oh_assert(m_buckets_data.empty());  // Current hash table must be empty
+
+    const slz_size_type version =
+        deserialize_value<slz_size_type>(deserializer);
+    // For now we only have one version of the serialization protocol.
+    // If it doesn't match there is a problem with the file.
+    if (version != SERIALIZATION_PROTOCOL_VERSION) {
+      TSL_OH_THROW_OR_TERMINATE(std::runtime_error,
+                                "Can't deserialize the ordered_map/set. "
+                                "The protocol version header is invalid.");
+    }
+
+    const slz_size_type nb_elements =
+        deserialize_value<slz_size_type>(deserializer);
+    const slz_size_type bucket_count_ds =
+        deserialize_value<slz_size_type>(deserializer);
+    const float max_load_factor = deserialize_value<float>(deserializer);
+
+    if (max_load_factor < MAX_LOAD_FACTOR__MINIMUM ||
+        max_load_factor > MAX_LOAD_FACTOR__MAXIMUM) {
+      TSL_OH_THROW_OR_TERMINATE(
+          std::runtime_error,
+          "Invalid max_load_factor. Check that the serializer "
+          "and deserializer support floats correctly as they "
+          "can be converted implicitly to ints.");
+    }
+
+    this->max_load_factor(max_load_factor);
+
+    if (bucket_count_ds == 0) {
+      tsl_oh_assert(nb_elements == 0);
+      return;
+    }
+
+    if (!hash_compatible) {
+      reserve(numeric_cast<size_type>(nb_elements,
+                                      "Deserialized nb_elements is too big."));
+      for (slz_size_type el = 0; el < nb_elements; el++) {
+        insert(deserialize_value<value_type>(deserializer));
+      }
+    } else {
+      m_buckets_data.reserve(numeric_cast<size_type>(
+          bucket_count_ds, "Deserialized bucket_count is too big."));
+      m_buckets = m_buckets_data.data(),
+      m_hash_mask = m_buckets_data.capacity() - 1;
+
+      reserve_space_for_values(numeric_cast<size_type>(
+          nb_elements, "Deserialized nb_elements is too big."));
+      for (slz_size_type el = 0; el < nb_elements; el++) {
+        m_values.push_back(deserialize_value<value_type>(deserializer));
+      }
+
+      for (slz_size_type b = 0; b < bucket_count_ds; b++) {
+        m_buckets_data.push_back(bucket_entry::deserialize(deserializer));
+      }
+    }
+  }
+
+  static std::size_t round_up_to_power_of_two(std::size_t value) {
+    if (is_power_of_two(value)) {
+      return value;
+    }
+
+    if (value == 0) {
+      return 1;
+    }
+
+    --value;
+    for (std::size_t i = 1; i < sizeof(std::size_t) * CHAR_BIT; i *= 2) {
+      value |= value >> i;
+    }
+
+    return value + 1;
+  }
+
+  static constexpr bool is_power_of_two(std::size_t value) {
+    return value != 0 && (value & (value - 1)) == 0;
+  }
+
+ public:
+  static const size_type DEFAULT_INIT_BUCKETS_SIZE = 0;
+  static constexpr float DEFAULT_MAX_LOAD_FACTOR = 0.75f;
+
+ private:
+  static constexpr float MAX_LOAD_FACTOR__MINIMUM = 0.1f;
+  static constexpr float MAX_LOAD_FACTOR__MAXIMUM = 0.95f;
+
+  static const size_type REHASH_ON_HIGH_NB_PROBES__NPROBES = 128;
+  static constexpr float REHASH_ON_HIGH_NB_PROBES__MIN_LOAD_FACTOR = 0.15f;
+
+  /**
+   * Protocol version currenlty used for serialization.
+   */
+  static const slz_size_type SERIALIZATION_PROTOCOL_VERSION = 1;
+
+  /**
+   * Return an always valid pointer to an static empty bucket_entry with
+   * last_bucket() == true.
+   */
+  bucket_entry* static_empty_bucket_ptr() {
+    static bucket_entry empty_bucket;
+    return &empty_bucket;
+  }
+
+ private:
+  buckets_container_type m_buckets_data;
+
+  /**
+   * Points to m_buckets_data.data() if !m_buckets_data.empty() otherwise points
+   * to static_empty_bucket_ptr. This variable is useful to avoid the cost of
+   * checking if m_buckets_data is empty when trying to find an element.
+   *
+   * TODO Remove m_buckets_data and only use a pointer+size instead of a
+   * pointer+vector to save some space in the ordered_hash object.
+   */
+  bucket_entry* m_buckets;
+
+  size_type m_hash_mask;
+
+  values_container_type m_values;
+
+  size_type m_load_threshold;
+  float m_max_load_factor;
+
+  bool m_grow_on_next_insert;
+};
+
+}  // end namespace detail_ordered_hash
+
+}  // end namespace tsl
+
+#endif
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_map.h lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_map.h
--- lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_map.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_map.h	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,996 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef TSL_ORDERED_MAP_H
+#define TSL_ORDERED_MAP_H
+
+#include <cstddef>
+#include <cstdint>
+#include <deque>
+#include <functional>
+#include <initializer_list>
+#include <memory>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#include "ordered_hash.h"
+
+namespace tsl {
+
+/**
+ * Implementation of an hash map using open addressing with robin hood with
+ * backshift delete to resolve collisions.
+ *
+ * The particularity of this hash map is that it remembers the order in which
+ * the elements were added and provide a way to access the structure which
+ * stores these values through the 'values_container()' method. The used
+ * container is defined by ValueTypeContainer, by default a std::deque is used
+ * (grows faster) but a std::vector may be used. In this case the map provides a
+ * 'data()' method which give a direct access to the memory used to store the
+ * values (which can be useful to communicate with C API's).
+ *
+ * The Key and T must be copy constructible and/or move constructible. To use
+ * `unordered_erase` they both must be swappable.
+ *
+ * The behaviour of the hash map is undefined if the destructor of Key or T
+ * throws an exception.
+ *
+ * By default the maximum size of a map is limited to 2^32 - 1 values, if needed
+ * this can be changed through the IndexType template parameter. Using an
+ * `uint64_t` will raise this limit to 2^64 - 1 values but each bucket will use
+ * 16 bytes instead of 8 bytes in addition to the space needed to store the
+ * values.
+ *
+ * Iterators invalidation:
+ *  - clear, operator=, reserve, rehash: always invalidate the iterators (also
+ * invalidate end()).
+ *  - insert, emplace, emplace_hint, operator[]: when a std::vector is used as
+ * ValueTypeContainer and if size() < capacity(), only end(). Otherwise all the
+ * iterators are invalidated if an insert occurs.
+ *  - erase, unordered_erase: when a std::vector is used as ValueTypeContainer
+ * invalidate the iterator of the erased element and all the ones after the
+ * erased element (including end()). Otherwise all the iterators are invalidated
+ * if an erase occurs.
+ */
+template <class Key, class T, class Hash = std::hash<Key>,
+          class KeyEqual = std::equal_to<Key>,
+          class Allocator = std::allocator<std::pair<Key, T>>,
+          class ValueTypeContainer = std::deque<std::pair<Key, T>, Allocator>,
+          class IndexType = std::uint_least32_t>
+class ordered_map {
+ private:
+  template <typename U>
+  using has_is_transparent = tsl::detail_ordered_hash::has_is_transparent<U>;
+
+  class KeySelect {
+   public:
+    using key_type = Key;
+
+    const key_type& operator()(
+        const std::pair<Key, T>& key_value) const noexcept {
+      return key_value.first;
+    }
+
+    key_type& operator()(std::pair<Key, T>& key_value) noexcept {
+      return key_value.first;
+    }
+  };
+
+  class ValueSelect {
+   public:
+    using value_type = T;
+
+    const value_type& operator()(
+        const std::pair<Key, T>& key_value) const noexcept {
+      return key_value.second;
+    }
+
+    value_type& operator()(std::pair<Key, T>& key_value) noexcept {
+      return key_value.second;
+    }
+  };
+
+  using ht =
+      detail_ordered_hash::ordered_hash<std::pair<Key, T>, KeySelect,
+                                        ValueSelect, Hash, KeyEqual, Allocator,
+                                        ValueTypeContainer, IndexType>;
+
+ public:
+  using key_type = typename ht::key_type;
+  using mapped_type = T;
+  using value_type = typename ht::value_type;
+  using size_type = typename ht::size_type;
+  using difference_type = typename ht::difference_type;
+  using hasher = typename ht::hasher;
+  using key_equal = typename ht::key_equal;
+  using allocator_type = typename ht::allocator_type;
+  using reference = typename ht::reference;
+  using const_reference = typename ht::const_reference;
+  using pointer = typename ht::pointer;
+  using const_pointer = typename ht::const_pointer;
+  using iterator = typename ht::iterator;
+  using const_iterator = typename ht::const_iterator;
+  using reverse_iterator = typename ht::reverse_iterator;
+  using const_reverse_iterator = typename ht::const_reverse_iterator;
+
+  using values_container_type = typename ht::values_container_type;
+
+  /*
+   * Constructors
+   */
+  ordered_map() : ordered_map(ht::DEFAULT_INIT_BUCKETS_SIZE) {}
+
+  explicit ordered_map(size_type bucket_count, const Hash& hash = Hash(),
+                       const KeyEqual& equal = KeyEqual(),
+                       const Allocator& alloc = Allocator())
+      : m_ht(bucket_count, hash, equal, alloc, ht::DEFAULT_MAX_LOAD_FACTOR) {}
+
+  ordered_map(size_type bucket_count, const Allocator& alloc)
+      : ordered_map(bucket_count, Hash(), KeyEqual(), alloc) {}
+
+  ordered_map(size_type bucket_count, const Hash& hash, const Allocator& alloc)
+      : ordered_map(bucket_count, hash, KeyEqual(), alloc) {}
+
+  explicit ordered_map(const Allocator& alloc)
+      : ordered_map(ht::DEFAULT_INIT_BUCKETS_SIZE, alloc) {}
+
+  template <class InputIt>
+  ordered_map(InputIt first, InputIt last,
+              size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
+              const Hash& hash = Hash(), const KeyEqual& equal = KeyEqual(),
+              const Allocator& alloc = Allocator())
+      : ordered_map(bucket_count, hash, equal, alloc) {
+    insert(first, last);
+  }
+
+  template <class InputIt>
+  ordered_map(InputIt first, InputIt last, size_type bucket_count,
+              const Allocator& alloc)
+      : ordered_map(first, last, bucket_count, Hash(), KeyEqual(), alloc) {}
+
+  template <class InputIt>
+  ordered_map(InputIt first, InputIt last, size_type bucket_count,
+              const Hash& hash, const Allocator& alloc)
+      : ordered_map(first, last, bucket_count, hash, KeyEqual(), alloc) {}
+
+  ordered_map(std::initializer_list<value_type> init,
+              size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
+              const Hash& hash = Hash(), const KeyEqual& equal = KeyEqual(),
+              const Allocator& alloc = Allocator())
+      : ordered_map(init.begin(), init.end(), bucket_count, hash, equal,
+                    alloc) {}
+
+  ordered_map(std::initializer_list<value_type> init, size_type bucket_count,
+              const Allocator& alloc)
+      : ordered_map(init.begin(), init.end(), bucket_count, Hash(), KeyEqual(),
+                    alloc) {}
+
+  ordered_map(std::initializer_list<value_type> init, size_type bucket_count,
+              const Hash& hash, const Allocator& alloc)
+      : ordered_map(init.begin(), init.end(), bucket_count, hash, KeyEqual(),
+                    alloc) {}
+
+  ordered_map& operator=(std::initializer_list<value_type> ilist) {
+    m_ht.clear();
+
+    m_ht.reserve(ilist.size());
+    m_ht.insert(ilist.begin(), ilist.end());
+
+    return *this;
+  }
+
+  allocator_type get_allocator() const { return m_ht.get_allocator(); }
+
+  /*
+   * Iterators
+   */
+  iterator begin() noexcept { return m_ht.begin(); }
+  const_iterator begin() const noexcept { return m_ht.begin(); }
+  const_iterator cbegin() const noexcept { return m_ht.cbegin(); }
+
+  iterator end() noexcept { return m_ht.end(); }
+  const_iterator end() const noexcept { return m_ht.end(); }
+  const_iterator cend() const noexcept { return m_ht.cend(); }
+
+  reverse_iterator rbegin() noexcept { return m_ht.rbegin(); }
+  const_reverse_iterator rbegin() const noexcept { return m_ht.rbegin(); }
+  const_reverse_iterator rcbegin() const noexcept { return m_ht.rcbegin(); }
+
+  reverse_iterator rend() noexcept { return m_ht.rend(); }
+  const_reverse_iterator rend() const noexcept { return m_ht.rend(); }
+  const_reverse_iterator rcend() const noexcept { return m_ht.rcend(); }
+
+  /*
+   * Capacity
+   */
+  bool empty() const noexcept { return m_ht.empty(); }
+  size_type size() const noexcept { return m_ht.size(); }
+  size_type max_size() const noexcept { return m_ht.max_size(); }
+
+  /*
+   * Modifiers
+   */
+  void clear() noexcept { m_ht.clear(); }
+
+  std::pair<iterator, bool> insert(const value_type& value) {
+    return m_ht.insert(value);
+  }
+
+  template <class P, typename std::enable_if<std::is_constructible<
+                         value_type, P&&>::value>::type* = nullptr>
+  std::pair<iterator, bool> insert(P&& value) {
+    return m_ht.emplace(std::forward<P>(value));
+  }
+
+  std::pair<iterator, bool> insert(value_type&& value) {
+    return m_ht.insert(std::move(value));
+  }
+
+  iterator insert(const_iterator hint, const value_type& value) {
+    return m_ht.insert_hint(hint, value);
+  }
+
+  template <class P, typename std::enable_if<std::is_constructible<
+                         value_type, P&&>::value>::type* = nullptr>
+  iterator insert(const_iterator hint, P&& value) {
+    return m_ht.emplace_hint(hint, std::forward<P>(value));
+  }
+
+  iterator insert(const_iterator hint, value_type&& value) {
+    return m_ht.insert_hint(hint, std::move(value));
+  }
+
+  template <class InputIt>
+  void insert(InputIt first, InputIt last) {
+    m_ht.insert(first, last);
+  }
+  void insert(std::initializer_list<value_type> ilist) {
+    m_ht.insert(ilist.begin(), ilist.end());
+  }
+
+  template <class M>
+  std::pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj) {
+    return m_ht.insert_or_assign(k, std::forward<M>(obj));
+  }
+
+  template <class M>
+  std::pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj) {
+    return m_ht.insert_or_assign(std::move(k), std::forward<M>(obj));
+  }
+
+  template <class M>
+  iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj) {
+    return m_ht.insert_or_assign(hint, k, std::forward<M>(obj));
+  }
+
+  template <class M>
+  iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj) {
+    return m_ht.insert_or_assign(hint, std::move(k), std::forward<M>(obj));
+  }
+
+  /**
+   * Due to the way elements are stored, emplace will need to move or copy the
+   * key-value once. The method is equivalent to
+   * insert(value_type(std::forward<Args>(args)...));
+   *
+   * Mainly here for compatibility with the std::unordered_map interface.
+   */
+  template <class... Args>
+  std::pair<iterator, bool> emplace(Args&&... args) {
+    return m_ht.emplace(std::forward<Args>(args)...);
+  }
+
+  /**
+   * Due to the way elements are stored, emplace_hint will need to move or copy
+   * the key-value once. The method is equivalent to insert(hint,
+   * value_type(std::forward<Args>(args)...));
+   *
+   * Mainly here for compatibility with the std::unordered_map interface.
+   */
+  template <class... Args>
+  iterator emplace_hint(const_iterator hint, Args&&... args) {
+    return m_ht.emplace_hint(hint, std::forward<Args>(args)...);
+  }
+
+  template <class... Args>
+  std::pair<iterator, bool> try_emplace(const key_type& k, Args&&... args) {
+    return m_ht.try_emplace(k, std::forward<Args>(args)...);
+  }
+
+  template <class... Args>
+  std::pair<iterator, bool> try_emplace(key_type&& k, Args&&... args) {
+    return m_ht.try_emplace(std::move(k), std::forward<Args>(args)...);
+  }
+
+  template <class... Args>
+  iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args) {
+    return m_ht.try_emplace_hint(hint, k, std::forward<Args>(args)...);
+  }
+
+  template <class... Args>
+  iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args) {
+    return m_ht.try_emplace_hint(hint, std::move(k),
+                                 std::forward<Args>(args)...);
+  }
+
+  /**
+   * When erasing an element, the insert order will be preserved and no holes
+   * will be present in the container returned by 'values_container()'.
+   *
+   * The method is in O(bucket_count()), if the order is not important
+   * 'unordered_erase(...)' method is faster with an O(1) average complexity.
+   */
+  iterator erase(iterator pos) { return m_ht.erase(pos); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  iterator erase(const_iterator pos) { return m_ht.erase(pos); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  iterator erase(const_iterator first, const_iterator last) {
+    return m_ht.erase(first, last);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  size_type erase(const key_type& key) { return m_ht.erase(key); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup to the value if you already have the hash.
+   */
+  size_type erase(const key_type& key, std::size_t precalculated_hash) {
+    return m_ht.erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type erase(const K& key) {
+    return m_ht.erase(key);
+  }
+
+  /**
+   * @copydoc erase(const key_type& key, std::size_t precalculated_hash)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type erase(const K& key, std::size_t precalculated_hash) {
+    return m_ht.erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * Erases all elements that satisfy the predicate pred. The method is in
+   * O(n). Note that the function only has the strong exception guarantee if
+   * the Predicate, Hash, and Key predicates and moves of keys and values do
+   * not throw. If an exception is raised, the object is in an invalid state.
+   * It can still be cleared and destroyed without leaking memory.
+   */
+  template <class Predicate>
+  friend size_type erase_if(ordered_map &map, Predicate pred) {
+    return map.m_ht.erase_if(pred);
+  }
+
+  void swap(ordered_map& other) { other.m_ht.swap(m_ht); }
+
+  /*
+   * Lookup
+   */
+  T& at(const Key& key) { return m_ht.at(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  T& at(const Key& key, std::size_t precalculated_hash) {
+    return m_ht.at(key, precalculated_hash);
+  }
+
+  const T& at(const Key& key) const { return m_ht.at(key); }
+
+  /**
+   * @copydoc at(const Key& key, std::size_t precalculated_hash)
+   */
+  const T& at(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.at(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  T& at(const K& key) {
+    return m_ht.at(key);
+  }
+
+  /**
+   * @copydoc at(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  T& at(const K& key, std::size_t precalculated_hash) {
+    return m_ht.at(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc at(const K& key)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const T& at(const K& key) const {
+    return m_ht.at(key);
+  }
+
+  /**
+   * @copydoc at(const K& key, std::size_t precalculated_hash)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const T& at(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.at(key, precalculated_hash);
+  }
+
+  T& operator[](const Key& key) { return m_ht[key]; }
+  T& operator[](Key&& key) { return m_ht[std::move(key)]; }
+
+  size_type count(const Key& key) const { return m_ht.count(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  size_type count(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.count(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type count(const K& key) const {
+    return m_ht.count(key);
+  }
+
+  /**
+   * @copydoc count(const K& key) const
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type count(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.count(key, precalculated_hash);
+  }
+
+  iterator find(const Key& key) { return m_ht.find(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  iterator find(const Key& key, std::size_t precalculated_hash) {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  const_iterator find(const Key& key) const { return m_ht.find(key); }
+
+  /**
+   * @copydoc find(const Key& key, std::size_t precalculated_hash)
+   */
+  const_iterator find(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  iterator find(const K& key) {
+    return m_ht.find(key);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  iterator find(const K& key, std::size_t precalculated_hash) {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const_iterator find(const K& key) const {
+    return m_ht.find(key);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const_iterator find(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  bool contains(const Key& key) const { return m_ht.contains(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  bool contains(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.contains(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  bool contains(const K& key) const {
+    return m_ht.contains(key);
+  }
+
+  /**
+   * @copydoc contains(const K& key) const
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  bool contains(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.contains(key, precalculated_hash);
+  }
+
+  std::pair<iterator, iterator> equal_range(const Key& key) {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  std::pair<iterator, iterator> equal_range(const Key& key,
+                                            std::size_t precalculated_hash) {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  std::pair<const_iterator, const_iterator> equal_range(const Key& key) const {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const Key& key, std::size_t precalculated_hash)
+   */
+  std::pair<const_iterator, const_iterator> equal_range(
+      const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<iterator, iterator> equal_range(const K& key) {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<iterator, iterator> equal_range(const K& key,
+                                            std::size_t precalculated_hash) {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<const_iterator, const_iterator> equal_range(const K& key) const {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key, std::size_t precalculated_hash)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<const_iterator, const_iterator> equal_range(
+      const K& key, std::size_t precalculated_hash) const {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /*
+   * Bucket interface
+   */
+  size_type bucket_count() const { return m_ht.bucket_count(); }
+  size_type max_bucket_count() const { return m_ht.max_bucket_count(); }
+
+  /*
+   * Hash policy
+   */
+  float load_factor() const { return m_ht.load_factor(); }
+  float max_load_factor() const { return m_ht.max_load_factor(); }
+  void max_load_factor(float ml) { m_ht.max_load_factor(ml); }
+
+  void rehash(size_type count) { m_ht.rehash(count); }
+  void reserve(size_type count) { m_ht.reserve(count); }
+
+  /*
+   * Observers
+   */
+  hasher hash_function() const { return m_ht.hash_function(); }
+  key_equal key_eq() const { return m_ht.key_eq(); }
+
+  /*
+   * Other
+   */
+
+  /**
+   * Convert a const_iterator to an iterator.
+   */
+  iterator mutable_iterator(const_iterator pos) {
+    return m_ht.mutable_iterator(pos);
+  }
+
+  /**
+   * Requires index <= size().
+   *
+   * Return an iterator to the element at index. Return end() if index ==
+   * size().
+   */
+  iterator nth(size_type index) { return m_ht.nth(index); }
+
+  /**
+   * @copydoc nth(size_type index)
+   */
+  const_iterator nth(size_type index) const { return m_ht.nth(index); }
+
+  /**
+   * Return const_reference to the first element. Requires the container to not
+   * be empty.
+   */
+  const_reference front() const { return m_ht.front(); }
+
+  /**
+   * Return const_reference to the last element. Requires the container to not
+   * be empty.
+   */
+  const_reference back() const { return m_ht.back(); }
+
+  /**
+   * Only available if ValueTypeContainer is a std::vector. Same as calling
+   * 'values_container().data()'.
+   */
+  template <class U = values_container_type,
+            typename std::enable_if<
+                tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>
+  const typename values_container_type::value_type* data() const noexcept {
+    return m_ht.data();
+  }
+
+  /**
+   * Return the container in which the values are stored. The values are in the
+   * same order as the insertion order and are contiguous in the structure, no
+   * holes (size() == values_container().size()).
+   */
+  const values_container_type& values_container() const noexcept {
+    return m_ht.values_container();
+  }
+
+  /**
+   * Release the container in which the values are stored.
+   *
+   * The map is empty after this operation.
+   */
+  values_container_type release() { return m_ht.release(); }
+
+  template <class U = values_container_type,
+            typename std::enable_if<
+                tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>
+  size_type capacity() const noexcept {
+    return m_ht.capacity();
+  }
+
+  void shrink_to_fit() { m_ht.shrink_to_fit(); }
+
+  /**
+   * Insert the value before pos shifting all the elements on the right of pos
+   * (including pos) one position to the right.
+   *
+   * O(bucket_count()) runtime complexity.
+   */
+  std::pair<iterator, bool> insert_at_position(const_iterator pos,
+                                               const value_type& value) {
+    return m_ht.insert_at_position(pos, value);
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   */
+  std::pair<iterator, bool> insert_at_position(const_iterator pos,
+                                               value_type&& value) {
+    return m_ht.insert_at_position(pos, std::move(value));
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   *
+   * Same as insert_at_position(pos, value_type(std::forward<Args>(args)...),
+   * mainly here for coherence.
+   */
+  template <class... Args>
+  std::pair<iterator, bool> emplace_at_position(const_iterator pos,
+                                                Args&&... args) {
+    return m_ht.emplace_at_position(pos, std::forward<Args>(args)...);
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   */
+  template <class... Args>
+  std::pair<iterator, bool> try_emplace_at_position(const_iterator pos,
+                                                    const key_type& k,
+                                                    Args&&... args) {
+    return m_ht.try_emplace_at_position(pos, k, std::forward<Args>(args)...);
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   */
+  template <class... Args>
+  std::pair<iterator, bool> try_emplace_at_position(const_iterator pos,
+                                                    key_type&& k,
+                                                    Args&&... args) {
+    return m_ht.try_emplace_at_position(pos, std::move(k),
+                                        std::forward<Args>(args)...);
+  }
+
+  void pop_back() { m_ht.pop_back(); }
+
+  /**
+   * Faster erase operation with an O(1) average complexity but it doesn't
+   * preserve the insertion order.
+   *
+   * If an erasure occurs, the last element of the map will take the place of
+   * the erased element.
+   */
+  iterator unordered_erase(iterator pos) { return m_ht.unordered_erase(pos); }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   */
+  iterator unordered_erase(const_iterator pos) {
+    return m_ht.unordered_erase(pos);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   */
+  size_type unordered_erase(const key_type& key) {
+    return m_ht.unordered_erase(key);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  size_type unordered_erase(const key_type& key,
+                            std::size_t precalculated_hash) {
+    return m_ht.unordered_erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type unordered_erase(const K& key) {
+    return m_ht.unordered_erase(key);
+  }
+
+  /**
+   * @copydoc unordered_erase(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type unordered_erase(const K& key, std::size_t precalculated_hash) {
+    return m_ht.unordered_erase(key, precalculated_hash);
+  }
+
+  /**
+   * Serialize the map through the `serializer` parameter.
+   *
+   * The `serializer` parameter must be a function object that supports the
+   * following call:
+   *  - `template<typename U> void operator()(const U& value);` where the types
+   * `std::uint64_t`, `float` and `std::pair<Key, T>` must be supported for U.
+   *
+   * The implementation leaves binary compatibility (endianness, IEEE 754 for
+   * floats, ...) of the types it serializes in the hands of the `Serializer`
+   * function object if compatibility is required.
+   */
+  template <class Serializer>
+  void serialize(Serializer& serializer) const {
+    m_ht.serialize(serializer);
+  }
+
+  /**
+   * Deserialize a previously serialized map through the `deserializer`
+   * parameter.
+   *
+   * The `deserializer` parameter must be a function object that supports the
+   * following calls:
+   *  - `template<typename U> U operator()();` where the types `std::uint64_t`,
+   * `float` and `std::pair<Key, T>` must be supported for U.
+   *
+   * If the deserialized hash map type is hash compatible with the serialized
+   * map, the deserialization process can be sped up by setting
+   * `hash_compatible` to true. To be hash compatible, the Hash and KeyEqual
+   * must behave the same way than the ones used on the serialized map. The
+   * `std::size_t` must also be of the same size as the one on the platform used
+   * to serialize the map, the same apply for `IndexType`. If these criteria are
+   * not met, the behaviour is undefined with `hash_compatible` sets to true.
+   *
+   * The behaviour is undefined if the type `Key` and `T` of the `ordered_map`
+   * are not the same as the types used during serialization.
+   *
+   * The implementation leaves binary compatibility (endianness, IEEE 754 for
+   * floats, size of int, ...) of the types it deserializes in the hands of the
+   * `Deserializer` function object if compatibility is required.
+   */
+  template <class Deserializer>
+  static ordered_map deserialize(Deserializer& deserializer,
+                                 bool hash_compatible = false) {
+    ordered_map map(0);
+    map.m_ht.deserialize(deserializer, hash_compatible);
+
+    return map;
+  }
+
+  friend bool operator==(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht == rhs.m_ht;
+  }
+  friend bool operator!=(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht != rhs.m_ht;
+  }
+  friend bool operator<(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht < rhs.m_ht;
+  }
+  friend bool operator<=(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht <= rhs.m_ht;
+  }
+  friend bool operator>(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht > rhs.m_ht;
+  }
+  friend bool operator>=(const ordered_map& lhs, const ordered_map& rhs) {
+    return lhs.m_ht >= rhs.m_ht;
+  }
+
+  friend void swap(ordered_map& lhs, ordered_map& rhs) { lhs.swap(rhs); }
+
+ private:
+  ht m_ht;
+};
+
+}  // end namespace tsl
+
+#endif
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_set.h lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_set.h
--- lightspark-0.9.0/src/3rdparty/ordered-map/include/tsl/ordered_set.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/include/tsl/ordered_set.h	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,831 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef TSL_ORDERED_SET_H
+#define TSL_ORDERED_SET_H
+
+#include <cstddef>
+#include <cstdint>
+#include <deque>
+#include <functional>
+#include <initializer_list>
+#include <memory>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#include "ordered_hash.h"
+
+namespace tsl {
+
+/**
+ * Implementation of an hash set using open addressing with robin hood with
+ * backshift delete to resolve collisions.
+ *
+ * The particularity of this hash set is that it remembers the order in which
+ * the elements were added and provide a way to access the structure which
+ * stores these values through the 'values_container()' method. The used
+ * container is defined by ValueTypeContainer, by default a std::deque is used
+ * (grows faster) but a std::vector may be used. In this case the set provides a
+ * 'data()' method which give a direct access to the memory used to store the
+ * values (which can be useful to communicate with C API's).
+ *
+ * The Key must be copy constructible and/or move constructible. To use
+ * `unordered_erase` it also must be swappable.
+ *
+ * The behaviour of the hash set is undefined if the destructor of Key throws an
+ * exception.
+ *
+ * By default the maximum size of a set is limited to 2^32 - 1 values, if needed
+ * this can be changed through the IndexType template parameter. Using an
+ * `uint64_t` will raise this limit to 2^64 - 1 values but each bucket will use
+ * 16 bytes instead of 8 bytes in addition to the space needed to store the
+ * values.
+ *
+ * Iterators invalidation:
+ *  - clear, operator=, reserve, rehash: always invalidate the iterators (also
+ * invalidate end()).
+ *  - insert, emplace, emplace_hint, operator[]: when a std::vector is used as
+ * ValueTypeContainer and if size() < capacity(), only end(). Otherwise all the
+ * iterators are invalidated if an insert occurs.
+ *  - erase, unordered_erase: when a std::vector is used as ValueTypeContainer
+ * invalidate the iterator of the erased element and all the ones after the
+ * erased element (including end()). Otherwise all the iterators are invalidated
+ * if an erase occurs.
+ */
+template <class Key, class Hash = std::hash<Key>,
+          class KeyEqual = std::equal_to<Key>,
+          class Allocator = std::allocator<Key>,
+          class ValueTypeContainer = std::deque<Key, Allocator>,
+          class IndexType = std::uint_least32_t>
+class ordered_set {
+ private:
+  template <typename U>
+  using has_is_transparent = tsl::detail_ordered_hash::has_is_transparent<U>;
+
+  class KeySelect {
+   public:
+    using key_type = Key;
+
+    const key_type& operator()(const Key& key) const noexcept { return key; }
+
+    key_type& operator()(Key& key) noexcept { return key; }
+  };
+
+  using ht = detail_ordered_hash::ordered_hash<Key, KeySelect, void, Hash,
+                                               KeyEqual, Allocator,
+                                               ValueTypeContainer, IndexType>;
+
+ public:
+  using key_type = typename ht::key_type;
+  using value_type = typename ht::value_type;
+  using size_type = typename ht::size_type;
+  using difference_type = typename ht::difference_type;
+  using hasher = typename ht::hasher;
+  using key_equal = typename ht::key_equal;
+  using allocator_type = typename ht::allocator_type;
+  using reference = typename ht::reference;
+  using const_reference = typename ht::const_reference;
+  using pointer = typename ht::pointer;
+  using const_pointer = typename ht::const_pointer;
+  using iterator = typename ht::iterator;
+  using const_iterator = typename ht::const_iterator;
+  using reverse_iterator = typename ht::reverse_iterator;
+  using const_reverse_iterator = typename ht::const_reverse_iterator;
+
+  using values_container_type = typename ht::values_container_type;
+
+  /*
+   * Constructors
+   */
+  ordered_set() : ordered_set(ht::DEFAULT_INIT_BUCKETS_SIZE) {}
+
+  explicit ordered_set(size_type bucket_count, const Hash& hash = Hash(),
+                       const KeyEqual& equal = KeyEqual(),
+                       const Allocator& alloc = Allocator())
+      : m_ht(bucket_count, hash, equal, alloc, ht::DEFAULT_MAX_LOAD_FACTOR) {}
+
+  ordered_set(size_type bucket_count, const Allocator& alloc)
+      : ordered_set(bucket_count, Hash(), KeyEqual(), alloc) {}
+
+  ordered_set(size_type bucket_count, const Hash& hash, const Allocator& alloc)
+      : ordered_set(bucket_count, hash, KeyEqual(), alloc) {}
+
+  explicit ordered_set(const Allocator& alloc)
+      : ordered_set(ht::DEFAULT_INIT_BUCKETS_SIZE, alloc) {}
+
+  template <class InputIt>
+  ordered_set(InputIt first, InputIt last,
+              size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
+              const Hash& hash = Hash(), const KeyEqual& equal = KeyEqual(),
+              const Allocator& alloc = Allocator())
+      : ordered_set(bucket_count, hash, equal, alloc) {
+    insert(first, last);
+  }
+
+  template <class InputIt>
+  ordered_set(InputIt first, InputIt last, size_type bucket_count,
+              const Allocator& alloc)
+      : ordered_set(first, last, bucket_count, Hash(), KeyEqual(), alloc) {}
+
+  template <class InputIt>
+  ordered_set(InputIt first, InputIt last, size_type bucket_count,
+              const Hash& hash, const Allocator& alloc)
+      : ordered_set(first, last, bucket_count, hash, KeyEqual(), alloc) {}
+
+  ordered_set(std::initializer_list<value_type> init,
+              size_type bucket_count = ht::DEFAULT_INIT_BUCKETS_SIZE,
+              const Hash& hash = Hash(), const KeyEqual& equal = KeyEqual(),
+              const Allocator& alloc = Allocator())
+      : ordered_set(init.begin(), init.end(), bucket_count, hash, equal,
+                    alloc) {}
+
+  ordered_set(std::initializer_list<value_type> init, size_type bucket_count,
+              const Allocator& alloc)
+      : ordered_set(init.begin(), init.end(), bucket_count, Hash(), KeyEqual(),
+                    alloc) {}
+
+  ordered_set(std::initializer_list<value_type> init, size_type bucket_count,
+              const Hash& hash, const Allocator& alloc)
+      : ordered_set(init.begin(), init.end(), bucket_count, hash, KeyEqual(),
+                    alloc) {}
+
+  ordered_set& operator=(std::initializer_list<value_type> ilist) {
+    m_ht.clear();
+
+    m_ht.reserve(ilist.size());
+    m_ht.insert(ilist.begin(), ilist.end());
+
+    return *this;
+  }
+
+  allocator_type get_allocator() const { return m_ht.get_allocator(); }
+
+  /*
+   * Iterators
+   */
+  iterator begin() noexcept { return m_ht.begin(); }
+  const_iterator begin() const noexcept { return m_ht.begin(); }
+  const_iterator cbegin() const noexcept { return m_ht.cbegin(); }
+
+  iterator end() noexcept { return m_ht.end(); }
+  const_iterator end() const noexcept { return m_ht.end(); }
+  const_iterator cend() const noexcept { return m_ht.cend(); }
+
+  reverse_iterator rbegin() noexcept { return m_ht.rbegin(); }
+  const_reverse_iterator rbegin() const noexcept { return m_ht.rbegin(); }
+  const_reverse_iterator rcbegin() const noexcept { return m_ht.rcbegin(); }
+
+  reverse_iterator rend() noexcept { return m_ht.rend(); }
+  const_reverse_iterator rend() const noexcept { return m_ht.rend(); }
+  const_reverse_iterator rcend() const noexcept { return m_ht.rcend(); }
+
+  /*
+   * Capacity
+   */
+  bool empty() const noexcept { return m_ht.empty(); }
+  size_type size() const noexcept { return m_ht.size(); }
+  size_type max_size() const noexcept { return m_ht.max_size(); }
+
+  /*
+   * Modifiers
+   */
+  void clear() noexcept { m_ht.clear(); }
+
+  std::pair<iterator, bool> insert(const value_type& value) {
+    return m_ht.insert(value);
+  }
+  std::pair<iterator, bool> insert(value_type&& value) {
+    return m_ht.insert(std::move(value));
+  }
+
+  iterator insert(const_iterator hint, const value_type& value) {
+    return m_ht.insert_hint(hint, value);
+  }
+
+  iterator insert(const_iterator hint, value_type&& value) {
+    return m_ht.insert_hint(hint, std::move(value));
+  }
+
+  template <class InputIt>
+  void insert(InputIt first, InputIt last) {
+    m_ht.insert(first, last);
+  }
+  void insert(std::initializer_list<value_type> ilist) {
+    m_ht.insert(ilist.begin(), ilist.end());
+  }
+
+  /**
+   * Due to the way elements are stored, emplace will need to move or copy the
+   * key-value once. The method is equivalent to
+   * insert(value_type(std::forward<Args>(args)...));
+   *
+   * Mainly here for compatibility with the std::unordered_map interface.
+   */
+  template <class... Args>
+  std::pair<iterator, bool> emplace(Args&&... args) {
+    return m_ht.emplace(std::forward<Args>(args)...);
+  }
+
+  /**
+   * Due to the way elements are stored, emplace_hint will need to move or copy
+   * the key-value once. The method is equivalent to insert(hint,
+   * value_type(std::forward<Args>(args)...));
+   *
+   * Mainly here for compatibility with the std::unordered_map interface.
+   */
+  template <class... Args>
+  iterator emplace_hint(const_iterator hint, Args&&... args) {
+    return m_ht.emplace_hint(hint, std::forward<Args>(args)...);
+  }
+
+  /**
+   * When erasing an element, the insert order will be preserved and no holes
+   * will be present in the container returned by 'values_container()'.
+   *
+   * The method is in O(bucket_count()), if the order is not important
+   * 'unordered_erase(...)' method is faster with an O(1) average complexity.
+   */
+  iterator erase(iterator pos) { return m_ht.erase(pos); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  iterator erase(const_iterator pos) { return m_ht.erase(pos); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  iterator erase(const_iterator first, const_iterator last) {
+    return m_ht.erase(first, last);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   */
+  size_type erase(const key_type& key) { return m_ht.erase(key); }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup to the value if you already have the hash.
+   */
+  size_type erase(const key_type& key, std::size_t precalculated_hash) {
+    return m_ht.erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type erase(const K& key) {
+    return m_ht.erase(key);
+  }
+
+  /**
+   * @copydoc erase(const key_type& key, std::size_t precalculated_hash)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type erase(const K& key, std::size_t precalculated_hash) {
+    return m_ht.erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc erase(iterator pos)
+   *
+   * Erases all elements that satisfy the predicate pred. The method is in
+   * O(n). Note that the function only has the strong exception guarantee if
+   * the Predicate, Hash, and Key predicates and moves of keys and values do
+   * not throw. If an exception is raised, the object is in an invalid state.
+   * It can still be cleared and destroyed without leaking memory.
+   */
+  template <class Predicate>
+  friend size_type erase_if(ordered_set &set, Predicate pred) {
+    return set.m_ht.erase_if(pred);
+  }
+
+  void swap(ordered_set& other) { other.m_ht.swap(m_ht); }
+
+  /*
+   * Lookup
+   */
+  size_type count(const Key& key) const { return m_ht.count(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  size_type count(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.count(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type count(const K& key) const {
+    return m_ht.count(key);
+  }
+
+  /**
+   * @copydoc count(const K& key) const
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type count(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.count(key, precalculated_hash);
+  }
+
+  iterator find(const Key& key) { return m_ht.find(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  iterator find(const Key& key, std::size_t precalculated_hash) {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  const_iterator find(const Key& key) const { return m_ht.find(key); }
+
+  /**
+   * @copydoc find(const Key& key, std::size_t precalculated_hash)
+   */
+  const_iterator find(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  iterator find(const K& key) {
+    return m_ht.find(key);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  iterator find(const K& key, std::size_t precalculated_hash) {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const_iterator find(const K& key) const {
+    return m_ht.find(key);
+  }
+
+  /**
+   * @copydoc find(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  const_iterator find(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.find(key, precalculated_hash);
+  }
+
+  bool contains(const Key& key) const { return m_ht.contains(key); }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  bool contains(const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.contains(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  bool contains(const K& key) const {
+    return m_ht.contains(key);
+  }
+
+  /**
+   * @copydoc contains(const K& key) const
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  bool contains(const K& key, std::size_t precalculated_hash) const {
+    return m_ht.contains(key, precalculated_hash);
+  }
+
+  std::pair<iterator, iterator> equal_range(const Key& key) {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  std::pair<iterator, iterator> equal_range(const Key& key,
+                                            std::size_t precalculated_hash) {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  std::pair<const_iterator, const_iterator> equal_range(const Key& key) const {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const Key& key, std::size_t precalculated_hash)
+   */
+  std::pair<const_iterator, const_iterator> equal_range(
+      const Key& key, std::size_t precalculated_hash) const {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /**
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<iterator, iterator> equal_range(const K& key) {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<iterator, iterator> equal_range(const K& key,
+                                            std::size_t precalculated_hash) {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<const_iterator, const_iterator> equal_range(const K& key) const {
+    return m_ht.equal_range(key);
+  }
+
+  /**
+   * @copydoc equal_range(const K& key, std::size_t precalculated_hash)
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  std::pair<const_iterator, const_iterator> equal_range(
+      const K& key, std::size_t precalculated_hash) const {
+    return m_ht.equal_range(key, precalculated_hash);
+  }
+
+  /*
+   * Bucket interface
+   */
+  size_type bucket_count() const { return m_ht.bucket_count(); }
+  size_type max_bucket_count() const { return m_ht.max_bucket_count(); }
+
+  /*
+   *  Hash policy
+   */
+  float load_factor() const { return m_ht.load_factor(); }
+  float max_load_factor() const { return m_ht.max_load_factor(); }
+  void max_load_factor(float ml) { m_ht.max_load_factor(ml); }
+
+  void rehash(size_type count) { m_ht.rehash(count); }
+  void reserve(size_type count) { m_ht.reserve(count); }
+
+  /*
+   * Observers
+   */
+  hasher hash_function() const { return m_ht.hash_function(); }
+  key_equal key_eq() const { return m_ht.key_eq(); }
+
+  /*
+   * Other
+   */
+
+  /**
+   * Convert a const_iterator to an iterator.
+   */
+  iterator mutable_iterator(const_iterator pos) {
+    return m_ht.mutable_iterator(pos);
+  }
+
+  /**
+   * Requires index <= size().
+   *
+   * Return an iterator to the element at index. Return end() if index ==
+   * size().
+   */
+  iterator nth(size_type index) { return m_ht.nth(index); }
+
+  /**
+   * @copydoc nth(size_type index)
+   */
+  const_iterator nth(size_type index) const { return m_ht.nth(index); }
+
+  /**
+   * Return const_reference to the first element. Requires the container to not
+   * be empty.
+   */
+  const_reference front() const { return m_ht.front(); }
+
+  /**
+   * Return const_reference to the last element. Requires the container to not
+   * be empty.
+   */
+  const_reference back() const { return m_ht.back(); }
+
+  /**
+   * Only available if ValueTypeContainer is a std::vector. Same as calling
+   * 'values_container().data()'.
+   */
+  template <class U = values_container_type,
+            typename std::enable_if<
+                tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>
+  const typename values_container_type::value_type* data() const noexcept {
+    return m_ht.data();
+  }
+
+  /**
+   * Return the container in which the values are stored. The values are in the
+   * same order as the insertion order and are contiguous in the structure, no
+   * holes (size() == values_container().size()).
+   */
+  const values_container_type& values_container() const noexcept {
+    return m_ht.values_container();
+  }
+
+  /**
+   * Release the container in which the values are stored.
+   *
+   * The set is empty after this operation.
+   */
+  values_container_type release() { return m_ht.release(); }
+
+  template <class U = values_container_type,
+            typename std::enable_if<
+                tsl::detail_ordered_hash::is_vector<U>::value>::type* = nullptr>
+  size_type capacity() const noexcept {
+    return m_ht.capacity();
+  }
+
+  void shrink_to_fit() { m_ht.shrink_to_fit(); }
+
+  /**
+   * Insert the value before pos shifting all the elements on the right of pos
+   * (including pos) one position to the right.
+   *
+   * O(bucket_count()) runtime complexity.
+   */
+  std::pair<iterator, bool> insert_at_position(const_iterator pos,
+                                               const value_type& value) {
+    return m_ht.insert_at_position(pos, value);
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   */
+  std::pair<iterator, bool> insert_at_position(const_iterator pos,
+                                               value_type&& value) {
+    return m_ht.insert_at_position(pos, std::move(value));
+  }
+
+  /**
+   * @copydoc insert_at_position(const_iterator pos, const value_type& value)
+   *
+   * Same as insert_at_position(pos, value_type(std::forward<Args>(args)...),
+   * mainly here for coherence.
+   */
+  template <class... Args>
+  std::pair<iterator, bool> emplace_at_position(const_iterator pos,
+                                                Args&&... args) {
+    return m_ht.emplace_at_position(pos, std::forward<Args>(args)...);
+  }
+
+  void pop_back() { m_ht.pop_back(); }
+
+  /**
+   * Faster erase operation with an O(1) average complexity but it doesn't
+   * preserve the insertion order.
+   *
+   * If an erasure occurs, the last element of the map will take the place of
+   * the erased element.
+   */
+  iterator unordered_erase(iterator pos) { return m_ht.unordered_erase(pos); }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   */
+  iterator unordered_erase(const_iterator pos) {
+    return m_ht.unordered_erase(pos);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   */
+  size_type unordered_erase(const key_type& key) {
+    return m_ht.unordered_erase(key);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  size_type unordered_erase(const key_type& key,
+                            std::size_t precalculated_hash) {
+    return m_ht.unordered_erase(key, precalculated_hash);
+  }
+
+  /**
+   * @copydoc unordered_erase(iterator pos)
+   *
+   * This overload only participates in the overload resolution if the typedef
+   * KeyEqual::is_transparent exists. If so, K must be hashable and comparable
+   * to Key.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type unordered_erase(const K& key) {
+    return m_ht.unordered_erase(key);
+  }
+
+  /**
+   * @copydoc unordered_erase(const K& key)
+   *
+   * Use the hash value 'precalculated_hash' instead of hashing the key. The
+   * hash value should be the same as hash_function()(key). Useful to speed-up
+   * the lookup if you already have the hash.
+   */
+  template <
+      class K, class KE = KeyEqual,
+      typename std::enable_if<has_is_transparent<KE>::value>::type* = nullptr>
+  size_type unordered_erase(const K& key, std::size_t precalculated_hash) {
+    return m_ht.unordered_erase(key, precalculated_hash);
+  }
+
+  /**
+   * Serialize the set through the `serializer` parameter.
+   *
+   * The `serializer` parameter must be a function object that supports the
+   * following call:
+   *  - `void operator()(const U& value);` where the types `std::uint64_t`,
+   * `float` and `Key` must be supported for U.
+   *
+   * The implementation leaves binary compatibility (endianness, IEEE 754 for
+   * floats, ...) of the types it serializes in the hands of the `Serializer`
+   * function object if compatibility is required.
+   */
+  template <class Serializer>
+  void serialize(Serializer& serializer) const {
+    m_ht.serialize(serializer);
+  }
+
+  /**
+   * Deserialize a previously serialized set through the `deserializer`
+   * parameter.
+   *
+   * The `deserializer` parameter must be a function object that supports the
+   * following calls:
+   *  - `template<typename U> U operator()();` where the types `std::uint64_t`,
+   * `float` and `Key` must be supported for U.
+   *
+   * If the deserialized hash set type is hash compatible with the serialized
+   * set, the deserialization process can be sped up by setting
+   * `hash_compatible` to true. To be hash compatible, the Hash and KeyEqual
+   * must behave the same way than the ones used on the serialized map. The
+   * `std::size_t` must also be of the same size as the one on the platform used
+   * to serialize the map, the same apply for `IndexType`. If these criteria are
+   * not met, the behaviour is undefined with `hash_compatible` sets to true.
+   *
+   * The behaviour is undefined if the type `Key` of the `ordered_set` is not
+   * the same as the type used during serialization.
+   *
+   * The implementation leaves binary compatibility (endianness, IEEE 754 for
+   * floats, size of int, ...) of the types it deserializes in the hands of the
+   * `Deserializer` function object if compatibility is required.
+   */
+  template <class Deserializer>
+  static ordered_set deserialize(Deserializer& deserializer,
+                                 bool hash_compatible = false) {
+    ordered_set set(0);
+    set.m_ht.deserialize(deserializer, hash_compatible);
+
+    return set;
+  }
+
+  friend bool operator==(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht == rhs.m_ht;
+  }
+  friend bool operator!=(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht != rhs.m_ht;
+  }
+  friend bool operator<(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht < rhs.m_ht;
+  }
+  friend bool operator<=(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht <= rhs.m_ht;
+  }
+  friend bool operator>(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht > rhs.m_ht;
+  }
+  friend bool operator>=(const ordered_set& lhs, const ordered_set& rhs) {
+    return lhs.m_ht >= rhs.m_ht;
+  }
+
+  friend void swap(ordered_set& lhs, ordered_set& rhs) { lhs.swap(rhs); }
+
+ private:
+  ht m_ht;
+};
+
+}  // end namespace tsl
+
+#endif
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/LICENSE lightspark-master/src/3rdparty/ordered-map/LICENSE
--- lightspark-0.9.0/src/3rdparty/ordered-map/LICENSE	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/LICENSE	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/README.md lightspark-master/src/3rdparty/ordered-map/README.md
--- lightspark-0.9.0/src/3rdparty/ordered-map/README.md	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/README.md	2025-03-05 20:13:02.116864001 +0100
@@ -0,0 +1,449 @@
+[![CI](https://github.com/Tessil/ordered-map/actions/workflows/ci.yml/badge.svg?branch=master)](https://github.com/Tessil/ordered-map/actions/workflows/ci.yml)
+
+## C++ hash map and hash set which preserves the order of insertion
+
+The ordered-map library provides a hash map and a hash set which preserve the order of insertion in a way similar to Python's [OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict). When iterating over the map, the values will be returned in the same order as they were inserted.
+
+The values are stored contiguously in an underlying structure, no holes in-between values even after an erase operation. By default a `std::deque` is used for this structure, but it's also possible to  use a `std::vector`. This structure is directly accessible through the `values_container()` method and if the structure is a `std::vector`, a `data()` method is also provided to easily interact with C APIs. This provides fast iteration but with the drawback of an O(bucket_count) erase operation. An O(1) `pop_back()` and an O(1) `unordered_erase()` functions are available. **If ordered erase is often used, another data structure is recommended.**
+
+To resolve collisions on hashes, the library uses linear robin hood probing with backward shift deletion.
+
+The library provides a behaviour similar to a `std::deque/std::vector` with unique values but with an average time complexity of O(1) for lookups and an amortised time complexity of O(1) for insertions. This comes at the price of a little higher memory footprint (8 bytes per bucket by default).
+
+Two classes are provided: `tsl::ordered_map` and `tsl::ordered_set`.
+
+**Note**: The library uses a power of two for the size of its buckets array to take advantage of the [fast modulo](https://en.wikipedia.org/wiki/Modulo_operation#Performance_issues). For good performances, it requires the hash table to have a well-distributed hash function. If you encounter performance issues check your hash function.
+
+### Key features
+
+- Header-only library, just add the [include](include/) directory to your include path and you are ready to go. If you use CMake, you can also use the `tsl::ordered_map` exported target from the [CMakeLists.txt](CMakeLists.txt).
+- Values are stored in the same order as the insertion order. The library provides a direct access to the underlying structure which stores the values.
+- O(1) average time complexity for lookups with performances similar to `std::unordered_map` but with faster insertions and reduced memory usage (see [benchmark](https://tessil.github.io/2016/08/29/benchmark-hopscotch-map.html) for details).
+- Provide random access iterators and also reverse iterators.
+- Support for heterogeneous lookups allowing the usage of `find` with a type different than `Key` (e.g. if you have a map that uses `std::unique_ptr<foo>` as key, you can use a `foo*` or a `std::uintptr_t` as key parameter to `find` without constructing a `std::unique_ptr<foo>`, see [example](#heterogeneous-lookups)).
+- If the hash is known before a lookup, it is possible to pass it as parameter to speed-up the lookup (see `precalculated_hash` parameter in [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a7fcde27edc6697a0b127f4b1aefa8a7d)).
+- Support for efficient serialization and deserialization (see [example](#serialization) and the `serialize/deserialize` methods in the [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html) for details).
+- The library can be used with exceptions disabled (through `-fno-exceptions` option on Clang and GCC, without an `/EH` option on MSVC or simply by defining `TSL_NO_EXCEPTIONS`). `std::terminate` is used in replacement of the `throw` instruction when exceptions are disabled.
+- API closely similar to `std::unordered_map` and `std::unordered_set`.
+
+### Differences compared to `std::unordered_map`
+`tsl::ordered_map` tries to have an interface similar to `std::unordered_map`, but some differences exist.
+- The iterators are `RandomAccessIterator`.
+- Iterator invalidation behaves in a way closer to `std::vector` and `std::deque` (see [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details) for details). If you use `std::vector` as `ValueTypeContainer`, you can use `reserve()` to preallocate some space and avoid the invalidation of the iterators on insert.
+- Slow `erase()` operation, it has a complexity of O(bucket_count). A faster O(1) version `unordered_erase()` exists, but it breaks the insertion order (see [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#a9f94a7889fa7fa92eea41ca63b3f98a4) for details). An O(1) `pop_back()` is also available.
+- The equality operators `operator==` and `operator!=` are order dependent. Two `tsl::ordered_map` with the same values but inserted in a different order don't compare equal.
+- For iterators, `operator*()` and `operator->()` return a reference and a pointer to `const std::pair<Key, T>` instead of `std::pair<const Key, T>` making the value `T` not modifiable. To modify the value you have to call the `value()` method of the iterator to get a mutable reference. Example:
+```c++
+tsl::ordered_map<int, int> map = {{1, 1}, {2, 1}, {3, 1}};
+for(auto it = map.begin(); it != map.end(); ++it) {
+    //it->second = 2; // Illegal
+    it.value() = 2; // Ok
+}
+```
+- By default the map can only hold up to 2<sup>32</sup> - 1 values, that is 4 294 967 295 values. This can be raised through the `IndexType` class template parameter, check the [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html#details) for details. 
+- No support for some bucket related methods (like `bucket_size`, `bucket`, ...).
+
+Thread-safety guarantee is the same as `std::unordered_map`  (i.e. possible to have multiple concurrent readers with no writer).
+
+These differences also apply between `std::unordered_set` and `tsl::ordered_set`.
+
+### Exception Guarantees
+
+If not mentioned otherwise, functions have the strong exception guarantee, see [details](https://en.cppreference.com/w/cpp/language/exceptions). We below list cases in which this guarantee is not provided.
+
+The guarantee is only provided if `ValueContainer::emplace_back` has the strong exception guarantee (which is true for `std::vector` and `std::deque` as long as the type `T` is not a move-only type with a move constructor that may throw an exception, see [details](http://en.cppreference.com/w/cpp/container/vector/emplace_back#Exceptions)).
+
+The `tsl::ordered_map::erase_if` and `tsl::ordered_set::erase_if` functions only have the guarantee under the preconditions listed in their documentation.
+
+### Installation
+
+To use ordered-map, just add the [include](include/) directory to your include path. It is a **header-only** library.
+
+If you use CMake, you can also use the `tsl::ordered_map` exported target from the [CMakeLists.txt](CMakeLists.txt) with `target_link_libraries`. 
+```cmake
+# Example where the ordered-map project is stored in a third-party directory
+add_subdirectory(third-party/ordered-map)
+target_link_libraries(your_target PRIVATE tsl::ordered_map)  
+```
+
+If the project has been installed through `make install`, you can also use `find_package(tsl-ordered-map REQUIRED)` instead of `add_subdirectory`.
+
+The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.
+
+To run the tests you will need the Boost Test library and CMake.
+
+```bash
+git clone https://github.com/Tessil/ordered-map.git
+cd ordered-map/tests
+mkdir build
+cd build
+cmake ..
+cmake --build .
+./tsl_ordered_map_tests 
+```
+
+### Usage
+
+The API can be found [here](https://tessil.github.io/ordered-map/).
+
+### Example
+
+```c++
+#include <iostream>
+#include <string>
+#include <cstdlib>
+#include <tsl/ordered_map.h>
+#include <tsl/ordered_set.h>
+
+int main() {
+    tsl::ordered_map<char, int> map = {{'d', 1}, {'a', 2}, {'g', 3}};
+    map.insert({'b', 4});
+    map['h'] = 5;
+    map['e'] = 6;
+    
+    map.erase('a');
+    
+    
+    // {d, 1} {g, 3} {b, 4} {h, 5} {e, 6}
+    for(const auto& key_value : map) {
+        std::cout << "{" << key_value.first << ", " << key_value.second << "}" << std::endl;
+    }
+    
+    
+    map.unordered_erase('b');
+    
+    // Break order: {d, 1} {g, 3} {e, 6} {h, 5}
+    for(const auto& key_value : map) {
+        std::cout << "{" << key_value.first << ", " << key_value.second << "}" << std::endl;
+    }
+    
+    
+    for(auto it = map.begin(); it != map.end(); ++it) {
+        //it->second += 2; // Not valid.
+        it.value() += 2;
+    }
+    
+    
+    if(map.find('d') != map.end()) {
+        std::cout << "Found 'd'." << std::endl;
+    }
+    
+    const std::size_t precalculated_hash = std::hash<char>()('d');
+    // If we already know the hash beforehand, we can pass it as argument to speed-up the lookup.
+    if(map.find('d', precalculated_hash) != map.end()) {
+        std::cout << "Found 'd' with hash " << precalculated_hash << "." << std::endl;
+    }
+    
+    
+    tsl::ordered_set<char, std::hash<char>, std::equal_to<char>,
+                     std::allocator<char>, std::vector<char>> set;
+    set.reserve(6);
+    
+    set = {'3', '4', '9', '2'};
+    set.erase('2');
+    set.insert('1');
+    set.insert('\0');
+    
+    set.pop_back();
+    set.insert({'0', '\0'});
+    
+    // Get raw buffer for C API: 34910
+    std::cout << atoi(set.data()) << std::endl;
+}
+```
+
+#### Heterogeneous lookup
+
+Heterogeneous overloads allow the usage of other types than `Key` for lookup and erase operations as long as the used types are hashable and comparable to `Key`.
+
+To activate the heterogeneous overloads in `tsl::ordered_map/set`, the qualified-id `KeyEqual::is_transparent` must be valid. It works the same way as for [`std::map::find`](http://en.cppreference.com/w/cpp/container/map/find). You can either use [`std::equal_to<>`](http://en.cppreference.com/w/cpp/utility/functional/equal_to_void) or define your own function object.
+
+Both `KeyEqual` and `Hash` will need to be able to deal with the different types.
+
+```c++
+#include <functional>
+#include <iostream>
+#include <string>
+#include <tsl/ordered_map.h>
+
+
+
+struct employee {
+    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {
+    }
+    
+    // Either we include the comparators in the class and we use `std::equal_to<>`...
+    friend bool operator==(const employee& empl, int empl_id) {
+        return empl.m_id == empl_id;
+    }
+    
+    friend bool operator==(int empl_id, const employee& empl) {
+        return empl_id == empl.m_id;
+    }
+    
+    friend bool operator==(const employee& empl1, const employee& empl2) {
+        return empl1.m_id == empl2.m_id;
+    }
+    
+    
+    int m_id;
+    std::string m_name;
+};
+
+// ... or we implement a separate class to compare employees.
+struct equal_employee {
+    using is_transparent = void;
+    
+    bool operator()(const employee& empl, int empl_id) const {
+        return empl.m_id == empl_id;
+    }
+    
+    bool operator()(int empl_id, const employee& empl) const {
+        return empl_id == empl.m_id;
+    }
+    
+    bool operator()(const employee& empl1, const employee& empl2) const {
+        return empl1.m_id == empl2.m_id;
+    }
+};
+
+struct hash_employee {
+    std::size_t operator()(const employee& empl) const {
+        return std::hash<int>()(empl.m_id);
+    }
+    
+    std::size_t operator()(int id) const {
+        return std::hash<int>()(id);
+    }
+};
+
+
+int main() {
+    // Use std::equal_to<> which will automatically deduce and forward the parameters
+    tsl::ordered_map<employee, int, hash_employee, std::equal_to<>> map; 
+    map.insert({employee(1, "John Doe"), 2001});
+    map.insert({employee(2, "Jane Doe"), 2002});
+    map.insert({employee(3, "John Smith"), 2003});
+
+    // John Smith 2003
+    auto it = map.find(3);
+    if(it != map.end()) {
+        std::cout << it->first.m_name << " " << it->second << std::endl;
+    }
+
+    map.erase(1);
+
+
+
+    // Use a custom KeyEqual which has an is_transparent member type
+    tsl::ordered_map<employee, int, hash_employee, equal_employee> map2;
+    map2.insert({employee(4, "Johnny Doe"), 2004});
+
+    // 2004
+    std::cout << map2.at(4) << std::endl;
+} 
+```
+
+#### Serialization
+
+The library provides an efficient way to serialize and deserialize a map or a set so that it can be saved to a file or send through the network.
+To do so, it requires the user to provide a function object for both serialization and deserialization.
+
+```c++
+struct serializer {
+    // Must support the following types for U: std::uint64_t, float 
+    // and std::pair<Key, T> if a map is used or Key for a set.
+    template<typename U>
+    void operator()(const U& value);
+};
+```
+
+```c++
+struct deserializer {
+    // Must support the following types for U: std::uint64_t, float 
+    // and std::pair<Key, T> if a map is used or Key for a set.
+    template<typename U>
+    U operator()();
+};
+```
+
+Note that the implementation leaves binary compatibility (endianness, float binary representation, size of int, ...) of the types it serializes/deserializes in the hands of the provided function objects if compatibility is required.
+
+More details regarding the `serialize` and `deserialize` methods can be found in the [API](https://tessil.github.io/ordered-map/classtsl_1_1ordered__map.html).
+
+```c++
+#include <cassert>
+#include <cstdint>
+#include <fstream>
+#include <type_traits>
+#include <tsl/ordered_map.h>
+
+
+class serializer {
+public:
+    explicit serializer(const char* file_name) {
+        m_ostream.exceptions(m_ostream.badbit | m_ostream.failbit);
+        m_ostream.open(file_name, std::ios::binary);
+    }
+    
+    template<class T,
+             typename std::enable_if<std::is_arithmetic<T>::value>::type* = nullptr>
+    void operator()(const T& value) {
+        m_ostream.write(reinterpret_cast<const char*>(&value), sizeof(T));
+    }
+    
+    void operator()(const std::pair<std::int64_t, std::int64_t>& value) {
+        (*this)(value.first);
+        (*this)(value.second);
+    }
+
+private:
+    std::ofstream m_ostream;
+};
+
+class deserializer {
+public:
+    explicit deserializer(const char* file_name) {
+        m_istream.exceptions(m_istream.badbit | m_istream.failbit | m_istream.eofbit);
+        m_istream.open(file_name, std::ios::binary);
+    }
+    
+    template<class T>
+    T operator()() {
+        T value;
+        deserialize(value);
+        
+        return value;
+    }
+    
+private:
+    template<class T,
+             typename std::enable_if<std::is_arithmetic<T>::value>::type* = nullptr>
+    void deserialize(T& value) {
+        m_istream.read(reinterpret_cast<char*>(&value), sizeof(T));
+    }
+    
+    void deserialize(std::pair<std::int64_t, std::int64_t>& value) {
+        deserialize(value.first);
+        deserialize(value.second);
+    }
+
+private:
+    std::ifstream m_istream;
+};
+
+
+int main() {
+    const tsl::ordered_map<std::int64_t, std::int64_t> map = {{1, -1}, {2, -2}, {3, -3}, {4, -4}};
+    
+    
+    const char* file_name = "ordered_map.data";
+    {
+        serializer serial(file_name);
+        map.serialize(serial);
+    }
+    
+    {
+        deserializer dserial(file_name);
+        auto map_deserialized = tsl::ordered_map<std::int64_t, std::int64_t>::deserialize(dserial);
+        
+        assert(map == map_deserialized);
+    }
+    
+    {
+        deserializer dserial(file_name);
+        
+        /**
+         * If the serialized and deserialized map are hash compatibles (see conditions in API), 
+         * setting the argument to true speed-up the deserialization process as we don't have 
+         * to recalculate the hash of each key. We also know how much space each bucket needs.
+         */
+        const bool hash_compatible = true;
+        auto map_deserialized = 
+            tsl::ordered_map<std::int64_t, std::int64_t>::deserialize(dserial, hash_compatible);
+        
+        assert(map == map_deserialized);
+    }
+} 
+```
+
+##### Serialization with Boost Serialization and compression with zlib
+
+It's possible to use a serialization library to avoid the boilerplate. 
+
+The following example uses Boost Serialization with the Boost zlib compression stream to reduce the size of the resulting serialized file. The example requires C++20 due to the usage of the template parameter list syntax in lambdas, but it can be adapted to less recent versions.
+
+```c++
+#include <boost/archive/binary_iarchive.hpp>
+#include <boost/archive/binary_oarchive.hpp>
+#include <boost/iostreams/filter/zlib.hpp>
+#include <boost/iostreams/filtering_stream.hpp>
+#include <boost/serialization/split_free.hpp>
+#include <boost/serialization/utility.hpp>
+#include <cassert>
+#include <cstdint>
+#include <fstream>
+#include <tsl/ordered_map.h>
+
+
+namespace boost { namespace serialization {
+    template<class Archive, class Key, class T>
+    void serialize(Archive & ar, tsl::ordered_map<Key, T>& map, const unsigned int version) {
+        split_free(ar, map, version); 
+    }
+
+    template<class Archive, class Key, class T>
+    void save(Archive & ar, const tsl::ordered_map<Key, T>& map, const unsigned int /*version*/) {
+        auto serializer = [&ar](const auto& v) { ar & v; };
+        map.serialize(serializer);
+    }
+
+    template<class Archive, class Key, class T>
+    void load(Archive & ar, tsl::ordered_map<Key, T>& map, const unsigned int /*version*/) {
+        auto deserializer = [&ar]<typename U>() { U u; ar & u; return u; };
+        map = tsl::ordered_map<Key, T>::deserialize(deserializer);
+    }
+}}
+
+
+int main() {
+    tsl::ordered_map<std::int64_t, std::int64_t> map = {{1, -1}, {2, -2}, {3, -3}, {4, -4}};
+    
+    
+    const char* file_name = "ordered_map.data";
+    {
+        std::ofstream ofs;
+        ofs.exceptions(ofs.badbit | ofs.failbit);
+        ofs.open(file_name, std::ios::binary);
+        
+        boost::iostreams::filtering_ostream fo;
+        fo.push(boost::iostreams::zlib_compressor());
+        fo.push(ofs);
+        
+        boost::archive::binary_oarchive oa(fo);
+        
+        oa << map;
+    }
+    
+    {
+        std::ifstream ifs;
+        ifs.exceptions(ifs.badbit | ifs.failbit | ifs.eofbit);
+        ifs.open(file_name, std::ios::binary);
+        
+        boost::iostreams::filtering_istream fi;
+        fi.push(boost::iostreams::zlib_decompressor());
+        fi.push(ifs);
+        
+        boost::archive::binary_iarchive ia(fi);
+     
+        tsl::ordered_map<std::int64_t, std::int64_t> map_deserialized;   
+        ia >> map_deserialized;
+        
+        assert(map == map_deserialized);
+    }
+}
+```
+
+### License
+
+The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details.
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/CMakeLists.txt lightspark-master/src/3rdparty/ordered-map/tests/CMakeLists.txt
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/CMakeLists.txt	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,25 @@
+cmake_minimum_required(VERSION 3.8)
+
+project(tsl_ordered_map_tests)
+
+add_executable(tsl_ordered_map_tests "main.cpp" 
+                                     "custom_allocator_tests.cpp" 
+                                     "ordered_map_tests.cpp" 
+                                     "ordered_set_tests.cpp")
+
+target_compile_features(tsl_ordered_map_tests PRIVATE cxx_std_11)
+
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID MATCHES "GNU")
+    target_compile_options(tsl_ordered_map_tests PRIVATE -Werror -Wall -Wextra -Wold-style-cast -DTSL_DEBUG -UNDEBUG)
+elseif(CMAKE_CXX_COMPILER_ID MATCHES "MSVC")
+    target_compile_options(tsl_ordered_map_tests PRIVATE /bigobj /WX /W3 /DTSL_DEBUG /UNDEBUG)
+endif()
+
+# Boost::unit_test_framework
+set(Boost_USE_STATIC_LIBS ON)
+find_package(Boost 1.54.0 REQUIRED COMPONENTS unit_test_framework)
+target_link_libraries(tsl_ordered_map_tests PRIVATE Boost::unit_test_framework)   
+
+# tsl::ordered_map
+add_subdirectory(../ ${CMAKE_CURRENT_BINARY_DIR}/tsl)
+target_link_libraries(tsl_ordered_map_tests PRIVATE tsl::ordered_map)  
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/custom_allocator_tests.cpp lightspark-master/src/3rdparty/ordered-map/tests/custom_allocator_tests.cpp
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/custom_allocator_tests.cpp	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/custom_allocator_tests.cpp	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,139 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#include <tsl/ordered_map.h>
+
+#include <boost/test/unit_test.hpp>
+#include <cstdint>
+#include <cstdlib>
+#include <limits>
+#include <stdexcept>
+#include <type_traits>
+#include <utility>
+
+#include "utils.h"
+
+static std::size_t nb_custom_allocs = 0;
+
+template <typename T>
+class custom_allocator {
+ public:
+  using value_type = T;
+  using pointer = T*;
+  using const_pointer = const T*;
+  using reference = T&;
+  using const_reference = const T&;
+  using size_type = std::size_t;
+  using difference_type = std::ptrdiff_t;
+  using propagate_on_container_move_assignment = std::true_type;
+
+  template <typename U>
+  struct rebind {
+    using other = custom_allocator<U>;
+  };
+
+  custom_allocator() = default;
+  custom_allocator(const custom_allocator&) = default;
+
+  template <typename U>
+  custom_allocator(const custom_allocator<U>&) {}
+
+  pointer address(reference x) const noexcept { return &x; }
+
+  const_pointer address(const_reference x) const noexcept { return &x; }
+
+  pointer allocate(size_type n, const void* /*hint*/ = 0) {
+    nb_custom_allocs++;
+
+    pointer ptr = static_cast<pointer>(std::malloc(n * sizeof(T)));
+    if (ptr == nullptr) {
+#ifdef TSL_OH_NO_EXCEPTIONS
+      std::abort();
+#else
+      throw std::bad_alloc();
+#endif
+    }
+
+    return ptr;
+  }
+
+  void deallocate(T* p, size_type /*n*/) { std::free(p); }
+
+  size_type max_size() const noexcept {
+    return std::numeric_limits<size_type>::max() / sizeof(value_type);
+  }
+
+  template <typename U, typename... Args>
+  void construct(U* p, Args&&... args) {
+    ::new (static_cast<void*>(p)) U(std::forward<Args>(args)...);
+  }
+
+  template <typename U>
+  void destroy(U* p) {
+    p->~U();
+  }
+};
+
+template <class T, class U>
+bool operator==(const custom_allocator<T>&, const custom_allocator<U>&) {
+  return true;
+}
+
+template <class T, class U>
+bool operator!=(const custom_allocator<T>&, const custom_allocator<U>&) {
+  return false;
+}
+
+// TODO Avoid overloading new to check number of global new.
+// How can we check we only go through the allocator for allocation?
+
+// static std::size_t nb_global_new = 0;
+// void* operator new(std::size_t sz) {
+//     nb_global_new++;
+//     return std::malloc(sz);
+// }
+//
+// void operator delete(void* ptr) noexcept {
+//     std::free(ptr);
+// }
+
+BOOST_AUTO_TEST_SUITE(test_custom_allocator)
+
+BOOST_AUTO_TEST_CASE(test_custom_allocator_1) {
+  //    nb_global_new = 0;
+  nb_custom_allocs = 0;
+
+  tsl::ordered_map<int, int, std::hash<int>, std::equal_to<int>,
+                   custom_allocator<std::pair<int, int>>>
+      map;
+
+  const int nb_elements = 1000;
+  for (int i = 0; i < nb_elements; i++) {
+    map.insert({i, i * 2});
+  }
+
+  BOOST_CHECK_NE(nb_custom_allocs, 0u);
+  //    BOOST_CHECK_EQUAL(nb_global_new, 0);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/main.cpp lightspark-master/src/3rdparty/ordered-map/tests/main.cpp
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/main.cpp	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,26 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#define BOOST_TEST_MODULE ordered_map_tests
+
+#include <boost/test/unit_test.hpp>
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/ordered_map_tests.cpp lightspark-master/src/3rdparty/ordered-map/tests/ordered_map_tests.cpp
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/ordered_map_tests.cpp	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/ordered_map_tests.cpp	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,1709 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#include <boost/mpl/list.hpp>
+#include <boost/test/unit_test.hpp>
+#include <cstddef>
+#include <cstdint>
+#include <deque>
+#include <functional>
+#include <iterator>
+#include <memory>
+#include <stdexcept>
+#include <string>
+#include <tuple>
+#include <type_traits>
+#include <utility>
+#include <vector>
+
+#include "tsl/ordered_map.h"
+#include "utils.h"
+
+BOOST_AUTO_TEST_SUITE(test_ordered_map)
+
+using test_types = boost::mpl::list<
+    tsl::ordered_map<std::int64_t, std::int64_t>,
+    tsl::ordered_map<std::int64_t, std::int64_t, std::hash<std::int64_t>,
+                     std::equal_to<std::int64_t>,
+                     std::allocator<std::pair<std::int64_t, std::int64_t>>,
+                     std::vector<std::pair<std::int64_t, std::int64_t>>>,
+    tsl::ordered_map<std::string, std::string>,
+    tsl::ordered_map<std::string, std::string, mod_hash<9>>,
+    tsl::ordered_map<move_only_test, move_only_test, mod_hash<9>>>;
+
+/**
+ * insert
+ */
+BOOST_AUTO_TEST_CASE_TEMPLATE(test_insert, HMap, test_types) {
+  // insert x values, insert them again, check values through find, check order
+  // through iterator
+  using key_tt = typename HMap::key_type;
+  using value_tt = typename HMap::mapped_type;
+
+  const std::size_t nb_values = 1000;
+  HMap map(0);
+  BOOST_CHECK_EQUAL(map.bucket_count(), 0u);
+
+  typename HMap::iterator it;
+  bool inserted;
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    // Avoid sequential values by splitting the values with modulo
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    std::tie(it, inserted) =
+        map.insert({utils::get_key<key_tt>(insert_val),
+                    utils::get_value<value_tt>(insert_val)});
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(insert_val));
+    BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(insert_val));
+    BOOST_CHECK(inserted);
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    std::tie(it, inserted) =
+        map.insert({utils::get_key<key_tt>(insert_val),
+                    utils::get_value<value_tt>(insert_val + 1)});
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(insert_val));
+    BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(insert_val));
+    BOOST_CHECK(!inserted);
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    it = map.find(utils::get_key<key_tt>(insert_val));
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(insert_val));
+    BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(insert_val));
+  }
+
+  std::size_t i = 0;
+  for (const auto& key_value : map) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+
+    BOOST_CHECK_EQUAL(key_value.first, utils::get_key<key_tt>(insert_val));
+    BOOST_CHECK_EQUAL(key_value.second, utils::get_value<value_tt>(insert_val));
+
+    i++;
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_range_insert) {
+  // insert x values in vector, range insert x-15 values from vector to map,
+  // check values
+  const int nb_values = 1000;
+  std::vector<std::pair<int, int>> values;
+  for (int i = 0; i < nb_values; i++) {
+    values.push_back(std::make_pair(i, i + 1));
+  }
+
+  tsl::ordered_map<int, int> map = {{-1, 0}, {-2, 0}};
+  map.insert(values.begin() + 10, values.end() - 5);
+
+  BOOST_CHECK_EQUAL(map.size(), 987u);
+
+  BOOST_CHECK_EQUAL(map.values_container()[0].first, -1);
+  BOOST_CHECK_EQUAL(map.values_container()[0].second, 0);
+  BOOST_CHECK_EQUAL(map.at(-1), 0);
+
+  BOOST_CHECK_EQUAL(map.values_container()[1].first, -2);
+  BOOST_CHECK_EQUAL(map.values_container()[1].second, 0);
+  BOOST_CHECK_EQUAL(map.at(-2), 0);
+
+  for (int i = 10, j = 2; i < nb_values - 5; i++, j++) {
+    BOOST_CHECK_EQUAL(map.values_container()[j].first, i);
+    BOOST_CHECK_EQUAL(map.values_container()[j].second, i + 1);
+    BOOST_CHECK_EQUAL(map.at(i), i + 1);
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_insert_with_hint) {
+  tsl::ordered_map<int, int> map{{1, 0}, {2, 1}, {3, 2}};
+
+  // Wrong hint
+  BOOST_CHECK(map.insert(map.find(2), std::make_pair(3, 4)) == map.find(3));
+
+  // Good hint
+  BOOST_CHECK(map.insert(map.find(2), std::make_pair(2, 4)) == map.find(2));
+
+  // end() hint
+  BOOST_CHECK(map.insert(map.find(10), std::make_pair(2, 4)) == map.find(2));
+
+  BOOST_CHECK_EQUAL(map.size(), 3u);
+
+  // end() hint, new value
+  BOOST_CHECK_EQUAL(map.insert(map.find(10), std::make_pair(4, 3))->first, 4);
+
+  // Wrong hint, new value
+  BOOST_CHECK_EQUAL(map.insert(map.find(2), std::make_pair(5, 4))->first, 5);
+
+  BOOST_CHECK_EQUAL(map.size(), 5u);
+}
+
+BOOST_AUTO_TEST_CASE(test_insert_copy_constructible_only_values) {
+  // Test that an ordered_map with copy constructible only objects compiles
+  const std::size_t nb_values = 100;
+
+  tsl::ordered_map<copy_constructible_only_test, copy_constructible_only_test>
+      map;
+  for (std::size_t i = 0; i < nb_values; i++) {
+    map.insert(
+        {copy_constructible_only_test(i), copy_constructible_only_test(i * 2)});
+  }
+
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+}
+
+/**
+ * emplace_hint
+ */
+BOOST_AUTO_TEST_CASE(test_emplace_hint) {
+  tsl::ordered_map<int, int> map{{1, 0}, {2, 1}, {3, 2}};
+
+  // Wrong hint
+  BOOST_CHECK(map.emplace_hint(map.find(2), std::piecewise_construct,
+                               std::forward_as_tuple(3),
+                               std::forward_as_tuple(4)) == map.find(3));
+
+  // Good hint
+  BOOST_CHECK(map.emplace_hint(map.find(2), std::piecewise_construct,
+                               std::forward_as_tuple(2),
+                               std::forward_as_tuple(4)) == map.find(2));
+
+  // end() hint
+  BOOST_CHECK(map.emplace_hint(map.find(10), std::piecewise_construct,
+                               std::forward_as_tuple(2),
+                               std::forward_as_tuple(4)) == map.find(2));
+
+  BOOST_CHECK_EQUAL(map.size(), 3u);
+
+  // end() hint, new value
+  BOOST_CHECK_EQUAL(
+      map.emplace_hint(map.find(10), std::piecewise_construct,
+                       std::forward_as_tuple(4), std::forward_as_tuple(3))
+          ->first,
+      4);
+
+  // Wrong hint, new value
+  BOOST_CHECK_EQUAL(
+      map.emplace_hint(map.find(2), std::piecewise_construct,
+                       std::forward_as_tuple(5), std::forward_as_tuple(4))
+          ->first,
+      5);
+
+  BOOST_CHECK_EQUAL(map.size(), 5u);
+}
+
+/**
+ * emplace
+ */
+BOOST_AUTO_TEST_CASE(test_emplace) {
+  tsl::ordered_map<std::int64_t, move_only_test> map;
+  tsl::ordered_map<std::int64_t, move_only_test>::iterator it;
+  bool inserted;
+
+  std::tie(it, inserted) =
+      map.emplace(std::piecewise_construct, std::forward_as_tuple(10),
+                  std::forward_as_tuple(1));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+  BOOST_CHECK(inserted);
+
+  std::tie(it, inserted) =
+      map.emplace(std::piecewise_construct, std::forward_as_tuple(10),
+                  std::forward_as_tuple(3));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+  BOOST_CHECK(!inserted);
+}
+
+/**
+ * try_emplace
+ */
+BOOST_AUTO_TEST_CASE(test_try_emplace) {
+  tsl::ordered_map<std::int64_t, move_only_test> map;
+  tsl::ordered_map<std::int64_t, move_only_test>::iterator it;
+  bool inserted;
+
+  std::tie(it, inserted) = map.try_emplace(10, 1);
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+  BOOST_CHECK(inserted);
+
+  std::tie(it, inserted) = map.try_emplace(10, 3);
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+  BOOST_CHECK(!inserted);
+}
+
+BOOST_AUTO_TEST_CASE(test_try_emplace_2) {
+  tsl::ordered_map<std::string, move_only_test> map;
+  tsl::ordered_map<std::string, move_only_test>::iterator it;
+  bool inserted;
+
+  const std::size_t nb_values = 1000;
+  for (std::size_t i = 0; i < nb_values; i++) {
+    std::tie(it, inserted) = map.try_emplace(utils::get_key<std::string>(i), i);
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));
+    BOOST_CHECK_EQUAL(it->second, move_only_test(i));
+    BOOST_CHECK(inserted);
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    std::tie(it, inserted) =
+        map.try_emplace(utils::get_key<std::string>(i), i + 1);
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));
+    BOOST_CHECK_EQUAL(it->second, move_only_test(i));
+    BOOST_CHECK(!inserted);
+  }
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    it = map.find(utils::get_key<std::string>(i));
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<std::string>(i));
+    BOOST_CHECK_EQUAL(it->second, move_only_test(i));
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_try_emplace_hint) {
+  tsl::ordered_map<std::int64_t, move_only_test> map(0);
+
+  // end() hint, new value
+  auto it = map.try_emplace(map.find(10), 10, 1);
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+
+  // Good hint
+  it = map.try_emplace(map.find(10), 10, 3);
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+
+  // Wrong hint, new value
+  it = map.try_emplace(map.find(10), 1, 3);
+  BOOST_CHECK_EQUAL(it->first, 1);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(3));
+}
+
+/**
+ * insert_or_assign
+ */
+BOOST_AUTO_TEST_CASE(test_insert_or_assign) {
+  tsl::ordered_map<std::int64_t, move_only_test> map;
+  tsl::ordered_map<std::int64_t, move_only_test>::iterator it;
+  bool inserted;
+
+  std::tie(it, inserted) = map.insert_or_assign(10, move_only_test(1));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+  BOOST_CHECK(inserted);
+
+  std::tie(it, inserted) = map.insert_or_assign(10, move_only_test(3));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(3));
+  BOOST_CHECK(!inserted);
+}
+
+BOOST_AUTO_TEST_CASE(test_insert_or_assign_hint) {
+  tsl::ordered_map<std::int64_t, move_only_test> map(0);
+
+  // end() hint, new value
+  auto it = map.insert_or_assign(map.find(10), 10, move_only_test(1));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(1));
+
+  // Good hint
+  it = map.insert_or_assign(map.find(10), 10, move_only_test(3));
+  BOOST_CHECK_EQUAL(it->first, 10);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(3));
+
+  // Bad hint, new value
+  it = map.insert_or_assign(map.find(10), 1, move_only_test(3));
+  BOOST_CHECK_EQUAL(it->first, 1);
+  BOOST_CHECK_EQUAL(it->second, move_only_test(3));
+}
+
+/**
+ * insert_at_position
+ */
+BOOST_AUTO_TEST_CASE(test_insert_at_position) {
+  tsl::ordered_map<std::string, int> map = {
+      {"Key2", 2}, {"Key4", 4},   {"Key6", 6},   {"Key8", 8},
+      {"Key9", 9}, {"Key10", 10}, {"Key11", 11}, {"Key12", 12}};
+
+  BOOST_CHECK(map.insert_at_position(map.begin(), {"Key1", 1}).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12}}));
+
+  auto it = map.insert_at_position(map.nth(2), {"Key3", 3});
+  BOOST_CHECK(*it.first == (std::pair<std::string, int>("Key3", 3)));
+  BOOST_CHECK(it.second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12}}));
+
+  BOOST_CHECK(map.insert_at_position(map.end(), {"Key7", 7}).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+
+  BOOST_CHECK(map.insert_at_position(map.nth(4), {"Key5", 5}).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key5", 5},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+
+  it = map.insert_at_position(map.nth(3), {"Key8", 8});
+  BOOST_CHECK(*it.first == (std::pair<std::string, int>("Key8", 8)));
+  BOOST_CHECK(!it.second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key5", 5},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+}
+
+BOOST_AUTO_TEST_CASE(test_insert_at_position_high_collisions) {
+  tsl::ordered_map<int, int, identity_hash<int>> map(32);
+  BOOST_CHECK_EQUAL(map.bucket_count(), 32u);
+  map.insert({{0, 0}, {32, -32}, {64, -64}, {96, -96}, {128, -128}});
+
+  auto it = map.insert_at_position(map.begin(), {160, -160});
+  BOOST_CHECK(*it.first == (std::pair<int, int>(160, -160)));
+  BOOST_CHECK(it.second);
+  BOOST_CHECK(utils::test_is_equal(
+      map,
+      tsl::ordered_map<int, int, identity_hash<int>>{
+          {160, -160}, {0, 0}, {32, -32}, {64, -64}, {96, -96}, {128, -128}}));
+}
+
+/**
+ * try_emplace_at_position
+ */
+BOOST_AUTO_TEST_CASE(test_try_emplace_at_position) {
+  tsl::ordered_map<std::string, int> map = {
+      {"Key2", 2}, {"Key4", 4},   {"Key6", 6},   {"Key8", 8},
+      {"Key9", 9}, {"Key10", 10}, {"Key11", 11}, {"Key12", 12}};
+
+  BOOST_CHECK(map.try_emplace_at_position(map.begin(), "Key1", 1).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12}}));
+
+  auto it = map.try_emplace_at_position(map.nth(2), "Key3", 3);
+  BOOST_CHECK(*it.first == (std::pair<std::string, int>("Key3", 3)));
+  BOOST_CHECK(it.second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12}}));
+
+  BOOST_CHECK(map.try_emplace_at_position(map.end(), "Key7", 7).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+
+  BOOST_CHECK(map.try_emplace_at_position(map.nth(4), "Key5", 5).second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key5", 5},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+
+  it = map.try_emplace_at_position(map.nth(3), "Key8", 8);
+  BOOST_CHECK(*it.first == (std::pair<std::string, int>("Key8", 8)));
+  BOOST_CHECK(!it.second);
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"Key1", 1},
+                                              {"Key2", 2},
+                                              {"Key3", 3},
+                                              {"Key4", 4},
+                                              {"Key5", 5},
+                                              {"Key6", 6},
+                                              {"Key8", 8},
+                                              {"Key9", 9},
+                                              {"Key10", 10},
+                                              {"Key11", 11},
+                                              {"Key12", 12},
+                                              {"Key7", 7}}));
+}
+
+/**
+ * erase
+ */
+BOOST_AUTO_TEST_CASE(test_range_erase_all) {
+  // insert x values, delete all
+  using HMap = tsl::ordered_map<std::string, std::int64_t>;
+
+  const std::size_t nb_values = 1000;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+
+  auto it = map.erase(map.begin(), map.end());
+  BOOST_CHECK(it == map.end());
+  BOOST_CHECK(map.empty());
+}
+
+BOOST_AUTO_TEST_CASE(test_range_erase) {
+  // insert x values, delete all with iterators except 10 first and 780 last
+  // values
+  using HMap = tsl::ordered_map<std::string, std::int64_t>;
+
+  const std::size_t nb_values = 1000;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+
+  auto it_first = std::next(map.begin(), 10);
+  auto it_last = std::next(map.begin(), 220);
+
+  auto it = map.erase(it_first, it_last);
+  BOOST_CHECK_EQUAL(std::distance(it, map.end()), 780);
+  BOOST_CHECK_EQUAL(map.size(), 790u);
+  BOOST_CHECK_EQUAL(std::distance(map.begin(), map.end()), 790);
+
+  for (auto& val : map) {
+    BOOST_CHECK_EQUAL(map.count(val.first), 1u);
+  }
+
+  // Check order
+  it = map.begin();
+  for (std::size_t i = 0; i < nb_values; i++) {
+    if (i >= 10 && i < 220) {
+      continue;
+    }
+    BOOST_CHECK(*it == (std::pair<std::string, std::int64_t>(
+                           utils::get_key<std::string>(i),
+                           utils::get_value<std::int64_t>(i))));
+    ++it;
+  }
+}
+
+BOOST_AUTO_TEST_CASE_TEMPLATE(test_erase_loop, HMap, test_types) {
+  // insert x values, delete all one by one
+  std::size_t nb_values = 1000;
+
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+  HMap map2 = utils::get_filled_hash_map<HMap>(nb_values);
+
+  auto it = map.begin();
+  // Use second map to check for key after delete as we may not copy the key
+  // with move-only types.
+  auto it2 = map2.begin();
+  while (it != map.end()) {
+    it = map.erase(it);
+    --nb_values;
+
+    BOOST_CHECK_EQUAL(map.count(it2->first), 0u);
+    BOOST_CHECK_EQUAL(map.size(), nb_values);
+    ++it2;
+  }
+
+  BOOST_CHECK(map.empty());
+}
+
+BOOST_AUTO_TEST_CASE_TEMPLATE(test_erase_loop_range, HMap, test_types) {
+  // insert x values, delete all five by five
+  const std::size_t hop = 5;
+  std::size_t nb_values = 1000;
+
+  BOOST_REQUIRE_EQUAL(nb_values % hop, 0u);
+
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+
+  auto it = map.begin();
+  while (it != map.end()) {
+    it = map.erase(it, std::next(it, hop));
+    nb_values -= hop;
+
+    BOOST_CHECK_EQUAL(map.size(), nb_values);
+  }
+
+  BOOST_CHECK(map.empty());
+}
+
+BOOST_AUTO_TEST_CASE_TEMPLATE(test_insert_erase_insert, HMap, test_types) {
+  // insert x/2 values, delete x/4 values, insert x/2 values, find each value,
+  // check order of values
+  using key_tt = typename HMap::key_type;
+  using value_tt = typename HMap::mapped_type;
+
+  const std::size_t nb_values = 2000;
+  HMap map(10);
+  typename HMap::iterator it;
+  bool inserted;
+
+  // Insert nb_values/2
+  for (std::size_t i = 0; i < nb_values / 2; i++) {
+    std::tie(it, inserted) =
+        map.insert({utils::get_key<key_tt>(i), utils::get_value<value_tt>(i)});
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(i));
+    BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(i));
+    BOOST_CHECK(inserted);
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values / 2);
+
+  // Delete nb_values/4
+  for (std::size_t i = 0; i < nb_values / 2; i++) {
+    if (i % 2 == 0) {
+      BOOST_CHECK_EQUAL(map.erase(utils::get_key<key_tt>(i)), 1u);
+    }
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values / 4);
+
+  // Insert nb_values/2
+  for (std::size_t i = nb_values / 2; i < nb_values; i++) {
+    std::tie(it, inserted) =
+        map.insert({utils::get_key<key_tt>(i), utils::get_value<value_tt>(i)});
+
+    BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(i));
+    BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(i));
+    BOOST_CHECK(inserted);
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values - nb_values / 4);
+
+  // Find
+  for (std::size_t i = 0; i < nb_values; i++) {
+    if (i % 2 == 0 && i < nb_values / 2) {
+      it = map.find(utils::get_key<key_tt>(i));
+
+      BOOST_CHECK(it == map.cend());
+    } else {
+      it = map.find(utils::get_key<key_tt>(i));
+
+      BOOST_REQUIRE(it != map.end());
+      BOOST_CHECK_EQUAL(it->first, utils::get_key<key_tt>(i));
+      BOOST_CHECK_EQUAL(it->second, utils::get_value<value_tt>(i));
+    }
+  }
+
+  // Check order
+  std::size_t i = 1;
+  for (const auto& key_value : map) {
+    if (i < nb_values / 2) {
+      BOOST_CHECK_EQUAL(key_value.first, utils::get_key<key_tt>(i));
+      BOOST_CHECK_EQUAL(key_value.second, utils::get_value<value_tt>(i));
+
+      i = std::min(i + 2, nb_values / 2);
+    } else {
+      BOOST_CHECK_EQUAL(key_value.first, utils::get_key<key_tt>(i));
+      BOOST_CHECK_EQUAL(key_value.second, utils::get_value<value_tt>(i));
+
+      i++;
+    }
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_range_erase_same_iterators) {
+  // insert x values, test erase with same iterator as each parameter, check if
+  // returned mutable iterator is valid.
+  const std::size_t nb_values = 100;
+  auto map =
+      utils::get_filled_hash_map<tsl::ordered_map<std::int64_t, std::int64_t>>(
+          nb_values);
+
+  tsl::ordered_map<std::int64_t, std::int64_t>::const_iterator it_const =
+      map.cbegin();
+  std::advance(it_const, 10);
+
+  tsl::ordered_map<std::int64_t, std::int64_t>::iterator it_mutable =
+      map.erase(it_const, it_const);
+  BOOST_CHECK(it_const == it_mutable);
+  BOOST_CHECK(map.mutable_iterator(it_const) == it_mutable);
+  BOOST_CHECK_EQUAL(map.size(), 100u);
+
+  it_mutable.value() = -100;
+  BOOST_CHECK_EQUAL(it_const.value(), -100);
+}
+
+/**
+ * erase_if
+ */
+BOOST_AUTO_TEST_CASE(test_erase_if) {
+  using map_type = tsl::ordered_map<int, int>;
+  using value_type = map_type::value_type;
+  tsl::ordered_map<int, int> map{{0, 2}, {16, 2}, {24, 2}, {5, 5},
+                                 {6, 2}, {7, 7},  {8, 8},  {9, 9}};
+
+  auto n = erase_if(map, [](const value_type& x) { return x.second == 2; });
+  BOOST_CHECK_EQUAL(n, 4);
+
+  n = erase_if(map, [](const value_type& x) { return x.second == 2; });
+  BOOST_CHECK_EQUAL(n, 0);
+
+  BOOST_CHECK_EQUAL(map.size(), 4);
+
+  BOOST_CHECK_EQUAL(map.at(5), 5);
+  BOOST_CHECK_EQUAL(map.at(7), 7);
+  BOOST_CHECK_EQUAL(map.at(8), 8);
+  BOOST_CHECK_EQUAL(map.at(9), 9);
+
+  BOOST_CHECK(map.find(0) == map.end());
+  BOOST_CHECK(map.find(6) == map.end());
+  BOOST_CHECK(map.find(16) == map.end());
+  BOOST_CHECK(map.find(24) == map.end());
+}
+
+/**
+ * unordered_erase
+ */
+BOOST_AUTO_TEST_CASE(test_unordered_erase) {
+  std::size_t nb_values = 100;
+  auto map =
+      utils::get_filled_hash_map<tsl::ordered_map<std::int64_t, std::int64_t>>(
+          nb_values);
+
+  BOOST_CHECK_EQUAL(map.unordered_erase(3), 1u);
+  BOOST_CHECK_EQUAL(map.size(), --nb_values);
+
+  BOOST_CHECK_EQUAL(map.unordered_erase(-1), 0u);
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  auto it = map.begin();
+  while (it != map.end()) {
+    it = map.unordered_erase(it);
+    BOOST_CHECK_EQUAL(map.size(), --nb_values);
+  }
+
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+}
+
+/**
+ * rehash
+ */
+BOOST_AUTO_TEST_CASE(test_rehash_empty) {
+  // test rehash(0), test find/erase/insert on map.
+  const std::size_t nb_values = 100;
+  auto map =
+      utils::get_filled_hash_map<tsl::ordered_map<std::int64_t, std::int64_t>>(
+          nb_values);
+
+  const std::size_t bucket_count = map.bucket_count();
+  BOOST_CHECK(bucket_count >= nb_values);
+
+  map.clear();
+  BOOST_CHECK_EQUAL(map.bucket_count(), bucket_count);
+  BOOST_CHECK(map.empty());
+
+  map.rehash(0);
+  BOOST_CHECK_EQUAL(map.bucket_count(), 0u);
+  BOOST_CHECK(map.empty());
+
+  BOOST_CHECK(map.find(1) == map.end());
+  BOOST_CHECK_EQUAL(map.erase(1), 0u);
+  BOOST_CHECK(map.insert({1, 10}).second);
+  BOOST_CHECK_EQUAL(map.at(1), 10);
+}
+
+/**
+ * operator== and operator!=
+ */
+BOOST_AUTO_TEST_CASE(test_compare) {
+  const tsl::ordered_map<std::string, int> map = {{"D", 1}, {"L", 2}, {"A", 3}};
+
+  BOOST_ASSERT(utils::test_is_equal(
+      map, tsl::ordered_map<std::string, int>{{"D", 1}, {"L", 2}, {"A", 3}}));
+  BOOST_ASSERT(map != (tsl::ordered_map<std::string, int>{
+                          {"L", 2}, {"D", 1}, {"A", 3}}));
+
+  BOOST_ASSERT(
+      map < (tsl::ordered_map<std::string, int>{{"D", 1}, {"L", 2}, {"B", 3}}));
+  BOOST_ASSERT(map <= (tsl::ordered_map<std::string, int>{
+                          {"D", 1}, {"L", 2}, {"B", 3}}));
+  BOOST_ASSERT(map <= (tsl::ordered_map<std::string, int>{
+                          {"D", 1}, {"L", 2}, {"A", 3}}));
+
+  BOOST_ASSERT(
+      map > (tsl::ordered_map<std::string, int>{{"D", 1}, {"K", 2}, {"A", 3}}));
+  BOOST_ASSERT(map >= (tsl::ordered_map<std::string, int>{
+                          {"D", 1}, {"K", 2}, {"A", 3}}));
+  BOOST_ASSERT(map >= (tsl::ordered_map<std::string, int>{
+                          {"D", 1}, {"L", 2}, {"A", 3}}));
+}
+
+/**
+ * clear
+ */
+BOOST_AUTO_TEST_CASE(test_clear) {
+  // insert x values, clear map, insert new values
+  using HMap = tsl::ordered_map<std::int64_t, std::int64_t>;
+
+  const std::size_t nb_values = 1000;
+  auto map = utils::get_filled_hash_map<HMap>(nb_values);
+
+  map.clear();
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+  BOOST_CHECK_EQUAL(std::distance(map.begin(), map.end()), 0);
+
+  map.insert({5, -5});
+  map.insert({{1, -1}, {2, -1}, {4, -4}, {3, -3}});
+
+  BOOST_CHECK(utils::test_is_equal(
+      map, HMap({{5, -5}, {1, -1}, {2, -1}, {4, -4}, {3, -3}})));
+}
+
+/**
+ * iterator
+ */
+BOOST_AUTO_TEST_CASE(test_reverse_iterator) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{1, 1}, {-2, 2}, {3, 3}};
+  map[2] = 4;
+
+  std::int64_t i = 4;
+  for (auto it = map.rbegin(); it != map.rend(); ++it) {
+    BOOST_CHECK_EQUAL(it->second, i);
+    i--;
+  }
+
+  i = 4;
+  for (auto it = map.rcbegin(); it != map.rcend(); ++it) {
+    BOOST_CHECK_EQUAL(it->second, i);
+    i--;
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_iterator_arithmetic) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {
+      {1, 10}, {2, 20}, {3, 30}, {4, 40}, {5, 50}, {6, 60}};
+
+  tsl::ordered_map<std::int64_t, std::int64_t>::const_iterator it;
+  tsl::ordered_map<std::int64_t, std::int64_t>::const_iterator it2;
+
+  it = map.cbegin();
+  // it += n
+  it += 3;
+  BOOST_CHECK_EQUAL(it->second, 40);
+
+  // it + n
+  BOOST_CHECK_EQUAL((map.cbegin() + 3)->second, 40);
+  // n + it
+  BOOST_CHECK_EQUAL((3 + map.cbegin())->second, 40);
+
+  it = map.cbegin() + 4;
+  // it -= n
+  it -= 2;
+  BOOST_CHECK_EQUAL(it->second, 30);
+
+  // it - n
+  BOOST_CHECK_EQUAL((it - 1)->second, 20);
+
+  it = map.cbegin() + 2;
+  it2 = map.cbegin() + 4;
+  // it - it
+  BOOST_CHECK_EQUAL(it2 - it, 2);
+
+  // it[n]
+  BOOST_CHECK_EQUAL(map.cbegin()[2].second, 30);
+
+  it = map.cbegin() + 1;
+  // it[n]
+  BOOST_CHECK_EQUAL(it[2].second, 40);
+
+  it = map.cbegin();
+  // it++
+  it++;
+  BOOST_CHECK_EQUAL((it++)->second, 20);
+
+  it = map.cbegin();
+  // ++it
+  ++it;
+  BOOST_CHECK_EQUAL((++it)->second, 30);
+
+  it = map.cend();
+  // it--
+  it--;
+  BOOST_CHECK_EQUAL((it--)->second, 60);
+
+  it = map.cend();
+  // --it
+  --it;
+  BOOST_CHECK_EQUAL((--it)->second, 50);
+}
+
+BOOST_AUTO_TEST_CASE(test_iterator_compartors) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {
+      {1, 10}, {2, 20}, {3, 30}, {4, 40}, {5, 50}, {6, 60}};
+
+  tsl::ordered_map<std::int64_t, std::int64_t>::const_iterator it;
+  tsl::ordered_map<std::int64_t, std::int64_t>::const_iterator it2;
+
+  it = map.begin() + 1;
+  it2 = map.end() - 1;
+
+  BOOST_CHECK(it < it2);
+  BOOST_CHECK(it <= it2);
+  BOOST_CHECK(it2 > it);
+  BOOST_CHECK(it2 >= it);
+
+  it = map.begin() + 3;
+  it2 = map.end() - 3;
+
+  BOOST_CHECK(it == it2);
+  BOOST_CHECK(it <= it2);
+  BOOST_CHECK(it >= it2);
+  BOOST_CHECK(it2 <= it);
+  BOOST_CHECK(it2 >= it);
+  BOOST_CHECK(!(it < it2));
+  BOOST_CHECK(!(it > it2));
+  BOOST_CHECK(!(it2 < it));
+  BOOST_CHECK(!(it2 > it));
+}
+
+/**
+ * iterator.value()
+ */
+BOOST_AUTO_TEST_CASE(test_modify_value) {
+  // insert x values, modify value of even keys, check values
+  const std::size_t nb_values = 100;
+  auto map =
+      utils::get_filled_hash_map<tsl::ordered_map<std::int64_t, std::int64_t>>(
+          nb_values);
+
+  for (auto it = map.begin(); it != map.end(); ++it) {
+    if (it->first % 2 == 0) {
+      it.value() = -1;
+    }
+  }
+
+  for (auto& val : map) {
+    if (val.first % 2 == 0) {
+      BOOST_CHECK_EQUAL(val.second, -1);
+    } else {
+      BOOST_CHECK_NE(val.second, -1);
+    }
+  }
+}
+
+/**
+ * max_size
+ */
+BOOST_AUTO_TEST_CASE(test_max_size) {
+  // TODO not compatible on systems with sizeof(std::size_t) <
+  // sizeof(std::uint32_t), will not build.
+  tsl::ordered_map<int, int, std::hash<int>, std::equal_to<int>,
+                   std::allocator<std::pair<int, int>>,
+                   std::vector<std::pair<int, int>>, std::uint16_t>
+      map;
+  BOOST_CHECK(map.max_size() <= std::numeric_limits<std::uint16_t>::max());
+  BOOST_CHECK(map.max_size() > std::numeric_limits<std::uint8_t>::max());
+
+  tsl::ordered_map<int, int, std::hash<int>, std::equal_to<int>,
+                   std::allocator<std::pair<int, int>>,
+                   std::vector<std::pair<int, int>>, std::uint32_t>
+      map2;
+  BOOST_CHECK(map2.max_size() <= std::numeric_limits<std::uint32_t>::max());
+  BOOST_CHECK(map2.max_size() > std::numeric_limits<std::uint16_t>::max());
+
+  using max_size_type =
+      std::conditional<sizeof(std::size_t) == sizeof(std::uint64_t),
+                       std::uint64_t, std::uint32_t>::type;
+  using min_size_type =
+      std::conditional<sizeof(std::size_t) == sizeof(std::uint64_t),
+                       std::uint32_t, std::uint16_t>::type;
+  tsl::ordered_map<int, int, std::hash<int>, std::equal_to<int>,
+                   std::allocator<std::pair<int, int>>,
+                   std::vector<std::pair<int, int>>, max_size_type>
+      map3;
+  BOOST_CHECK(map3.max_size() <= std::numeric_limits<max_size_type>::max());
+  BOOST_CHECK(map3.max_size() > std::numeric_limits<min_size_type>::max());
+}
+
+/**
+ * constructor
+ */
+BOOST_AUTO_TEST_CASE(test_extreme_bucket_count_value_construction) {
+  TSL_OH_CHECK_THROW(
+      (tsl::ordered_map<int, int>(std::numeric_limits<std::size_t>::max())),
+      std::length_error);
+}
+
+BOOST_AUTO_TEST_CASE(test_range_construct) {
+  tsl::ordered_map<int, int> map = {{2, 1}, {1, 0}, {3, 2}};
+
+  tsl::ordered_map<int, int> map2(map.begin(), map.end());
+  tsl::ordered_map<int, int> map3(map.cbegin(), map.cend());
+}
+
+/**
+ * operator=(std::initializer_list)
+ */
+BOOST_AUTO_TEST_CASE(test_assign_operator) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};
+  BOOST_CHECK_EQUAL(map.size(), 2u);
+
+  map = {{1, 3}, {2, 4}};
+  BOOST_CHECK_EQUAL(map.size(), 2u);
+  BOOST_CHECK_EQUAL(map.at(1), 3);
+  BOOST_CHECK_EQUAL(map.at(2), 4);
+  BOOST_CHECK(map.find(0) == map.end());
+
+  map = {};
+  BOOST_CHECK(map.empty());
+}
+
+/**
+ * move/copy constructor/operator
+ */
+BOOST_AUTO_TEST_CASE(test_move_constructor) {
+  // insert x values in map, move map into map_move, check map and map_move,
+  // insert additional values in map_move, check map_move
+  using HMap = tsl::ordered_map<std::string, move_only_test>;
+
+  const std::size_t nb_values = 100;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+  HMap map_move(std::move(map));
+
+  BOOST_CHECK(utils::test_is_equal(
+      map_move, utils::get_filled_hash_map<HMap>(nb_values)));
+  BOOST_CHECK(utils::test_is_equal(map, HMap()));
+
+  for (std::size_t i = nb_values; i < nb_values * 2; i++) {
+    map_move.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+
+  BOOST_CHECK_EQUAL(map_move.size(), nb_values * 2);
+  BOOST_CHECK(utils::test_is_equal(
+      map_move, utils::get_filled_hash_map<HMap>(nb_values * 2)));
+}
+
+BOOST_AUTO_TEST_CASE(test_move_constructor_empty) {
+  tsl::ordered_map<std::string, move_only_test> map(0);
+  tsl::ordered_map<std::string, move_only_test> map_move(std::move(map));
+
+  BOOST_CHECK(map.empty());
+  BOOST_CHECK(map_move.empty());
+
+  BOOST_CHECK(map.find("") == map.end());
+  BOOST_CHECK(map_move.find("") == map_move.end());
+}
+
+BOOST_AUTO_TEST_CASE(test_move_operator) {
+  // insert x values in map, move map into map_move, check map and map_move,
+  // insert additional values in map_move, check map_move
+  using HMap = tsl::ordered_map<std::string, move_only_test>;
+
+  const std::size_t nb_values = 100;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+  HMap map_move = utils::get_filled_hash_map<HMap>(1);
+  map_move = std::move(map);
+
+  BOOST_CHECK(utils::test_is_equal(
+      map_move, utils::get_filled_hash_map<HMap>(nb_values)));
+  BOOST_CHECK(utils::test_is_equal(map, HMap()));
+
+  for (std::size_t i = nb_values; i < nb_values * 2; i++) {
+    map_move.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+
+  BOOST_CHECK_EQUAL(map_move.size(), nb_values * 2);
+  BOOST_CHECK(utils::test_is_equal(
+      map_move, utils::get_filled_hash_map<HMap>(nb_values * 2)));
+}
+
+BOOST_AUTO_TEST_CASE(test_move_operator_empty) {
+  tsl::ordered_map<std::string, move_only_test> map(0);
+  tsl::ordered_map<std::string, move_only_test> map_move;
+  map_move = (std::move(map));
+
+  BOOST_CHECK(map.empty());
+  BOOST_CHECK(map_move.empty());
+
+  BOOST_CHECK(map.find("") == map.end());
+  BOOST_CHECK(map_move.find("") == map_move.end());
+}
+
+BOOST_AUTO_TEST_CASE(test_reassign_moved_object_move_constructor) {
+  using HMap = tsl::ordered_map<std::string, std::string>;
+
+  HMap map = {{"Key1", "Value1"}, {"Key2", "Value2"}, {"Key3", "Value3"}};
+  HMap map_move(std::move(map));
+
+  BOOST_CHECK_EQUAL(map_move.size(), 3u);
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+
+  map = {{"Key4", "Value4"}, {"Key5", "Value5"}};
+  BOOST_CHECK(utils::test_is_equal(
+      map, HMap({{"Key4", "Value4"}, {"Key5", "Value5"}})));
+}
+
+BOOST_AUTO_TEST_CASE(test_reassign_moved_object_move_operator) {
+  using HMap = tsl::ordered_map<std::string, std::string>;
+
+  HMap map = {{"Key1", "Value1"}, {"Key2", "Value2"}, {"Key3", "Value3"}};
+  HMap map_move = std::move(map);
+
+  BOOST_CHECK_EQUAL(map_move.size(), 3u);
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+
+  map = {{"Key4", "Value4"}, {"Key5", "Value5"}};
+  BOOST_CHECK(utils::test_is_equal(
+      map, HMap({{"Key4", "Value4"}, {"Key5", "Value5"}})));
+}
+
+BOOST_AUTO_TEST_CASE(test_use_after_move_constructor) {
+  using HMap = tsl::ordered_map<std::string, move_only_test>;
+
+  const std::size_t nb_values = 100;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+  HMap map_move(std::move(map));
+
+  BOOST_CHECK(utils::test_is_equal(map, HMap()));
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+  BOOST_CHECK_EQUAL(map.bucket_count(), 0u);
+  BOOST_CHECK_EQUAL(map.erase("a"), 0u);
+  BOOST_CHECK(map.find("a") == map.end());
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    map.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+  BOOST_CHECK(utils::test_is_equal(map, map_move));
+}
+
+BOOST_AUTO_TEST_CASE(test_use_after_move_operator) {
+  using HMap = tsl::ordered_map<std::string, move_only_test>;
+
+  const std::size_t nb_values = 100;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+  HMap map_move(0);
+  map_move = std::move(map);
+
+  BOOST_CHECK(utils::test_is_equal(map, HMap()));
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+  BOOST_CHECK_EQUAL(map.bucket_count(), 0u);
+  BOOST_CHECK_EQUAL(map.erase("a"), 0u);
+  BOOST_CHECK(map.find("a") == map.end());
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    map.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+  BOOST_CHECK(utils::test_is_equal(map, map_move));
+}
+
+BOOST_AUTO_TEST_CASE(test_copy_constructor_and_operator) {
+  using HMap = tsl::ordered_map<std::string, std::string, mod_hash<9>>;
+
+  const std::size_t nb_values = 100;
+  HMap map = utils::get_filled_hash_map<HMap>(nb_values);
+
+  HMap map_copy = map;
+  HMap map_copy2(map);
+  HMap map_copy3 = utils::get_filled_hash_map<HMap>(1);
+  map_copy3 = map;
+
+  BOOST_CHECK(utils::test_is_equal(map, map_copy));
+  map.clear();
+
+  BOOST_CHECK(utils::test_is_equal(map_copy, map_copy2));
+  BOOST_CHECK(utils::test_is_equal(map_copy, map_copy3));
+}
+
+BOOST_AUTO_TEST_CASE(test_copy_constructor_empty) {
+  tsl::ordered_map<std::string, int> map(0);
+  tsl::ordered_map<std::string, int> map_copy(map);
+
+  BOOST_CHECK(map.empty());
+  BOOST_CHECK(map_copy.empty());
+
+  BOOST_CHECK(map.find("") == map.end());
+  BOOST_CHECK(map_copy.find("") == map_copy.end());
+}
+
+BOOST_AUTO_TEST_CASE(test_copy_operator_empty) {
+  tsl::ordered_map<std::string, int> map(0);
+  tsl::ordered_map<std::string, int> map_copy(16);
+  map_copy = map;
+
+  BOOST_CHECK(map.empty());
+  BOOST_CHECK(map_copy.empty());
+
+  BOOST_CHECK(map.find("") == map.end());
+  BOOST_CHECK(map_copy.find("") == map_copy.end());
+}
+
+/**
+ * at
+ */
+BOOST_AUTO_TEST_CASE(test_at) {
+  // insert x values, use at for known and unknown values.
+  const tsl::ordered_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};
+
+  BOOST_CHECK_EQUAL(map.at(0), 10);
+  BOOST_CHECK_EQUAL(map.at(-2), 20);
+  TSL_OH_CHECK_THROW(map.at(1), std::out_of_range);
+}
+
+/**
+ * contains
+ */
+BOOST_AUTO_TEST_CASE(test_contains) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};
+
+  BOOST_CHECK(map.contains(0));
+  BOOST_CHECK(map.contains(-2));
+  BOOST_CHECK(!map.contains(-3));
+}
+
+/**
+ * equal_range
+ */
+BOOST_AUTO_TEST_CASE(test_equal_range) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};
+
+  auto it_pair = map.equal_range(0);
+  BOOST_REQUIRE_EQUAL(std::distance(it_pair.first, it_pair.second), 1);
+  BOOST_CHECK_EQUAL(it_pair.first->second, 10);
+
+  it_pair = map.equal_range(1);
+  BOOST_CHECK(it_pair.first == it_pair.second);
+  BOOST_CHECK(it_pair.first == map.end());
+}
+
+/**
+ * release
+ */
+BOOST_AUTO_TEST_CASE(test_release) {
+  auto vec = std::deque<std::pair<int, int>>{{1, 1}, {2, 2}, {3, 3}};
+  auto map = tsl::ordered_map<int, int>{vec.begin(), vec.end()};
+
+  BOOST_CHECK(map.release() == vec);
+  BOOST_CHECK(map.empty());
+}
+
+/**
+ * data()
+ */
+BOOST_AUTO_TEST_CASE(test_data) {
+  tsl::ordered_map<std::int64_t, std::int64_t, std::hash<std::int64_t>,
+                   std::equal_to<std::int64_t>,
+                   std::allocator<std::pair<std::int64_t, std::int64_t>>,
+                   std::vector<std::pair<std::int64_t, std::int64_t>>>
+      map = {{1, -1}, {2, -2}, {4, -4}, {3, -3}};
+
+  BOOST_CHECK(map.data() == map.values_container().data());
+}
+
+/**
+ * operator[]
+ */
+BOOST_AUTO_TEST_CASE(test_access_operator) {
+  // insert x values, use at for known and unknown values.
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{0, 10}, {-2, 20}};
+
+  BOOST_CHECK_EQUAL(map[0], 10);
+  BOOST_CHECK_EQUAL(map[-2], 20);
+  BOOST_CHECK_EQUAL(map[2], std::int64_t());
+
+  BOOST_CHECK_EQUAL(map.size(), 3u);
+}
+
+/**
+ * swap
+ */
+BOOST_AUTO_TEST_CASE(test_swap) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {
+      {1, 10}, {8, 80}, {3, 30}};
+  tsl::ordered_map<std::int64_t, std::int64_t> map2 = {{4, 40}, {5, 50}};
+
+  using std::swap;
+  swap(map, map2);
+
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::int64_t, std::int64_t>{{4, 40}, {5, 50}}));
+  BOOST_CHECK(utils::test_is_equal(
+      map2,
+      tsl::ordered_map<std::int64_t, std::int64_t>{{1, 10}, {8, 80}, {3, 30}}));
+
+  map.insert({6, 60});
+  map2.insert({4, 40});
+
+  BOOST_CHECK(utils::test_is_equal(
+      map,
+      tsl::ordered_map<std::int64_t, std::int64_t>{{4, 40}, {5, 50}, {6, 60}}));
+  BOOST_CHECK(
+      utils::test_is_equal(map2, tsl::ordered_map<std::int64_t, std::int64_t>{
+                                     {1, 10}, {8, 80}, {3, 30}, {4, 40}}));
+}
+
+BOOST_AUTO_TEST_CASE(test_swap_empty) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {
+      {1, 10}, {8, 80}, {3, 30}};
+  tsl::ordered_map<std::int64_t, std::int64_t> map2;
+
+  using std::swap;
+  swap(map, map2);
+
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::int64_t, std::int64_t>{}));
+  BOOST_CHECK(utils::test_is_equal(
+      map2,
+      tsl::ordered_map<std::int64_t, std::int64_t>{{1, 10}, {8, 80}, {3, 30}}));
+
+  map.insert({6, 60});
+  map2.insert({4, 40});
+
+  BOOST_CHECK(utils::test_is_equal(
+      map, tsl::ordered_map<std::int64_t, std::int64_t>{{6, 60}}));
+  BOOST_CHECK(
+      utils::test_is_equal(map2, tsl::ordered_map<std::int64_t, std::int64_t>{
+                                     {1, 10}, {8, 80}, {3, 30}, {4, 40}}));
+}
+
+/**
+ * serialize and deserialize
+ */
+BOOST_AUTO_TEST_CASE(test_serialize_deserialize_empty) {
+  // serialize empty map; deserialize in new map; check equal.
+  // for deserialization, test it with and without hash compatibility.
+  const tsl::ordered_map<std::string, move_only_test> empty_map(0);
+
+  serializer serial;
+  empty_map.serialize(serial);
+
+  deserializer dserial(serial.str());
+  auto empty_map_deserialized = decltype(empty_map)::deserialize(dserial, true);
+  BOOST_CHECK(utils::test_is_equal(empty_map_deserialized, empty_map));
+
+  deserializer dserial2(serial.str());
+  empty_map_deserialized = decltype(empty_map)::deserialize(dserial2, false);
+  BOOST_CHECK(utils::test_is_equal(empty_map_deserialized, empty_map));
+}
+
+BOOST_AUTO_TEST_CASE(test_serialize_deserialize) {
+  // insert x values; delete some values; serialize map; deserialize in new map;
+  // check equal. for deserialization, test it with and without hash
+  // compatibility.
+  const std::size_t nb_values = 1000;
+
+  tsl::ordered_map<std::string, move_only_test> map;
+  for (std::size_t i = 0; i < nb_values + 40; i++) {
+    map.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+
+  for (std::size_t i = nb_values; i < nb_values + 40; i++) {
+    map.erase(utils::get_key<std::string>(i));
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  serializer serial;
+  map.serialize(serial);
+
+  deserializer dserial(serial.str());
+  auto map_deserialized = decltype(map)::deserialize(dserial, true);
+  BOOST_CHECK(utils::test_is_equal(map, map_deserialized));
+
+  deserializer dserial2(serial.str());
+  map_deserialized = decltype(map)::deserialize(dserial2, false);
+  BOOST_CHECK(utils::test_is_equal(map_deserialized, map));
+}
+
+BOOST_AUTO_TEST_CASE(test_serialize_deserialize_with_different_hash) {
+  // insert x values; serialize map; deserialize in new map which has a
+  // different hash; check equal
+  struct hash_str_diff {
+    std::size_t operator()(const std::string& str) const {
+      return std::hash<std::string>()(str) + 123;
+    }
+  };
+
+  const std::size_t nb_values = 1000;
+
+  tsl::ordered_map<std::string, move_only_test> map;
+  for (std::size_t i = 0; i < nb_values; i++) {
+    map.insert(
+        {utils::get_key<std::string>(i), utils::get_value<move_only_test>(i)});
+  }
+  BOOST_CHECK_EQUAL(map.size(), nb_values);
+
+  serializer serial;
+  map.serialize(serial);
+
+  deserializer dserial(serial.str());
+  auto map_deserialized =
+      tsl::ordered_map<std::string, move_only_test, hash_str_diff>::deserialize(
+          dserial, false);
+
+  BOOST_CHECK_EQUAL(map_deserialized.size(), map.size());
+  for (const auto& val : map) {
+    BOOST_CHECK(map_deserialized.find(val.first) != map_deserialized.end());
+  }
+}
+
+/**
+ * front(), back()
+ */
+BOOST_AUTO_TEST_CASE(test_front_back) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{1, 10}, {2, 20}};
+  map.insert({0, 0});
+
+  BOOST_CHECK(map.front() == (std::pair<std::int64_t, std::int64_t>(1, 10)));
+  BOOST_CHECK(map.back() == (std::pair<std::int64_t, std::int64_t>(0, 0)));
+
+  map.clear();
+  map.insert({3, 30});
+  BOOST_CHECK(map.front() == (std::pair<std::int64_t, std::int64_t>(3, 30)));
+  BOOST_CHECK(map.back() == (std::pair<std::int64_t, std::int64_t>(3, 30)));
+}
+
+/**
+ * nth()
+ */
+BOOST_AUTO_TEST_CASE(test_nth) {
+  tsl::ordered_map<std::int64_t, std::int64_t> map = {{1, 10}, {2, 20}};
+  map.insert({0, 0});
+
+  BOOST_REQUIRE(map.nth(0) != map.end());
+  BOOST_CHECK(*map.nth(0) == (std::pair<std::int64_t, std::int64_t>(1, 10)));
+
+  BOOST_REQUIRE(map.nth(1) != map.end());
+  BOOST_CHECK(*map.nth(1) == (std::pair<std::int64_t, std::int64_t>(2, 20)));
+
+  BOOST_REQUIRE(map.nth(2) != map.end());
+  BOOST_CHECK(*map.nth(2) == (std::pair<std::int64_t, std::int64_t>(0, 0)));
+
+  BOOST_REQUIRE(map.nth(3) == map.end());
+
+  map.clear();
+  BOOST_REQUIRE(map.nth(0) == map.end());
+}
+
+/**
+ * KeyEqual
+ */
+BOOST_AUTO_TEST_CASE(test_key_equal) {
+  // Use a KeyEqual and Hash where any odd unsigned number 'x' is equal to
+  // 'x-1'. Make sure that KeyEqual is called (and not ==).
+  struct hash {
+    std::size_t operator()(std::uint64_t v) const {
+      if (v % 2u == 1u) {
+        return std::hash<std::uint64_t>()(v - 1);
+      } else {
+        return std::hash<std::uint64_t>()(v);
+      }
+    }
+  };
+
+  struct key_equal {
+    bool operator()(std::uint64_t lhs, std::uint64_t rhs) const {
+      if (lhs % 2u == 1u) {
+        lhs--;
+      }
+
+      if (rhs % 2u == 1u) {
+        rhs--;
+      }
+
+      return lhs == rhs;
+    }
+  };
+
+  tsl::ordered_map<std::uint64_t, std::uint64_t, hash, key_equal> map;
+  BOOST_CHECK(map.insert({2, 10}).second);
+  BOOST_CHECK_EQUAL(map.at(2), 10u);
+  BOOST_CHECK_EQUAL(map.at(3), 10u);
+  BOOST_CHECK(!map.insert({3, 10}).second);
+
+  BOOST_CHECK_EQUAL(map.size(), 1u);
+}
+
+/**
+ * other
+ */
+BOOST_AUTO_TEST_CASE(test_heterogeneous_lookups) {
+  struct hash_ptr {
+    std::size_t operator()(const std::unique_ptr<int>& p) const {
+      return std::hash<std::uintptr_t>()(
+          reinterpret_cast<std::uintptr_t>(p.get()));
+    }
+
+    std::size_t operator()(std::uintptr_t p) const {
+      return std::hash<std::uintptr_t>()(p);
+    }
+
+    std::size_t operator()(const int* const& p) const {
+      return std::hash<std::uintptr_t>()(reinterpret_cast<std::uintptr_t>(p));
+    }
+  };
+
+  struct equal_to_ptr {
+    using is_transparent = std::true_type;
+
+    bool operator()(const std::unique_ptr<int>& p1,
+                    const std::unique_ptr<int>& p2) const {
+      return p1 == p2;
+    }
+
+    bool operator()(const std::unique_ptr<int>& p1, std::uintptr_t p2) const {
+      return reinterpret_cast<std::uintptr_t>(p1.get()) == p2;
+    }
+
+    bool operator()(std::uintptr_t p1, const std::unique_ptr<int>& p2) const {
+      return p1 == reinterpret_cast<std::uintptr_t>(p2.get());
+    }
+
+    bool operator()(const std::unique_ptr<int>& p1,
+                    const int* const& p2) const {
+      return p1.get() == p2;
+    }
+
+    bool operator()(const int* const& p1,
+                    const std::unique_ptr<int>& p2) const {
+      return p1 == p2.get();
+    }
+  };
+
+  std::unique_ptr<int> ptr1(new int(1));
+  std::unique_ptr<int> ptr2(new int(2));
+  std::unique_ptr<int> ptr3(new int(3));
+  int other = -1;
+
+  const std::uintptr_t addr1 = reinterpret_cast<std::uintptr_t>(ptr1.get());
+  const int* const addr2 = ptr2.get();
+  const int* const addr_unknown = &other;
+
+  tsl::ordered_map<std::unique_ptr<int>, int, hash_ptr, equal_to_ptr> map;
+  map.insert({std::move(ptr1), 4});
+  map.insert({std::move(ptr2), 5});
+  map.insert({std::move(ptr3), 6});
+
+  BOOST_CHECK_EQUAL(map.size(), 3u);
+
+  BOOST_CHECK_EQUAL(map.at(addr1), 4);
+  BOOST_CHECK_EQUAL(map.at(addr2), 5);
+  TSL_OH_CHECK_THROW(map.at(addr_unknown), std::out_of_range);
+
+  BOOST_REQUIRE(map.find(addr1) != map.end());
+  BOOST_CHECK_EQUAL(*map.find(addr1)->first, 1);
+
+  BOOST_REQUIRE(map.find(addr2) != map.end());
+  BOOST_CHECK_EQUAL(*map.find(addr2)->first, 2);
+
+  BOOST_CHECK(map.find(addr_unknown) == map.end());
+
+  BOOST_CHECK_EQUAL(map.count(addr1), 1u);
+  BOOST_CHECK_EQUAL(map.count(addr2), 1u);
+  BOOST_CHECK_EQUAL(map.count(addr_unknown), 0u);
+
+  BOOST_CHECK_EQUAL(map.erase(addr1), 1u);
+  BOOST_CHECK_EQUAL(map.unordered_erase(addr2), 1u);
+  BOOST_CHECK_EQUAL(map.erase(addr_unknown), 0u);
+  BOOST_CHECK_EQUAL(map.unordered_erase(addr_unknown), 0u);
+
+  BOOST_CHECK_EQUAL(map.size(), 1u);
+}
+
+/**
+ * Various operations on empty map
+ */
+BOOST_AUTO_TEST_CASE(test_empty_map) {
+  tsl::ordered_map<std::string, int> map(0);
+
+  BOOST_CHECK_EQUAL(map.bucket_count(), 0u);
+  BOOST_CHECK_EQUAL(map.size(), 0u);
+  BOOST_CHECK_EQUAL(map.load_factor(), 0);
+  BOOST_CHECK(map.empty());
+
+  BOOST_CHECK(map.begin() == map.end());
+  BOOST_CHECK(map.begin() == map.cend());
+  BOOST_CHECK(map.cbegin() == map.cend());
+
+  BOOST_CHECK(map.find("") == map.end());
+  BOOST_CHECK(map.find("test") == map.end());
+
+  BOOST_CHECK_EQUAL(map.count(""), 0u);
+  BOOST_CHECK_EQUAL(map.count("test"), 0u);
+
+  BOOST_CHECK(!map.contains(""));
+  BOOST_CHECK(!map.contains("test"));
+
+  TSL_OH_CHECK_THROW(map.at(""), std::out_of_range);
+  TSL_OH_CHECK_THROW(map.at("test"), std::out_of_range);
+
+  auto range = map.equal_range("test");
+  BOOST_CHECK(range.first == range.second);
+
+  BOOST_CHECK_EQUAL(map.erase("test"), 0u);
+  BOOST_CHECK(map.erase(map.begin(), map.end()) == map.end());
+
+  BOOST_CHECK_EQUAL(map["new value"], int{});
+}
+
+/**
+ * Test precalculated hash
+ */
+BOOST_AUTO_TEST_CASE(test_precalculated_hash) {
+  tsl::ordered_map<int, int, identity_hash<int>> map = {
+      {1, -1}, {2, -2}, {3, -3}, {4, -4}, {5, -5}, {6, -6}};
+  const tsl::ordered_map<int, int, identity_hash<int>> map_const = map;
+
+  /**
+   * find
+   */
+  BOOST_REQUIRE(map.find(3, map.hash_function()(3)) != map.end());
+  BOOST_CHECK_EQUAL(map.find(3, map.hash_function()(3))->second, -3);
+
+  BOOST_REQUIRE(map_const.find(3, map_const.hash_function()(3)) !=
+                map_const.end());
+  BOOST_CHECK_EQUAL(map_const.find(3, map_const.hash_function()(3))->second,
+                    -3);
+
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));
+  BOOST_CHECK(map.find(3, map.hash_function()(2)) == map.end());
+
+  /**
+   * at
+   */
+  BOOST_CHECK_EQUAL(map.at(3, map.hash_function()(3)), -3);
+  BOOST_CHECK_EQUAL(map_const.at(3, map_const.hash_function()(3)), -3);
+
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));
+  TSL_OH_CHECK_THROW(map.at(3, map.hash_function()(2)), std::out_of_range);
+
+  /**
+   * count
+   */
+  BOOST_CHECK(map.contains(3, map.hash_function()(3)));
+  BOOST_CHECK(map_const.contains(3, map_const.hash_function()(3)));
+
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));
+  BOOST_CHECK(!map.contains(3, map.hash_function()(2)));
+
+  /**
+   * count
+   */
+  BOOST_CHECK_EQUAL(map.count(3, map.hash_function()(3)), 1u);
+  BOOST_CHECK_EQUAL(map_const.count(3, map_const.hash_function()(3)), 1u);
+
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));
+  BOOST_CHECK_EQUAL(map.count(3, map.hash_function()(2)), 0u);
+
+  /**
+   * equal_range
+   */
+  auto it_range = map.equal_range(3, map.hash_function()(3));
+  BOOST_REQUIRE_EQUAL(std::distance(it_range.first, it_range.second), 1);
+  BOOST_CHECK_EQUAL(it_range.first->second, -3);
+
+  auto it_range_const = map_const.equal_range(3, map_const.hash_function()(3));
+  BOOST_REQUIRE_EQUAL(
+      std::distance(it_range_const.first, it_range_const.second), 1);
+  BOOST_CHECK_EQUAL(it_range_const.first->second, -3);
+
+  it_range = map.equal_range(3, map.hash_function()(2));
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(3));
+  BOOST_CHECK_EQUAL(std::distance(it_range.first, it_range.second), 0);
+
+  /**
+   * erase
+   */
+  BOOST_CHECK_EQUAL(map.erase(3, map.hash_function()(3)), 1u);
+
+  BOOST_REQUIRE_NE(map.hash_function()(2), map.hash_function()(4));
+  BOOST_CHECK_EQUAL(map.erase(4, map.hash_function()(2)), 0u);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/ordered_set_tests.cpp lightspark-master/src/3rdparty/ordered-map/tests/ordered_set_tests.cpp
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/ordered_set_tests.cpp	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/ordered_set_tests.cpp	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,167 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#include <boost/mpl/list.hpp>
+#include <boost/test/unit_test.hpp>
+#include <cstdint>
+#include <deque>
+#include <functional>
+#include <memory>
+#include <string>
+#include <tuple>
+#include <utility>
+#include <vector>
+
+#include "tsl/ordered_set.h"
+#include "utils.h"
+
+BOOST_AUTO_TEST_SUITE(test_ordered_set)
+
+using test_types = boost::mpl::list<
+    tsl::ordered_set<std::int64_t>,
+    tsl::ordered_set<std::int64_t, std::hash<std::int64_t>,
+                     std::equal_to<std::int64_t>, std::allocator<std::int64_t>,
+                     std::vector<std::int64_t>>,
+    tsl::ordered_set<std::int64_t, mod_hash<9>>, tsl::ordered_set<std::string>,
+    tsl::ordered_set<std::string, mod_hash<9>>,
+    tsl::ordered_set<move_only_test, mod_hash<9>>>;
+
+/**
+ * insert
+ */
+BOOST_AUTO_TEST_CASE_TEMPLATE(test_insert, HSet, test_types) {
+  // insert x values, insert them again, check values through find, check order
+  // through iterator
+  using key_t = typename HSet::key_type;
+
+  const std::size_t nb_values = 1000;
+
+  HSet set;
+  typename HSet::iterator it;
+  bool inserted;
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    std::tie(it, inserted) = set.insert(utils::get_key<key_t>(insert_val));
+
+    BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(insert_val));
+    BOOST_CHECK(inserted);
+  }
+  BOOST_CHECK_EQUAL(set.size(), nb_values);
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    std::tie(it, inserted) = set.insert(utils::get_key<key_t>(insert_val));
+
+    BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(insert_val));
+    BOOST_CHECK(!inserted);
+  }
+  BOOST_CHECK_EQUAL(set.size(), nb_values);
+
+  for (std::size_t i = 0; i < nb_values; i++) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+    it = set.find(utils::get_key<key_t>(insert_val));
+
+    BOOST_CHECK_EQUAL(*it, utils::get_key<key_t>(insert_val));
+  }
+
+  std::size_t i = 0;
+  for (const auto& value : set) {
+    const std::size_t insert_val = (i % 2 == 0) ? i : nb_values + i;
+
+    BOOST_CHECK_EQUAL(value, utils::get_key<key_t>(insert_val));
+
+    i++;
+  }
+}
+
+BOOST_AUTO_TEST_CASE(test_compare) {
+  const tsl::ordered_set<std::string> map = {"D", "L", "A"};
+
+  BOOST_ASSERT(map == (tsl::ordered_set<std::string>{"D", "L", "A"}));
+  BOOST_ASSERT(map != (tsl::ordered_set<std::string>{"L", "D", "A"}));
+
+  BOOST_ASSERT(map < (tsl::ordered_set<std::string>{"D", "L", "B"}));
+  BOOST_ASSERT(map <= (tsl::ordered_set<std::string>{"D", "L", "B"}));
+  BOOST_ASSERT(map <= (tsl::ordered_set<std::string>{"D", "L", "A"}));
+
+  BOOST_ASSERT(map > (tsl::ordered_set<std::string>{"D", {"K", 2}, "A"}));
+  BOOST_ASSERT(map >= (tsl::ordered_set<std::string>{"D", {"K", 2}, "A"}));
+  BOOST_ASSERT(map >= (tsl::ordered_set<std::string>{"D", "L", "A"}));
+}
+
+BOOST_AUTO_TEST_CASE(test_insert_pointer) {
+  // Test added mainly to be sure that the code compiles with MSVC
+  std::string value;
+  std::string* value_ptr = &value;
+
+  tsl::ordered_set<std::string*> set;
+  set.insert(value_ptr);
+  set.emplace(value_ptr);
+
+  BOOST_CHECK_EQUAL(set.size(), 1u);
+  BOOST_CHECK_EQUAL(**set.begin(), value);
+}
+
+BOOST_AUTO_TEST_CASE(test_erase_if) {
+  tsl::ordered_set<int> set{1, 2, 3, 4, 5};
+  auto num = erase_if(set, [](int x) { return 2 <= x && x <= 4; });
+
+  BOOST_CHECK_EQUAL(num, 3);
+  BOOST_CHECK_EQUAL(set.size(), 2);
+  BOOST_CHECK_EQUAL(set.front(), 1);
+  BOOST_CHECK_EQUAL(set.back(), 5);
+}
+
+/**
+ * serialize and deserialize
+ */
+BOOST_AUTO_TEST_CASE(test_serialize_deserialize) {
+  // insert x values; delete some values; serialize set; deserialize in new set;
+  // check equal. for deserialization, test it with and without hash
+  // compatibility.
+  const std::size_t nb_values = 1000;
+
+  tsl::ordered_set<move_only_test> set;
+  for (std::size_t i = 0; i < nb_values + 40; i++) {
+    set.insert(utils::get_key<move_only_test>(i));
+  }
+
+  for (std::size_t i = nb_values; i < nb_values + 40; i++) {
+    set.erase(utils::get_key<move_only_test>(i));
+  }
+  BOOST_CHECK_EQUAL(set.size(), nb_values);
+
+  serializer serial;
+  set.serialize(serial);
+
+  deserializer dserial(serial.str());
+  auto set_deserialized = decltype(set)::deserialize(dserial, true);
+  BOOST_CHECK(set == set_deserialized);
+
+  deserializer dserial2(serial.str());
+  set_deserialized = decltype(set)::deserialize(dserial2, false);
+  BOOST_CHECK(set_deserialized == set);
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tests/utils.h lightspark-master/src/3rdparty/ordered-map/tests/utils.h
--- lightspark-0.9.0/src/3rdparty/ordered-map/tests/utils.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tests/utils.h	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,358 @@
+/**
+ * MIT License
+ *
+ * Copyright (c) 2017 Thibaut Goetghebuer-Planchon <tessil@gmx.com>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef TSL_UTILS_H
+#define TSL_UTILS_H
+
+#include <cstddef>
+#include <cstdint>
+#include <functional>
+#include <memory>
+#include <ostream>
+#include <string>
+#include <utility>
+
+#include "tsl/ordered_hash.h"
+
+#ifdef TSL_OH_NO_EXCEPTIONS
+#define TSL_OH_CHECK_THROW(S, E)
+#else
+#define TSL_OH_CHECK_THROW(S, E) BOOST_CHECK_THROW(S, E)
+#endif
+
+template <typename T>
+class identity_hash {
+ public:
+  std::size_t operator()(const T& value) const {
+    return static_cast<std::size_t>(value);
+  }
+};
+
+template <unsigned int MOD>
+class mod_hash {
+ public:
+  template <typename T>
+  std::size_t operator()(const T& value) const {
+    return std::hash<T>()(value) % MOD;
+  }
+};
+
+class move_only_test {
+ public:
+  explicit move_only_test(std::int64_t value)
+      : m_value(new std::int64_t(value)) {}
+
+  move_only_test(const move_only_test&) = delete;
+  move_only_test(move_only_test&&) = default;
+  move_only_test& operator=(const move_only_test&) = delete;
+  move_only_test& operator=(move_only_test&&) = default;
+
+  friend std::ostream& operator<<(std::ostream& stream,
+                                  const move_only_test& value) {
+    if (value.m_value == nullptr) {
+      stream << "null";
+    } else {
+      stream << *value.m_value;
+    }
+
+    return stream;
+  }
+
+  friend bool operator==(const move_only_test& lhs, const move_only_test& rhs) {
+    if (lhs.m_value == nullptr || rhs.m_value == nullptr) {
+      return lhs.m_value == nullptr && rhs.m_value == nullptr;
+    } else {
+      return *lhs.m_value == *rhs.m_value;
+    }
+  }
+
+  friend bool operator!=(const move_only_test& lhs, const move_only_test& rhs) {
+    return !(lhs == rhs);
+  }
+
+  std::int64_t value() const { return *m_value; }
+
+ private:
+  std::unique_ptr<std::int64_t> m_value;
+};
+
+class copy_constructible_only_test {
+ public:
+  explicit copy_constructible_only_test(std::int64_t value) : m_value(value) {}
+
+  copy_constructible_only_test(const copy_constructible_only_test&) = default;
+  copy_constructible_only_test(copy_constructible_only_test&&) = delete;
+  copy_constructible_only_test& operator=(const copy_constructible_only_test&) =
+      delete;
+  copy_constructible_only_test& operator=(copy_constructible_only_test&&) =
+      delete;
+
+  friend std::ostream& operator<<(std::ostream& stream,
+                                  const copy_constructible_only_test& value) {
+    stream << value.m_value;
+    return stream;
+  }
+
+  friend bool operator==(const copy_constructible_only_test& lhs,
+                         const copy_constructible_only_test& rhs) {
+    return lhs.m_value == rhs.m_value;
+  }
+
+  friend bool operator!=(const copy_constructible_only_test& lhs,
+                         const copy_constructible_only_test& rhs) {
+    return !(lhs == rhs);
+  }
+
+  std::int64_t value() const { return m_value; }
+
+ private:
+  std::int64_t m_value;
+};
+
+namespace std {
+template <>
+struct hash<move_only_test> {
+  std::size_t operator()(const move_only_test& val) const {
+    return std::hash<std::int64_t>()(val.value());
+  }
+};
+
+template <>
+struct hash<copy_constructible_only_test> {
+  std::size_t operator()(const copy_constructible_only_test& val) const {
+    return std::hash<std::int64_t>()(val.value());
+  }
+};
+}  // namespace std
+
+class utils {
+ public:
+  template <typename T>
+  static T get_key(std::size_t counter);
+
+  template <typename T>
+  static T get_value(std::size_t counter);
+
+  template <typename HMap>
+  static HMap get_filled_hash_map(std::size_t nb_elements);
+
+  /**
+   * The ordered_map equality operator only compares the m_values structure as
+   * it is sufficient for ensuring equality. This method do a more extensive
+   * comparison to ensure that the internal state of the map is coherent.
+   */
+  template <typename HMap>
+  static bool test_is_equal(const HMap& lhs, const HMap& rhs) {
+    if (lhs != rhs) {
+      return false;
+    }
+
+    if(lhs.size() != rhs.size()) {
+      return false;
+    }
+
+    for (const auto& val_lhs : lhs) {
+      auto it_rhs = rhs.find(val_lhs.first);
+      if (it_rhs == rhs.end()) {
+        return false;
+      }
+
+      if (val_lhs.first != it_rhs->first) {
+        return false;
+      }
+
+      if (val_lhs.second != it_rhs->second) {
+        return false;
+      }
+    }
+
+    for (const auto& val_rhs : rhs) {
+      auto it_lhs = lhs.find(val_rhs.first);
+      if (it_lhs == lhs.end()) {
+        return false;
+      }
+
+      if (it_lhs->first != val_rhs.first) {
+        return false;
+      }
+
+      if (it_lhs->second != val_rhs.second) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+};
+
+template <>
+inline std::int64_t utils::get_key<std::int64_t>(std::size_t counter) {
+  return tsl::detail_ordered_hash::numeric_cast<std::int64_t>(counter);
+}
+
+template <>
+inline std::string utils::get_key<std::string>(std::size_t counter) {
+  return "Key " + std::to_string(counter);
+}
+
+template <>
+inline move_only_test utils::get_key<move_only_test>(std::size_t counter) {
+  return move_only_test(
+      tsl::detail_ordered_hash::numeric_cast<std::int64_t>(counter));
+}
+
+template <>
+inline std::int64_t utils::get_value<std::int64_t>(std::size_t counter) {
+  return tsl::detail_ordered_hash::numeric_cast<std::int64_t>(counter * 2);
+}
+
+template <>
+inline std::string utils::get_value<std::string>(std::size_t counter) {
+  return "Value " + std::to_string(counter);
+}
+
+template <>
+inline move_only_test utils::get_value<move_only_test>(std::size_t counter) {
+  return move_only_test(
+      tsl::detail_ordered_hash::numeric_cast<std::int64_t>(counter * 2));
+}
+
+template <typename HMap>
+inline HMap utils::get_filled_hash_map(std::size_t nb_elements) {
+  using key_tt = typename HMap::key_type;
+  using value_tt = typename HMap::mapped_type;
+
+  HMap map;
+  map.reserve(nb_elements);
+
+  for (std::size_t i = 0; i < nb_elements; i++) {
+    map.insert({utils::get_key<key_tt>(i), utils::get_value<value_tt>(i)});
+  }
+
+  return map;
+}
+
+template <class T>
+struct is_pair : std::false_type {};
+
+template <class T1, class T2>
+struct is_pair<std::pair<T1, T2>> : std::true_type {};
+
+/**
+ * serializer helper to test serialize(...) and deserialize(...) functions
+ */
+class serializer {
+ public:
+  serializer() { m_ostream.exceptions(m_ostream.badbit | m_ostream.failbit); }
+
+  template <class T>
+  void operator()(const T& val) {
+    serialize_impl(val);
+  }
+
+  std::string str() const { return m_ostream.str(); }
+
+ private:
+  template <typename T, typename U>
+  void serialize_impl(const std::pair<T, U>& val) {
+    serialize_impl(val.first);
+    serialize_impl(val.second);
+  }
+
+  void serialize_impl(const std::string& val) {
+    serialize_impl(
+        tsl::detail_ordered_hash::numeric_cast<std::uint64_t>(val.size()));
+    m_ostream.write(val.data(), val.size());
+  }
+
+  void serialize_impl(const move_only_test& val) {
+    serialize_impl(val.value());
+  }
+
+  template <class T, typename std::enable_if<
+                         std::is_arithmetic<T>::value>::type* = nullptr>
+  void serialize_impl(const T& val) {
+    m_ostream.write(reinterpret_cast<const char*>(&val), sizeof(val));
+  }
+
+ private:
+  std::stringstream m_ostream;
+};
+
+class deserializer {
+ public:
+  explicit deserializer(const std::string& init_str = "")
+      : m_istream(init_str) {
+    m_istream.exceptions(m_istream.badbit | m_istream.failbit |
+                         m_istream.eofbit);
+  }
+
+  template <class T>
+  T operator()() {
+    return deserialize_impl<T>();
+  }
+
+ private:
+  template <class T,
+            typename std::enable_if<is_pair<T>::value>::type* = nullptr>
+  T deserialize_impl() {
+    auto first = deserialize_impl<typename T::first_type>();
+    return std::make_pair(std::move(first),
+                          deserialize_impl<typename T::second_type>());
+  }
+
+  template <class T, typename std::enable_if<
+                         std::is_same<std::string, T>::value>::type* = nullptr>
+  T deserialize_impl() {
+    const std::size_t str_size =
+        tsl::detail_ordered_hash::numeric_cast<std::size_t>(
+            deserialize_impl<std::uint64_t>());
+
+    // TODO std::string::data() return a const pointer pre-C++17. Avoid the
+    // inefficient double allocation.
+    std::vector<char> chars(str_size);
+    m_istream.read(chars.data(), str_size);
+
+    return std::string(chars.data(), chars.size());
+  }
+
+  template <class T, typename std::enable_if<std::is_same<
+                         move_only_test, T>::value>::type* = nullptr>
+  move_only_test deserialize_impl() {
+    return move_only_test(deserialize_impl<std::int64_t>());
+  }
+
+  template <class T, typename std::enable_if<
+                         std::is_arithmetic<T>::value>::type* = nullptr>
+  T deserialize_impl() {
+    T val;
+    m_istream.read(reinterpret_cast<char*>(&val), sizeof(val));
+
+    return val;
+  }
+
+ private:
+  std::stringstream m_istream;
+};
+
+#endif
diff -u -r -N lightspark-0.9.0/src/3rdparty/ordered-map/tsl-ordered-map.natvis lightspark-master/src/3rdparty/ordered-map/tsl-ordered-map.natvis
--- lightspark-0.9.0/src/3rdparty/ordered-map/tsl-ordered-map.natvis	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/3rdparty/ordered-map/tsl-ordered-map.natvis	2025-03-05 20:13:02.117864025 +0100
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="utf-8"?>
+<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">
+    <!-- Written in VC 2017 15.7 but is expected to be compatible with VC 2015 -->
+
+    <Type Name="tsl::ordered_map&lt;*&gt;">
+        <AlternativeType Name="tsl::ordered_set&lt;*&gt;"/>
+        <DisplayString>{m_ht.m_values}</DisplayString>
+        <Expand>
+            <Item Name="[bucket_count]" IncludeView="detailed">m_ht.m_buckets_data._Mypair._Myval2._Mylast - m_ht.m_buckets_data._Mypair._Myval2._Myfirst</Item>
+            <Item Name="[max_load_factor]" IncludeView="detailed">m_ht.m_max_load_factor</Item>
+            <ExpandedItem>m_ht.m_values</ExpandedItem>
+        </Expand>
+    </Type>
+
+    <Type Name="tsl::detail_ordered_hash::ordered_hash&lt;*&gt;::ordered_iterator&lt;*&gt;">
+        <DisplayString>{m_iterator}</DisplayString>
+        <Expand>
+            <ExpandedItem>m_iterator</ExpandedItem>
+        </Expand>
+    </Type>
+</AutoVisualizer>
diff -u -r -N lightspark-0.9.0/src/allclasses.h lightspark-master/src/allclasses.h
--- lightspark-0.9.0/src/allclasses.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/allclasses.h	2025-03-05 20:13:02.129864319 +0100
@@ -477,3 +477,5 @@
 REGISTER_CLASS_NAME_AVM1(AVM1Array,"Array","")
 REGISTER_CLASS_NAME_AVM1(AVM1Date,"Date","")
 REGISTER_CLASS_NAME_AVM1(AVM1BitmapFilter,"BitmapFilter","flash.filters")
+REGISTER_CLASS_NAME_AVM1(AVM1Selection,"Selection","")
+
diff -u -r -N lightspark-0.9.0/src/asobject.cpp lightspark-master/src/asobject.cpp
--- lightspark-0.9.0/src/asobject.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/asobject.cpp	2025-03-05 20:13:02.130864344 +0100
@@ -40,6 +40,7 @@
 #include "scripting/flash/net/flashnet.h"
 #include "scripting/flash/display/DisplayObject.h"
 #include "scripting/flash/display/RootMovieClip.h"
+#include "scripting/flash/display/Stage.h"
 #include "scripting/flash/utils/Dictionary.h"
 #include "scripting/toplevel/Undefined.h"
 #include "scripting/toplevel/Null.h"
@@ -195,7 +196,9 @@
 	executeASMethod(str,"toLocaleString", {""}, nullptr, 0);
 	if (asAtomHandler::isInvalid(str))
 		return "";
-	return asAtomHandler::toString(str,getInstanceWorker());
+	tiny_string ret = asAtomHandler::toString(str,getInstanceWorker());
+	ASATOM_DECREF(str);
+	return ret;
 }
 
 TRISTATE ASObject::isLess(ASObject* r)
@@ -232,6 +235,8 @@
 		else
 			return cur_index+1;
 	}
+	if (getClass() == nullptr || getClass()->prototype.isNull())
+		return 0;
 	if (getClass()->prototype->getObj() != this)
 	{
 		uint32_t res = getClass()->prototype->getObj()->nextNameIndex(cur_index-Variables.dynamic_vars.size());
@@ -552,6 +557,67 @@
 	return true;
 }
 
+asAtom ASObject::callResolveMethod(const tiny_string& name, ASWorker* wrk)
+{
+	auto pr = getprop_prototype();
+	asAtom ret = asAtomHandler::invalidAtom;
+
+	multiname m(nullptr);
+	m.name_type = multiname::NAME_STRING;
+	m.name_s_id = sys->getUniqueStringId("__resolve", wrk->AVM1isCaseSensitive());
+	m.isAttribute = false;
+
+	for (uint8_t depth = 0; pr != nullptr; pr = pr->getprop_prototype(), ++depth)
+	{
+		if (depth == UINT8_MAX)
+		{
+			throw ScriptLimitException
+			(
+				"Reached maximum prototype recursion limit",
+				ScriptLimitException::MaxPrototypeRecursion
+			);
+		}
+
+		auto func = asAtomHandler::invalidAtom;
+
+		GET_VARIABLE_RESULT varres = pr->AVM1getVariableByMultiname
+		(
+			func,
+			m,
+			GET_VARIABLE_OPTION
+			(
+				GET_VARIABLE_OPTION::DONT_CALL_GETTER |
+				GET_VARIABLE_OPTION::DONT_CHECK_PROTOTYPE
+			),
+			wrk,
+			false
+		);
+
+		if (asAtomHandler::isInvalid(func))
+			continue;
+
+		auto thisObj = asAtomHandler::fromObject(this);
+		auto strAtom = asAtomHandler::fromString(sys, name);
+		asAtomHandler::callFunction
+		(
+			func,
+			wrk,
+			ret,
+			thisObj,
+			&strAtom,
+			1,
+			false,
+			true,
+			true,
+			varres & GETVAR_ISGETTER
+		);
+		ASATOM_DECREF(func);
+		break;
+	}
+
+	return ret;
+}
+
 bool ASObject::has_valueOf()
 {
 	multiname valueOfName(nullptr);
@@ -801,6 +867,9 @@
 	if(isBorrowed && o->as<IFunction>()->inClass == nullptr)
 		o->as<IFunction>()->inClass = this->as<Class_base>();
 	o->as<IFunction>()->isStatic = !isBorrowed;
+	o->as<IFunction>()->isGetter = type==METHOD_TYPE::GETTER_METHOD;
+	o->as<IFunction>()->isSetter = type==METHOD_TYPE::SETTER_METHOD;
+	o->as<IFunction>()->namespaceNameID=ns.kind == NAMESPACE  ? ns.nsNameId : (uint32_t)BUILTIN_STRINGS::EMPTY;
 
 	variable* obj=nullptr;
 	if(isBorrowed)
@@ -1109,7 +1178,7 @@
 
 		asAtom v =asAtomHandler::fromObject(target);
 		asAtom ret=asAtomHandler::invalidAtom;
-		asAtomHandler::callFunction(obj->setter,wrk,ret,v,arg1,1,false);
+		asAtomHandler::callFunction(obj->setter,wrk,ret,v,arg1,1,false,true,true,true);
 		if (asAtomHandler::is<SyntheticFunction>(obj->setter))
 			retval = asAtomHandler::as<SyntheticFunction>(obj->setter)->getSimpleName();
 		ASATOM_DECREF(ret);
@@ -1934,32 +2003,122 @@
 	getInstanceWorker()->registerConstantRef(this);
 	setConstant();
 }
-GET_VARIABLE_RESULT ASObject::AVM1getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt,ASWorker* wrk)
+
+std::pair<asAtom, uint8_t> ASObject::AVM1searchPrototypeByMultiname
+(
+	const multiname& name,
+	bool isSlashPath,
+	ASWorker* wrk
+)
+{
+	ASObject* pr;
+	if (is<Class_base>())
+	{
+		auto _class = as<Class_base>();
+		auto proto = _class->getPrototype(wrk);
+		pr = proto != nullptr ? proto->getObj() : getprop_prototype();
+	}
+	else
+		pr = getprop_prototype();
+
+	asAtom ret = asAtomHandler::invalidAtom;
+	for (uint8_t depth = 0; pr != nullptr; pr = pr->getprop_prototype(), ++depth)
+	{
+		if (depth == UINT8_MAX)
+		{
+			throw ScriptLimitException
+			(
+				"Reached maximum prototype recursion limit",
+				ScriptLimitException::MaxPrototypeRecursion
+			);
+		}
+
+		bool isGetter = pr->AVM1getVariableByMultiname
+		(
+			ret,
+			name,
+			GET_VARIABLE_OPTION
+			(
+				GET_VARIABLE_OPTION::DONT_CALL_GETTER |
+				GET_VARIABLE_OPTION::DONT_CHECK_PROTOTYPE
+			),
+			wrk,
+			isSlashPath
+		) & GET_VARIABLE_RESULT::GETVAR_ISGETTER;
+
+		if (isGetter)
+		{
+			IFunction* f = asAtomHandler::as<IFunction>(ret);
+			auto thisObj = asAtomHandler::fromObject(this);
+			ret = asAtomHandler::invalidAtom;
+			f->callGetter(ret, thisObj, wrk);
+			return std::make_pair(ret, depth);
+		}
+		else if (asAtomHandler::isValid(ret))
+			return std::make_pair(ret, depth);
+	}
+
+	return std::make_pair(callResolveMethod(name.normalizedName(wrk), wrk), 0);
+}
+
+GET_VARIABLE_RESULT ASObject::AVM1getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt, ASWorker* wrk, bool isSlashPath)
 {
 	GET_VARIABLE_RESULT res = getVariableByMultiname(ret,name,opt,wrk);
-	if (asAtomHandler::isInvalid(ret))
+	if (asAtomHandler::isInvalid(ret) && !(opt & DONT_CHECK_PROTOTYPE))
+	{
+		auto pair = AVM1searchPrototypeByMultiname(name, isSlashPath, wrk);
+		ret = pair.first;
+	}
+	return res;
+}
+
+bool ASObject::AVM1setLocalByMultiname(multiname& name, asAtom& value, CONST_ALLOWED_FLAG allowConst, ASWorker* wrk)
+{
+	bool alreadySet = false;
+	setVariableByMultiname(name, value, allowConst, &alreadySet, wrk);
+	return alreadySet;
+}
+
+bool ASObject::AVM1setVariableByMultiname(multiname& name, asAtom& value, CONST_ALLOWED_FLAG allowConst, ASWorker* wrk)
+{
+	auto s = name.normalizedName(wrk);
+
+	if (s.empty())
+		return false;
+
+	// TODO: Support watchers.
+
+	if (!hasPropertyByMultiname(name, true, false, wrk))
 	{
-		ASObject* pr = getprop_prototype();
-		size_t depth = 0;
-		while (pr)
+		// We have to check the prototype chain for virtual setters,
+		// before inserting a new property.
+		for (auto pr = getprop_prototype(); pr != nullptr; pr = pr->getprop_prototype())
 		{
-			if (depth >= 255)
-			{
-				throw ScriptLimitException
-				(
-					"Reached maximum prototype recursion limit",
+			bool hasVirtual = false;
+			auto var = findSettable(name, &hasVirtual);
+			if (var == nullptr || !hasVirtual)
+				continue;
 
-					ScriptLimitException::MaxPrototypeRecursion
-				);
-			}
-			res = pr->getVariableByMultiname(ret,name,opt,wrk);
-			if (asAtomHandler::isValid(ret))
-				break;
-			pr = pr->getprop_prototype();
-			depth++;
+			if (asAtomHandler::isInvalid(var->setter))
+				continue;
+
+			auto thisObj = asAtomHandler::fromObject(this);
+			auto res = asAtomHandler::invalidAtom;
+			asAtomHandler::callFunction
+			(
+				var->setter,
+				wrk,
+				res,
+				thisObj,
+				&value,
+				1,
+				false
+			);
+			return false;
 		}
 	}
-	return res;
+
+	return AVM1setLocalByMultiname(name, value, allowConst, wrk);
 }
 
 void variables_map::check() const
@@ -2385,6 +2544,8 @@
 				if (!(*it)->gccounter.ignore && (*it)->isMarkedForGarbageCollection() && !deletedingarbagecollection)
 				{
 					getInstanceWorker()->addObjectToGarbageCollector(this);
+					gcstate.reset();
+					return false;
 				}
 				break;
 			}
@@ -2462,16 +2623,19 @@
 	{
 		if (!this->gccounter.ischecked)
 		{
-			gcstate.incCount(this,false);
 			if (this->gccounter.isAncestor)
+			{
+				ret = gcstate.incCount(this,false);
 				return this->gccounter.hasmember;
+			}
 			ret = countCylicMemberReferences(gcstate);
+			gcstate.incCount(this,false);
 			if (ret)
 				this->gccounter.hasmember=true;
 			else
 				ret=this->gccounter.hasmember;
 		}
-		else
+		else if (!this->gccounter.isAncestor)
 			ret = gcstate.incCount(this,false);
 	}
 	else
@@ -2486,7 +2650,6 @@
 {
 	return destructIntern();
 }
-
 bool ASObject::AVM1HandleKeyboardEvent(KeyboardEvent *e)
 {
 	if (e->type =="keyDown")
@@ -2529,34 +2692,40 @@
 	ASWorker* wrk = getInstanceWorker();
 	if (e->type == "mouseMove")
 	{
-		m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEMOVE;
-		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-		if (asAtomHandler::is<AVM1Function>(func))
-			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
-		ASATOM_DECREF(func);
+		if (!this->is<DisplayObject>() || this->is<MovieClip>())
+		{
+			m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEMOVE;
+			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
+			if (asAtomHandler::is<AVM1Function>(func))
+				asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
+			ASATOM_DECREF(func);
+		}
 	}
 	else if (e->type == "mouseDown")
 	{
-		if (dispobj && ((dispobj == this && !dispobj->is<DisplayObject>())
-				|| (dispobj->as<DisplayObject>()->isVisible() && this->is<DisplayObject>() && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
+		if (!this->is<DisplayObject>() || this->is<MovieClip>())
 		{
-			m.name_s_id=BUILTIN_STRINGS::STRING_ONPRESS;
+			func=asAtomHandler::invalidAtom;
+			m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEDOWN;
 			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
 			if (asAtomHandler::is<AVM1Function>(func))
 				asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
 			ASATOM_DECREF(func);
 		}
-		func=asAtomHandler::invalidAtom;
-		m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEDOWN;
-		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-		if (asAtomHandler::is<AVM1Function>(func))
-			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
-		ASATOM_DECREF(func);
 	}
 	else if (e->type == "mouseUp")
 	{
+		if (!this->is<DisplayObject>() || this->is<MovieClip>())
+		{
+			func=asAtomHandler::invalidAtom;
+			m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEUP;
+			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
+			if (asAtomHandler::is<AVM1Function>(func))
+				asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
+			ASATOM_DECREF(func);
+		}
 		if (dispobj && ((dispobj == this && !dispobj->is<DisplayObject>())
-				|| (dispobj->as<DisplayObject>()->isVisible() && this->is<DisplayObject>() && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
+				|| (dispobj->as<DisplayObject>()->isVisible() && (this->is<MovieClip>() || this->is<SimpleButton>())  && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
 		{
 			m.name_s_id=BUILTIN_STRINGS::STRING_ONRELEASE;
 			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
@@ -2564,12 +2733,6 @@
 				asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
 			ASATOM_DECREF(func);
 		}
-		func=asAtomHandler::invalidAtom;
-		m.name_s_id=BUILTIN_STRINGS::STRING_ONMOUSEUP;
-		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-		if (asAtomHandler::is<AVM1Function>(func))
-			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
-		ASATOM_DECREF(func);
 	}
 	else if (e->type == "mouseWheel")
 	{
@@ -2581,16 +2744,18 @@
 	}
 	else if (e->type == "releaseOutside")
 	{
-		m.name_s_id=BUILTIN_STRINGS::STRING_ONRELEASEOUTSIDE;
-		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-		if (asAtomHandler::is<AVM1Function>(func))
-			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
-		ASATOM_DECREF(func);
+		if (!this->is<DisplayObject>() || this->is<MovieClip>())
+		{
+			m.name_s_id=BUILTIN_STRINGS::STRING_ONRELEASEOUTSIDE;
+			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
+			if (asAtomHandler::is<AVM1Function>(func))
+				asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
+			ASATOM_DECREF(func);
+		}
 	}
 	else if (e->type == "rollOver")
 	{
-		if (dispobj && ((dispobj == this && !dispobj->is<DisplayObject>())
-				|| (dispobj->as<DisplayObject>()->isVisible() && this->is<DisplayObject>() && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
+		if (!this->is<DisplayObject>() || this->is<MovieClip>() || this->is<SimpleButton>())
 		{
 			m.name_s_id=BUILTIN_STRINGS::STRING_ONROLLOVER;
 			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
@@ -2601,8 +2766,7 @@
 	}
 	else if (e->type == "rollOut")
 	{
-		if (dispobj && ((dispobj == this && !dispobj->is<DisplayObject>())
-				|| (dispobj->as<DisplayObject>()->isVisible() && this->is<DisplayObject>() && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
+		if (dispobj == this && (!this->is<DisplayObject>() || this->is<MovieClip>() || this->is<SimpleButton>()))
 		{
 			m.name_s_id=BUILTIN_STRINGS::STRING_ONROLLOUT;
 			AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
@@ -2619,7 +2783,52 @@
 		LOG(LOG_NOT_IMPLEMENTED,"handling avm1 mouse event "<<e->type);
 	return false;
 }
+void ASObject::AVM1HandleSetFocusEvent(ASObject *dispobj)
+{
+	_NR<InteractiveObject> oldfocus = getSystemState()->stage->getFocusTarget();
+	if (dispobj && oldfocus.getPtr()==dispobj)
+		return;
+	if ((dispobj && dispobj->is<TextField>())
+		|| (oldfocus && oldfocus->is<TextField>()))
+	{
+		asAtom func=asAtomHandler::invalidAtom;
+		multiname m(nullptr);
+		m.name_type=multiname::NAME_STRING;
+		m.isAttribute = false;
+		asAtom ret=asAtomHandler::invalidAtom;
+		asAtom obj = asAtomHandler::fromObject(this);
+		ASWorker* wrk = getInstanceWorker();
+		asAtom args[2];
+		args[0] = !oldfocus || oldfocus==getSystemState()->stage || oldfocus->is<RootMovieClip>() ? asAtomHandler::nullAtom : asAtomHandler::fromObject(oldfocus.getPtr());
+		args[1] = !dispobj || dispobj==getSystemState()->stage || dispobj->is<RootMovieClip>() || !dispobj->is<TextField>() ? asAtomHandler::nullAtom : asAtomHandler::fromObject(dispobj);
+		m.name_s_id=BUILTIN_STRINGS::STRING_ONSETFOCUS;
+		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
+		if (asAtomHandler::is<AVM1Function>(func))
+			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,args,2);
+		ASATOM_DECREF(func);
+		ASATOM_DECREF(ret)
+	}
+}
 
+void ASObject::AVM1HandlePressedEvent(ASObject *dispobj)
+{
+	multiname m(nullptr);
+	m.name_type=multiname::NAME_STRING;
+	m.isAttribute = false;
+	asAtom ret=asAtomHandler::invalidAtom;
+	asAtom obj = asAtomHandler::fromObject(this);
+	ASWorker* wrk = getInstanceWorker();
+	if (dispobj && ((dispobj == this && !dispobj->is<DisplayObject>())
+					|| (dispobj->as<DisplayObject>()->isVisible() && (this->is<MovieClip>() || this->is<SimpleButton>()) && dispobj->as<DisplayObject>()->findParent(this->as<DisplayObject>()))))
+	{
+		m.name_s_id=BUILTIN_STRINGS::STRING_ONPRESS;
+		asAtom func=asAtomHandler::invalidAtom;
+		AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
+		if (asAtomHandler::is<AVM1Function>(func))
+			asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,nullptr,0);
+		ASATOM_DECREF(func);
+	}
+}
 void ASObject::AVM1UpdateAllBindings(DisplayObject* target, ASWorker* wrk)
 {
 	auto it = Variables.Variables.begin();
@@ -2662,7 +2871,11 @@
 			{
 				ASATOM_INCREF(v);
 			}
-			target->setVariableByMultiname(m,v,CONST_ALLOWED,nullptr,wrk);
+
+			if (needsactionscript3)
+				target->setVariableByMultiname(m,v,CONST_ALLOWED,nullptr,wrk);
+			else
+				(void)target->AVM1setVariableByMultiname(m, v, CONST_ALLOWED, wrk);
 		}
 		it++;
 	}
@@ -3323,7 +3536,7 @@
 	return a;
 }
 
-void asAtomHandler::callFunction(asAtom& caller,ASWorker* wrk,asAtom& ret,asAtom &obj, asAtom *args, uint32_t num_args, bool args_refcounted, bool coerceresult, bool coercearguments)
+void asAtomHandler::callFunction(asAtom& caller,ASWorker* wrk,asAtom& ret,asAtom &obj, asAtom *args, uint32_t num_args, bool args_refcounted, bool coerceresult, bool coercearguments, bool isAVM1InternalCall)
 {
 	if (USUALLY_FALSE(!asAtomHandler::isFunction(caller)))
 	{
@@ -3354,7 +3567,7 @@
 	{
 		// The caller is just the previous callee.
 		auto argCaller = wrk->AVM1getCallee();
-		getObjectNoCheck(caller)->as<AVM1Function>()->call(&ret,&c, args, num_args, argCaller);
+		getObjectNoCheck(caller)->as<AVM1Function>()->call(&ret,&c, args, num_args, argCaller,isAVM1InternalCall);
 	}
 	else
 	{
@@ -3962,12 +4175,14 @@
 	assert(getObject(ret) != nullptr);
 
 	auto obj = getObjectNoCheck(ret);
+	bool called=false;
 
 	// NOTE: `toString()` is never called, when using a number hint.
 	if (hint != NUMBER_HINT && (swfVersion > 5 && obj->is<Date>()))
 	{
 		// NOTE: In SWF 6, and later, `Date` objects call `toString()`.
 		obj->call_toString(ret);
+		called=true;
 	}
 	// NOTE: `valueOf()` is never called on `DisplayObject`s, when using
 	// a number hint.
@@ -3975,6 +4190,7 @@
 	{
 		// Most objects call `valueOf()`.
 		obj->call_valueOf(ret);
+		called=true;
 	}
 
 	if (isPrimitive(ret))
@@ -3982,6 +4198,8 @@
 		isRefCounted = true;
 		return true;
 	}
+	if (called)
+		ASATOM_DECREF(ret);
 
 	// If the above conversion returns an object, then the conversion
 	// failed, so fall back to the original object.
@@ -4141,8 +4359,13 @@
 	}
 	else
 	{
-		ASObject* val1 = toObject(a,wrk);
-		ASObject* val2 = toObject(v2,wrk);
+		bool ret = true;
+		bool isObject_a = asAtomHandler::isObject(a);
+		bool isObject_v2 = asAtomHandler::isObject(v2);
+		asAtom atmp = a;
+		asAtom v2tmp = v2;
+		ASObject* val1 = toObject(atmp,wrk);
+		ASObject* val2 = toObject(v2tmp,wrk);
 		if( (val1->is<XML>() || val1->is<XMLList>()) && (val2->is<XML>() || val2->is<XMLList>()) )
 		{
 			//Check if the objects are both XML or XMLLists
@@ -4209,9 +4432,15 @@
 				if (forceint)
 					setInt(a,wrk,result);
 				else
-					return replaceNumber(a,wrk,result);
+					ret = replaceNumber(a,wrk,result);
 			}
 		}
+		// cleanup new objects created in toObject() calls
+		if (!isObject_a)
+			ASATOM_DECREF(atmp);
+		if (!isObject_v2)
+			ASATOM_DECREF(v2tmp);
+		return ret;
 	}
 	return true;
 }
@@ -4264,8 +4493,10 @@
 	}
 	else
 	{
-		ASObject* val1 = toObject(v1,wrk);
-		ASObject* val2 = toObject(v2,wrk);
+		asAtom v1tmp = v1;
+		asAtom v2tmp = v2;
+		ASObject* val1 = toObject(v1tmp,wrk);
+		ASObject* val2 = toObject(v2tmp,wrk);
 		if( (val1->is<XML>() || val1->is<XMLList>()) && (val2->is<XML>() || val2->is<XMLList>()) )
 		{
 			//Check if the objects are both XML or XMLLists
@@ -4340,6 +4571,11 @@
 					o->decRef();
 			}
 		}
+		// cleanup new objects created in toObject() calls
+		if (!asAtomHandler::isObject(v1))
+			ASATOM_DECREF(v1tmp);
+		if (!asAtomHandler::isObject(v2))
+			ASATOM_DECREF(v2tmp);
 	}
 }
 
diff -u -r -N lightspark-0.9.0/src/asobject.h lightspark-master/src/asobject.h
--- lightspark-0.9.0/src/asobject.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/asobject.h	2025-03-05 20:13:02.130864344 +0100
@@ -460,7 +460,7 @@
 	 * Return the asAtom the function returned.
 	 * if coerceresult is false, the result of the function will not be coerced into the type provided by the method_info
 	 */
-	static void callFunction(asAtom& caller, ASWorker* wrk, asAtom& ret, asAtom &obj, asAtom *args, uint32_t num_args, bool args_refcounted, bool coerceresult=true, bool coercearguments=true);
+	static void callFunction(asAtom& caller, ASWorker* wrk, asAtom& ret, asAtom &obj, asAtom *args, uint32_t num_args, bool args_refcounted, bool coerceresult=true, bool coercearguments=true, bool isAVM1InternalCall=false);
 	static multiname* getVariableByMultiname(asAtom& a, asAtom &ret, const multiname& name, ASWorker* wrk, bool& canCache, GET_VARIABLE_OPTION opt);
 	static void getVariableByInteger(asAtom& a, asAtom &ret, int index, ASWorker* wrk);
 	static bool hasPropertyByMultiname(const asAtom& a, const multiname& name, bool considerDynamic, bool considerPrototype, ASWorker* wrk);
@@ -892,7 +892,7 @@
 	Class_base* getSlotType(unsigned int n, lightspark::ABCContext* context);
 
 	uint32_t findInstanceSlotByMultiname(multiname* name, ASWorker* wrk);
-	FORCE_INLINE bool setSlot(ASWorker* wrk, unsigned int n, asAtom &o);
+	FORCE_INLINE TRISTATE setSlot(ASWorker* wrk, unsigned int n, asAtom &o);
 	/*
 	 * This version of the call is guarantee to require no type conversion
 	 * this is verified at optimization time
@@ -1169,8 +1169,20 @@
 	{
 		return getVariableByIntegerIntern(ret,index,opt,wrk);
 	}
+
+	enum CONST_ALLOWED_FLAG { CONST_ALLOWED=0, CONST_NOT_ALLOWED };
+
+	std::pair<asAtom, uint8_t> AVM1searchPrototypeByMultiname
+	(
+		const multiname& name,
+		bool isSlashPath,
+		ASWorker* wrk
+	);
 	// AVM1 needs to check the "protoype" variable in addition to the normal behaviour
-	GET_VARIABLE_RESULT AVM1getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt, ASWorker* wrk);
+	virtual GET_VARIABLE_RESULT AVM1getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt, ASWorker* wrk, bool isSlashPath = true);
+	virtual bool AVM1setLocalByMultiname(multiname& name, asAtom& value, CONST_ALLOWED_FLAG allowConst, ASWorker* wrk);
+	bool AVM1setVariableByMultiname(multiname& name, asAtom& value, CONST_ALLOWED_FLAG allowConst, ASWorker* wrk);
+
 	/*
 	 * Helper method using the get the raw variable struct instead of calling the getter.
 	 * It is used by getVariableByMultiname and by early binding code
@@ -1200,7 +1212,6 @@
 	 */
 	void executeASMethod(asAtom &ret, const tiny_string& methodName, std::list<tiny_string> namespaces, asAtom *args, uint32_t num_args);
 	virtual void setVariableByMultiname_i(multiname &name, int32_t value, ASWorker* wrk);
-	enum CONST_ALLOWED_FLAG { CONST_ALLOWED=0, CONST_NOT_ALLOWED };
 	/*
 	 * If alreadyset is not null, it has to be initialized to false by the caller.
 	 * It will be set to true if the old and new value are the same.
@@ -1276,7 +1287,11 @@
 	{
 		return Variables.getSlotKind(n);
 	}
-	FORCE_INLINE bool setSlot(ASWorker* wrk,unsigned int n,asAtom o)
+	// return value:
+	// TTRUE: slot is updated, no new object created
+	// TFALSE: slot is updated, new object was created through coercion
+	// TUNDEFINED: slot was already set to new value, no changes necessary
+	FORCE_INLINE TRISTATE setSlot(ASWorker* wrk,unsigned int n,asAtom o)
 	{
 		return Variables.setSlot(wrk,n,o);
 	}
@@ -1346,6 +1361,7 @@
 	bool isInitialized() const {return traitsInitialized;}
 	virtual bool isConstructed() const;
 
+	asAtom callResolveMethod(const tiny_string& name, ASWorker* wrk);
 	/* helper functions for calling the "valueOf" and
 	 * "toString" AS-functions which may be members of this
 	 *  object */
@@ -1449,6 +1465,8 @@
 	virtual bool AVM1HandleKeyboardEvent(KeyboardEvent* e);
 	virtual bool AVM1HandleMouseEvent(EventDispatcher* dispatcher,MouseEvent* e);
 	bool AVM1HandleMouseEventStandard(ASObject *dispobj, MouseEvent *e);
+	void AVM1HandleSetFocusEvent(ASObject *dispobj);
+	virtual void AVM1HandlePressedEvent(ASObject *dispobj);
 	// updates AVM1 bindings in target for all members of this ASObject
 	void AVM1UpdateAllBindings(DisplayObject* target, ASWorker* wrk);
 
@@ -1459,15 +1477,15 @@
 };
 
 
-FORCE_INLINE bool variables_map::setSlot(ASWorker* wrk,unsigned int n, asAtom &o)
+FORCE_INLINE TRISTATE variables_map::setSlot(ASWorker* wrk,unsigned int n, asAtom &o)
 {
 	assert_and_throw(n < slotcount);
 	if (slots_vars[n]->var.uintval != o.uintval)
 	{
 		slots_vars[n]->setVar(wrk,o);
-		return slots_vars[n]->var.uintval == o.uintval; // setVar may coerce the object into a new instance, so we need to check if incRef is necessary
+		return slots_vars[n]->var.uintval == o.uintval ? TTRUE : TFALSE; // setVar may coerce the object into a new instance, so we need to check if incRef is necessary
 	}
-	return false;
+	return TUNDEFINED;
 }
 
 FORCE_INLINE void variables_map::setSlotNoCoerce(unsigned int n, asAtom o)
@@ -1554,6 +1572,7 @@
 class FileMode;
 class FileReference;
 class FileStream;
+class FocusEvent;
 class Function;
 class Function_object;
 class FontDescription;
@@ -1608,6 +1627,7 @@
 class SoundChannel;
 class SpaceJustifier;
 class Sprite;
+class StackOverflowError;
 class Stage;
 class Stage3D;
 class SyntaxError;
@@ -1652,7 +1672,7 @@
 template<> inline bool ASObject::is<ArgumentError>() const { return subtype==SUBTYPE_ARGUMENTERROR; }
 template<> inline bool ASObject::is<Array>() const { return type==T_ARRAY; }
 template<> inline bool ASObject::is<ASCondition>() const { return subtype==SUBTYPE_CONDITION; }
-template<> inline bool ASObject::is<ASError>() const { return subtype==SUBTYPE_ERROR || subtype==SUBTYPE_SECURITYERROR || subtype==SUBTYPE_ARGUMENTERROR || subtype==SUBTYPE_DEFINITIONERROR || subtype==SUBTYPE_EVALERROR || subtype==SUBTYPE_RANGEERROR || subtype==SUBTYPE_REFERENCEERROR || subtype==SUBTYPE_SYNTAXERROR || subtype==SUBTYPE_TYPEERROR || subtype==SUBTYPE_URIERROR || subtype==SUBTYPE_VERIFYERROR || subtype==SUBTYPE_UNINITIALIZEDERROR; }
+template<> inline bool ASObject::is<ASError>() const { return subtype==SUBTYPE_ERROR || subtype==SUBTYPE_SECURITYERROR || subtype==SUBTYPE_ARGUMENTERROR || subtype==SUBTYPE_DEFINITIONERROR || subtype==SUBTYPE_EVALERROR || subtype==SUBTYPE_RANGEERROR || subtype==SUBTYPE_REFERENCEERROR || subtype==SUBTYPE_SYNTAXERROR || subtype==SUBTYPE_TYPEERROR || subtype==SUBTYPE_URIERROR || subtype==SUBTYPE_VERIFYERROR || subtype==SUBTYPE_UNINITIALIZEDERROR || subtype==SUBTYPE_STACKOVERFLOWERROR; }
 template<> inline bool ASObject::is<ASFile>() const { return subtype==SUBTYPE_FILE; }
 template<> inline bool ASObject::is<ASMutex>() const { return subtype==SUBTYPE_MUTEX; }
 template<> inline bool ASObject::is<ASObject>() const { return true; }
@@ -1695,12 +1715,13 @@
 template<> inline bool ASObject::is<EastAsianJustifier>() const { return subtype==SUBTYPE_EASTASIANJUSTIFIER; }
 template<> inline bool ASObject::is<ElementFormat>() const { return subtype==SUBTYPE_ELEMENTFORMAT; }
 template<> inline bool ASObject::is<EvalError>() const { return subtype==SUBTYPE_EVALERROR; }
-template<> inline bool ASObject::is<Event>() const { return subtype==SUBTYPE_EVENT || subtype==SUBTYPE_WAITABLE_EVENT || subtype==SUBTYPE_PROGRESSEVENT || subtype==SUBTYPE_KEYBOARD_EVENT || subtype==SUBTYPE_MOUSE_EVENT || subtype==SUBTYPE_SAMPLEDATA_EVENT || subtype == SUBTYPE_THROTTLE_EVENT || subtype == SUBTYPE_CONTEXTMENUEVENT || subtype == SUBTYPE_GAMEINPUTEVENT || subtype == SUBTYPE_NATIVEWINDOWBOUNDSEVENT; }
+template<> inline bool ASObject::is<Event>() const { return subtype==SUBTYPE_EVENT || subtype==SUBTYPE_WAITABLE_EVENT || subtype==SUBTYPE_PROGRESSEVENT || subtype==SUBTYPE_KEYBOARD_EVENT || subtype==SUBTYPE_MOUSE_EVENT || subtype==SUBTYPE_SAMPLEDATA_EVENT || subtype == SUBTYPE_THROTTLE_EVENT || subtype == SUBTYPE_CONTEXTMENUEVENT || subtype == SUBTYPE_GAMEINPUTEVENT || subtype == SUBTYPE_NATIVEWINDOWBOUNDSEVENT || subtype == SUBTYPE_FOCUSEVENT; }
 template<> inline bool ASObject::is<ExtensionContext>() const { return subtype==SUBTYPE_EXTENSIONCONTEXT; }
 template<> inline bool ASObject::is<FontDescription>() const { return subtype==SUBTYPE_FONTDESCRIPTION; }
 template<> inline bool ASObject::is<FileMode>() const { return subtype==SUBTYPE_FILEMODE; }
 template<> inline bool ASObject::is<FileReference>() const { return subtype==SUBTYPE_FILE||subtype==SUBTYPE_FILEREFERENCE; }
 template<> inline bool ASObject::is<FileStream>() const { return subtype==SUBTYPE_FILESTREAM; }
+template<> inline bool ASObject::is<FocusEvent>() const { return subtype==SUBTYPE_FOCUSEVENT; }
 template<> inline bool ASObject::is<Function_object>() const { return subtype==SUBTYPE_FUNCTIONOBJECT; }
 template<> inline bool ASObject::is<Function>() const { return subtype==SUBTYPE_FUNCTION; }
 template<> inline bool ASObject::is<GameInputDevice>() const { return subtype==SUBTYPE_GAMEINPUTDEVICE; }
@@ -1755,6 +1776,7 @@
 template<> inline bool ASObject::is<SoundTransform>() const { return subtype==SUBTYPE_SOUNDTRANSFORM; }
 template<> inline bool ASObject::is<SpaceJustifier>() const { return subtype==SUBTYPE_SPACEJUSTIFIER; }
 template<> inline bool ASObject::is<Sprite>() const { return subtype==SUBTYPE_SPRITE || subtype==SUBTYPE_ROOTMOVIECLIP || subtype == SUBTYPE_MOVIECLIP || subtype == SUBTYPE_AVM1MOVIECLIP; }
+template<> inline bool ASObject::is<StackOverflowError>() const { return subtype==SUBTYPE_STACKOVERFLOWERROR; }
 template<> inline bool ASObject::is<Stage>() const { return subtype==SUBTYPE_STAGE; }
 template<> inline bool ASObject::is<Stage3D>() const { return subtype==SUBTYPE_STAGE3D; }
 template<> inline bool ASObject::is<SyntaxError>() const { return subtype==SUBTYPE_SYNTAXERROR; }
@@ -2891,9 +2913,20 @@
 struct stacktrace_entry
 {
 	asAtom object;
-	uint32_t name;
-	void set(asAtom o, uint32_t n) { object=o; name=n; }
+	SyntheticFunction* function;
+	void set(asAtom o, SyntheticFunction*f) { object=o; function=f; }
 };
 
+struct stacktrace_string_entry
+{
+	uint32_t clsname;
+	uint32_t init;
+	uint32_t function;
+	uint32_t ns;
+	uint32_t methodnumber;
+	bool isGetter:1;
+	bool isSetter:1;
+};
+typedef std::vector<stacktrace_string_entry> StackTraceList;
 }
 #endif /* ASOBJECT_H */
diff -u -r -N lightspark-0.9.0/src/backends/decoder.cpp lightspark-master/src/backends/decoder.cpp
--- lightspark-0.9.0/src/backends/decoder.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/backends/decoder.cpp	2025-03-05 20:13:02.131864369 +0100
@@ -30,6 +30,7 @@
 #include "scripting/flash/media/flashmedia.h"
 #include "parsing/tags.h"
 
+#ifdef ENABLE_LIBAVCODEC
 #if LIBAVUTIL_VERSION_MAJOR < 51
 #define AVMEDIA_TYPE_VIDEO CODEC_TYPE_VIDEO
 #define AVMEDIA_TYPE_AUDIO CODEC_TYPE_AUDIO
@@ -42,6 +43,7 @@
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55,45,101)
 #define av_frame_unref avcodec_get_frame_defaults
 #endif
+#endif
 
 using namespace lightspark;
 using namespace std;
diff -u -r -N lightspark-0.9.0/src/backends/sdl/event_loop.cpp lightspark-master/src/backends/sdl/event_loop.cpp
--- lightspark-0.9.0/src/backends/sdl/event_loop.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/backends/sdl/event_loop.cpp	2025-03-05 20:13:02.133864417 +0100
@@ -214,7 +214,7 @@
 
 	auto getNewDeadline = [&]
 	{
-		return time->now() + sys->timeUntilNextTick().valueOr(TimeSpec());
+		return time->now() + sys->timeUntilNextFrame();
 	};
 
 	deadline = deadline.orElseIf(hasSys, [&]
@@ -238,7 +238,7 @@
 			{
 				auto delta = endTime.absDiff(startTime);
 				startTime = time->now();
-				sys->updateTimers(delta, true);
+				sys->runTick(delta);
 				deadline = getNewDeadline();
 			}
 		}
diff -u -r -N lightspark-0.9.0/src/caseless_string.h lightspark-master/src/caseless_string.h
--- lightspark-0.9.0/src/caseless_string.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/caseless_string.h	2025-03-05 20:13:02.134864442 +0100
@@ -0,0 +1,79 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2025  mr b0nk 500 (b0nk@b0nk.xyz)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef CASELESS_STRING_H
+#define CASELESS_STRING_H 1
+
+#include "tiny_string.h"
+
+namespace lightspark
+{
+
+class CaselessString
+{
+public:
+	CaselessString(const tiny_string& _str) : str(_str) {}
+
+	bool operator==(const tiny_string& other) const
+	{
+		return str.caselessEquals(other);
+	}
+
+	operator const tiny_string&() const { return str; }
+	const tiny_string& getStr() const { return str; }
+private:
+	tiny_string str;
+};
+
+FORCE_INLINE bool operator==(const tiny_string& str, const CaselessString& other)
+{
+	return str.caselessEquals(other);
+}
+
+struct CaselessHash
+{
+	using is_transparent = void;
+
+	size_t operator()(const tiny_string& str) const
+	{
+		return std::hash<tiny_string>{}(str.lowercase());
+	}
+
+	size_t operator()(const CaselessString& str) const
+	{
+		return std::hash<tiny_string>{}(str.getStr().lowercase());
+	}
+};
+
+}
+
+namespace std
+{
+
+template<>
+struct hash<lightspark::CaselessString>
+{
+	size_t operator()(const lightspark::CaselessString& str) const
+	{
+		return hash<lightspark::tiny_string>{}(str.getStr().lowercase());
+	}
+};
+
+}
+#endif /* CASELESS_STRING_H */
diff -u -r -N lightspark-0.9.0/src/CMakeLists.txt lightspark-master/src/CMakeLists.txt
--- lightspark-0.9.0/src/CMakeLists.txt	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/CMakeLists.txt	2025-03-05 20:13:02.129864319 +0100
@@ -279,6 +279,7 @@
   scripting/avm1/avm1array.cpp
   scripting/avm1/avm1date.cpp
   scripting/avm1/avm1filter.cpp
+  scripting/avm1/scope.cpp
   scripting/avm1_interpreter.cpp
   platforms/engineutils.cpp
   3rdparty/nanovg/src/nanovg.c
@@ -334,12 +335,16 @@
   3rdparty/imgui/imgui_tables.cpp
   3rdparty/imgui/imgui_widgets.cpp
   3rdparty/imgui/backends/imgui_impl_sdl2.cpp
-  3rdparty/imgui/backends/imgui_impl_opengl2.cpp
   3rdparty/tinyfiledialogs/tinyfiledialogs.c
   )
 SET(LIBNATIVEEXTENSION_SOURCES
   nativeextension/FREimpl.cpp
   )
+IF (ENABLE_GLES2)
+SET(LIBSPARK_SOURCES ${LIBSPARK_SOURCES} 3rdparty/imgui/backends/imgui_impl_opengl3.cpp)
+ELSE()
+SET(LIBSPARK_SOURCES ${LIBSPARK_SOURCES} 3rdparty/imgui/backends/imgui_impl_opengl2.cpp)
+ENDIF()
 
 IF(MINGW)
     SET(LIBSPARK_SOURCES ${LIBSPARK_SOURCES} platforms/slowpaths_generic.cpp)
@@ -415,6 +420,7 @@
 	PRIVATE ${PROJECT_SOURCE_DIR}/src/3rdparty/avmplus/pcre
 	PRIVATE ${PROJECT_SOURCE_DIR}/src/3rdparty/imgui
 	PRIVATE ${PROJECT_SOURCE_DIR}/src/3rdparty/imgui/backends
+	PUBLIC ${PROJECT_SOURCE_DIR}/src/3rdparty/ordered-map/include
 )
 
 TARGET_INCLUDE_DIRECTORIES(
@@ -452,9 +458,94 @@
 PACK_LIBRARY(spark $<TARGET_FILE:spark>)
 PACK_LIBRARY(nativeextension $<TARGET_FILE:nativeextension>)
 #We have to use LIBRARY on linux and RUNTIME on win32
-INSTALL(TARGETS spark RUNTIME DESTINATION ${PRIVATELIBDIR} LIBRARY DESTINATION ${PRIVATELIBDIR} ARCHIVE DESTINATION ${PRIVATELIBDIR})
+INSTALL(TARGETS spark RUNTIME_DEPENDENCY_SET spark_dependencies RUNTIME DESTINATION ${PRIVATELIBDIR} LIBRARY DESTINATION ${PRIVATELIBDIR} ARCHIVE DESTINATION ${PRIVATELIBDIR})
 INSTALL(TARGETS nativeextension RUNTIME DESTINATION ${PRIVATELIBDIR} LIBRARY DESTINATION ${PRIVATELIBDIR} ARCHIVE DESTINATION ${PRIVATELIBDIR})
 
+# taken from https://github.com/wxFormBuilder/wxFormBuilder/blob/master/src/CMakeLists.txt to add dlls of dependencies to nsis installer
+if(WIN32)
+  # The installation of runtime dependencies does not take the set paths into account and
+  # only searches in system default paths. Therefor paths of libraries not in such locations
+  # need to be specified manually. Depending on the used compiler these are different.
+  # TODO: Should both variables be used? What do the find_* commands do?
+  set(extraDirectories "")
+  set(prefixPaths "")
+  if(DEFINED ENV{CMAKE_PREFIX_PATH})
+    cmake_path(CONVERT "$ENV{CMAKE_PREFIX_PATH}" TO_CMAKE_PATH_LIST pathList NORMALIZE)
+    list(APPEND prefixPaths ${pathList})
+    unset(pathList)
+  endif()
+  if(DEFINED CMAKE_PREFIX_PATH)
+    cmake_path(CONVERT "${CMAKE_PREFIX_PATH}" TO_CMAKE_PATH_LIST pathList NORMALIZE)
+    list(APPEND prefixPaths ${pathList})
+    unset(pathList)
+  endif()
+  # TODO: To find the external libraries, the search path must be augmented for certain libraries
+  #       which don't use a standard prefix layout, a certain naming of their directories is assumed.
+  #       An alternative would be to install the IMPORTED_RUNTIME_ARTIFACTS of the libraries themself,
+  #       but this does not work easily currently because of its limitations
+  #       (does not work with UNKNOWN IMPORTED or ALIAS libraries).
+  foreach(entry IN LISTS prefixPaths)
+    cmake_path(GET entry PARENT_PATH libraryPath)
+    cmake_path(GET libraryPath FILENAME libraryName)
+    list(APPEND extraDirectories "${entry}/bin")
+  endforeach()
+  unset(prefixPaths)
+  unset(libraryPath)
+  unset(libraryName)
+  if(MSVC)
+    # The compiler runtime libraries are installed in system default paths, because it is expected
+    # that the runtime distributables are getting installed along the application, these need to get
+    # filtered.
+    install(RUNTIME_DEPENDENCY_SET spark_dependencies
+      DIRECTORIES
+        ${extraDirectories}
+      DESTINATION ${BINDIR}
+      PRE_EXCLUDE_REGEXES
+        [[api-ms-win-.*]]
+        [[ext-ms-.*]]
+        [[kernel32\.dll]]
+        [[msvcp.*\.dll]]
+        [[vcruntime.*\.dll]]
+      POST_EXCLUDE_REGEXES
+        # For some reason some dependencies use forward slashes, some backward slashes
+        [[.*[/\]system32/.*\.dll]]
+    )
+  elseif(MINGW)
+    # This environment has its own search paths which are not taken into account and must be specified.
+    if(MSYS)
+      # The "virtual" paths used by the MSYS environment cannot be used, they must be translated into physical
+      # paths of the system.
+      find_program(cygpath_cmd NAMES cygpath REQUIRED)
+      mark_as_advanced(cygpath_cmd)
+      # The mixed mode output equals the CMake path format
+      execute_process(COMMAND "${cygpath_cmd}" -m "$ENV{MSYSTEM_PREFIX}/bin" OUTPUT_VARIABLE msysSystemDir OUTPUT_STRIP_TRAILING_WHITESPACE)
+      list(APPEND extraDirectories "${msysSystemDir}")
+      unset(msysSystemDir)
+    else()
+      # In plain MinGW environments it is more difficult to determine the paths in a system independent manner.
+      # As best effort search the path of the compiler and hope that contains all system libraries.
+      find_path(compilerSystemDir NAMES gcc.exe REQUIRED)
+      mark_as_advanced(compilerSystemDir)
+      list(APPEND extraDirectories "${compilerSystemDir}")
+    endif()
+    install(RUNTIME_DEPENDENCY_SET spark_dependencies
+      DIRECTORIES
+        ${extraDirectories}
+      DESTINATION ${BINDIR}
+      PRE_EXCLUDE_REGEXES
+        [[api-ms-win-.*]]
+        [[ext-ms-.*]]
+        [[kernel32\.dll]]
+        [[user32\.dll]]
+        [[msvcrt.*\.dll]]
+      POST_EXCLUDE_REGEXES
+        # For some reason some dependencies use forward slashes, some backward slashes
+        [[.*[/\]system32/.*\.dll]]
+    )
+  endif()
+  unset(extraDirectories)
+endif()
+
 # lightspark executable target
 IF(COMPILE_LIGHTSPARK)
   ADD_EXECUTABLE(lightspark main.cpp)
diff -u -r -N lightspark-0.9.0/src/launcher.cpp lightspark-master/src/launcher.cpp
--- lightspark-0.9.0/src/launcher.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/launcher.cpp	2025-03-05 20:13:02.142864638 +0100
@@ -21,7 +21,12 @@
 #include <SDL.h>
 #include <imgui.h>
 #include <imgui_impl_sdl2.h>
+#ifdef ENABLE_GLES2
+#define IMGUI_IMPL_OPENGL_ES2
+#include <imgui_impl_opengl3.h>
+#else
 #include <imgui_impl_opengl2.h>
+#endif
 #include "3rdparty/tinyfiledialogs/tinyfiledialogs.h"
 #include "3rdparty/pugixml/src/pugixml.hpp"
 #include <fstream>
@@ -1304,7 +1309,11 @@
 	
 	// Setup Platform/Renderer backends
 	ImGui_ImplSDL2_InitForOpenGL(window, gl_context);
+#ifdef ENABLE_GLES2
+	ImGui_ImplOpenGL3_Init();
+#else
 	ImGui_ImplOpenGL2_Init();
+#endif
 	
 	bool start=false;
 	bool inentryediting=false;
@@ -1331,7 +1340,11 @@
 		}
 		
 		// Start the Dear ImGui frame
+#ifdef ENABLE_GLES2
+		ImGui_ImplOpenGL3_NewFrame();
+#else
 		ImGui_ImplOpenGL2_NewFrame();
+#endif
 		ImGui_ImplSDL2_NewFrame();
 		ImGui::NewFrame();
 		if (inentryediting)
@@ -1485,12 +1498,20 @@
 		glViewport(0, 0, (int)io.DisplaySize.x, (int)io.DisplaySize.y);
 		glClearColor(0.0,0.0,0.0,1.0);
 		glClear(GL_COLOR_BUFFER_BIT);
+#ifdef ENABLE_GLES2
+		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
+#else
 		ImGui_ImplOpenGL2_RenderDrawData(ImGui::GetDrawData());
+#endif
 		SDL_GL_SwapWindow(window);
 	}
 	
 	// Cleanup
+#ifdef ENABLE_GLES2
+	ImGui_ImplOpenGL3_Shutdown();
+#else
 	ImGui_ImplOpenGL2_Shutdown();
+#endif
 	ImGui_ImplSDL2_Shutdown();
 	ImGui::DestroyContext();
 	
diff -u -r -N lightspark-0.9.0/src/logger.cpp lightspark-master/src/logger.cpp
--- lightspark-0.9.0/src/logger.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/logger.cpp	2025-03-05 20:13:02.143864663 +0100
@@ -49,7 +49,10 @@
 	{
 		Locker l(logmutex);
 #ifndef NDEBUG
-		*logStream << level_names[cur_level] << ": " << asAtomHandler::toDebugString(logAtom)<<" " << message.str();
+		if (asAtomHandler::isValid(logAtom))
+			*logStream << level_names[cur_level] << ": " << asAtomHandler::toDebugString(logAtom)<<" " << message.str();
+		else
+			*logStream << level_names[cur_level] << ": " << message.str();
 #else
 		*logStream << level_names[cur_level] << ": " << message.str();
 #endif
diff -u -r -N lightspark-0.9.0/src/parsing/amf3_generator.cpp lightspark-master/src/parsing/amf3_generator.cpp
--- lightspark-0.9.0/src/parsing/amf3_generator.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/parsing/amf3_generator.cpp	2025-03-05 20:13:02.143864663 +0100
@@ -497,6 +497,7 @@
 			// exception thrown during construction
 			// adobe seems to just trace the error and continue;
 			input->getSystemState()->trace(input->getInstanceWorker()->currentCallContext->exceptionthrown->toString());
+			input->getInstanceWorker()->currentCallContext->exceptionthrown->decRef();
 			input->getInstanceWorker()->currentCallContext->exceptionthrown=nullptr;
 		}
 	}
@@ -520,7 +521,9 @@
 			// exception thrown during setter call
 			// adobe seems to just trace the error and continue;
 			input->getSystemState()->trace(input->getInstanceWorker()->currentCallContext->exceptionthrown->toString());
+			input->getInstanceWorker()->currentCallContext->exceptionthrown->decRef();
 			input->getInstanceWorker()->currentCallContext->exceptionthrown=nullptr;
+			ASATOM_DECREF(value);
 		}
 	}
 
diff -u -r -N lightspark-0.9.0/src/parsing/tags.cpp lightspark-master/src/parsing/tags.cpp
--- lightspark-0.9.0/src/parsing/tags.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/parsing/tags.cpp	2025-03-05 20:13:02.144864687 +0100
@@ -2101,7 +2101,7 @@
 			if (it->EventFlags.ClipEventConstruct)
 			{
 				AVM1context context;
-				ACTIONRECORD::executeActions(currchar ,&context,it->actions,it->startactionpos,m);
+				ACTIONRECORD::executeActions(currchar ,&context,it->actions,it->startactionpos);
 			}
 		}
 	}
@@ -2114,7 +2114,7 @@
 			if (it->EventFlags.ClipEventInitialize)
 			{
 				AVM1context context;
-				ACTIONRECORD::executeActions(currchar ,&context,it->actions,it->startactionpos,m);
+				ACTIONRECORD::executeActions(currchar ,&context,it->actions,it->startactionpos);
 			}
 		}
 	}
@@ -3292,9 +3292,8 @@
 		LOG(LOG_ERROR,"sprite not found for InitActionTag:"<<SpriteId);
 		return;
 	}
-	std::map<uint32_t,asAtom> m;
 	LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<clip->state.FP<<" initActions "<< clip->toDebugString()<<" "<<sprite->getId());
-	ACTIONRECORD::executeActions(clip,sprite->getAVM1Context(),actions,startactionpos,m,true);
+	ACTIONRECORD::executeActions(clip,sprite->getAVM1Context(),actions,startactionpos,nullptr,true);
 	LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<clip->state.FP<<" initActions done "<< clip->toDebugString()<<" "<<sprite->getId());
 }
 
diff -u -r -N lightspark-0.9.0/src/platforms/engineutils.cpp lightspark-master/src/platforms/engineutils.cpp
--- lightspark-0.9.0/src/platforms/engineutils.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/platforms/engineutils.cpp	2025-03-05 20:13:02.144864687 +0100
@@ -175,7 +175,6 @@
 			if (quit.quitType == LSQuitEvent::QuitType::User)
 			{
 				assert(hasEngineData);
-				setTLSSys(nullptr);
 				sys->getEngineData()->handleQuit();
 				return true;
 			}
@@ -551,7 +550,7 @@
 	assert(!widget);
 	this->origwidth = w;
 	this->origheight = h;
-	
+
 	// width and height may already be set from the plugin
 	if (this->width == 0)
 		this->width = w;
@@ -570,7 +569,7 @@
 	if (widget && !(SDL_GetWindowFlags(widget) & SDL_WINDOW_HIDDEN))
 		SDL_ShowWindow(widget);
 	grabFocus();
-	
+
 }
 
 void EngineData::checkForNativeAIRExtensions(std::vector<tiny_string>& extensions, char* fileName)
@@ -648,7 +647,6 @@
 	}
 	else
 	{
-		setTLSSys(nullptr);
 		handleQuit();
 	}
 }
@@ -892,7 +890,7 @@
 	float backgroundcolor = 0.9;
 	float selectedbackgroundcolor = 0.5;
 	float textcolor = 0.0;
-	
+
 	contextmenucurrentitem=newselecteditem;
 	cairo_surface_t* cairoSurface=cairo_image_surface_create_for_data(contextmenupixels, CAIRO_FORMAT_ARGB32, CONTEXTMENUWIDTH, contextmenuheight, cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, CONTEXTMENUWIDTH));
 	cairo_t* cr=cairo_create(cairoSurface);
@@ -906,7 +904,7 @@
 	cairo_set_line_width(cr, 2);
 	cairo_rectangle(cr, 1, 1, CONTEXTMENUWIDTH-2, contextmenuheight-2);
 	cairo_stroke(cr);
-	
+
 	PangoLayout* layout = pango_cairo_create_layout(cr);
 	PangoFontDescription* desc = pango_font_description_new();
 	pango_font_description_set_family(desc, "Helvetica");
@@ -1022,7 +1020,7 @@
 	{
 		LOG(LOG_NOT_IMPLEMENTED,"showCursor for name:"<<name);
 		SDL_SetCursor(SDL_GetDefaultCursor());
-	}		
+	}
 }
 tiny_string EngineData::getMouseCursor(SystemState *sys)
 {
@@ -1447,7 +1445,7 @@
 void EngineData::exec_glFramebufferRenderbuffer_GL_FRAMEBUFFER_GL_DEPTH_STENCIL_ATTACHMENT(uint32_t depthStencilRenderBuffer)
 {
 #ifndef ENABLE_GLES2
-	glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER,depthStencilRenderBuffer);	
+	glFramebufferRenderbuffer(GL_FRAMEBUFFER,GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER,depthStencilRenderBuffer);
 #endif
 }
 
@@ -1743,7 +1741,12 @@
 }
 void EngineData::exec_glClearDepthf(float depth)
 {
+#ifdef ENABLE_GLES2
 	glClearDepthf(depth);
+#else
+	// glClearDepthf is not available in OpenGL2
+	glClearDepth(depth);
+#endif
 }
 
 void EngineData::exec_glClear_GL_COLOR_BUFFER_BIT()
@@ -1878,7 +1881,7 @@
 	GLenum glsfail=GL_KEEP;
 	switch (sfail)
 	{
-		case DEPTHSTENCIL_KEEP: 
+		case DEPTHSTENCIL_KEEP:
 			glsfail=GL_KEEP;
 			break;
 		case DEPTHSTENCIL_ZERO:
@@ -1906,7 +1909,7 @@
 	GLenum gldpfail=GL_KEEP;
 	switch (dpfail)
 	{
-		case DEPTHSTENCIL_KEEP: 
+		case DEPTHSTENCIL_KEEP:
 			gldpfail=GL_KEEP;
 			break;
 		case DEPTHSTENCIL_ZERO:
@@ -1934,7 +1937,7 @@
 	GLenum gldppass=GL_KEEP;
 	switch (dppass)
 	{
-		case DEPTHSTENCIL_KEEP: 
+		case DEPTHSTENCIL_KEEP:
 			gldppass=GL_KEEP;
 			break;
 		case DEPTHSTENCIL_ZERO:
diff -u -r -N lightspark-0.9.0/src/scripting/abc_avm1.cpp lightspark-master/src/scripting/abc_avm1.cpp
--- lightspark-0.9.0/src/scripting/abc_avm1.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abc_avm1.cpp	2025-03-05 20:13:02.154864933 +0100
@@ -82,6 +82,7 @@
 	builtinavm1->registerBuiltin("ContextMenuItem","",Class<AVM1ContextMenuItem>::getRef(m_sys));
 	builtinavm1->registerBuiltin("TextField","",Class<AVM1TextField>::getRef(m_sys));
 	builtinavm1->registerBuiltin("TextFormat","",Class<AVM1TextFormat>::getRef(m_sys));
+	builtinavm1->registerBuiltin("Selection","",Class<AVM1Selection>::getRef(m_sys));
 	builtinavm1->registerBuiltin("XML","",Class<AVM1XMLDocument>::getRef(m_sys));
 	builtinavm1->registerBuiltin("XMLNode","",Class<AVM1XMLNode>::getRef(m_sys));
 	builtinavm1->registerBuiltin("XMLSocket","",Class<AVM1XMLSocket>::getRef(m_sys));
diff -u -r -N lightspark-0.9.0/src/scripting/abc.cpp lightspark-master/src/scripting/abc.cpp
--- lightspark-0.9.0/src/scripting/abc.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abc.cpp	2025-03-05 20:13:02.153864908 +0100
@@ -1017,22 +1017,15 @@
 		if(!event->defaultPrevented)
 			dispatcher->getSystemState()->stage->defaultEventBehavior(event);
 	}
-	if (event->type == "mouseDown" && dispatcher->is<InteractiveObject>())
-	{
-		// only set new focus target if the current focus is not a child of the dispatcher
-		InteractiveObject* f = dispatcher->getSystemState()->stage->getFocusTarget().getPtr();
-		while (f && f != dispatcher)
-			f=f->getParent();
-		if (!f)
-		{
-			dispatcher->incRef();
-			dispatcher->getSystemState()->stage->setFocusTarget(_MNR(dispatcher->as<InteractiveObject>()));
-		}
-	}
 	if (dispatcher->is<DisplayObject>() || dispatcher->is<LoaderInfo>() || dispatcher->is<URLLoader>())
 		dispatcher->getSystemState()->stage->AVM1HandleEvent(dispatcher,event.getPtr());
 	else
 		dispatcher->AVM1HandleEvent(dispatcher,event.getPtr());
+	if (event->type == "mouseDown" && dispatcher->is<InteractiveObject>())
+	{
+		dispatcher->incRef();
+		dispatcher->getSystemState()->stage->setFocusTarget(_MNR(dispatcher->as<InteractiveObject>()));
+	}
 
 	/* This must even be called if stop*Propagation has been called */
 	if(!event->defaultPrevented)
@@ -1072,6 +1065,8 @@
 	catch(ASObject*& e)
 	{
 		ASWorker* wrk = e->getInstanceWorker();
+		StackTraceList stacktrace;
+		wrk->fillStackTrace(stacktrace);
 		if (!wrk->callStack.empty())
 		{
 			call_context* saved_cc = wrk->callStack.back();
@@ -1090,12 +1085,18 @@
 			m_sys->setError(e->as<ASError>()->getStackTraceString());
 		}
 		else
-			m_sys->setError("Unhandled ActionScript exception");
+		{
+			if (!m_sys->isShuttingDown())
+			{
+				/* do not allow any more event to be enqueued */
+				m_sys->setShutdownFlag();
+			}
+			m_sys->setError(ASWorker::getStackTraceString(m_sys,stacktrace,e));
+		}
 		if (!m_sys->isShuttingDown())
 		{
 			/* do not allow any more event to be enqueued */
-			shuttingdown = true;
-			signalEventWaiters();
+			m_sys->setShutdownFlag();
 		}
 	}
 }
@@ -1701,6 +1702,8 @@
 {
 	if (scriptsdeclared)
 		return;
+	while (!getVm(applicationDomain->getSystemState())->hasEverStarted()) // ensure that all builtin classes are defined
+		applicationDomain->getSystemState()->sleep_ms(10);
 	//Take script entries and declare their traits
 	unsigned int i=0;
 
@@ -1766,12 +1769,21 @@
 	method_info* m=get_method(scripts[i].init);
 	SyntheticFunction* entry=Class<IFunction>::getSyntheticFunction(this->applicationDomain->getInstanceWorker(),m,m->numArgs());
 	entry->fromNewFunction=true;
-
+	entry->scriptInit = true;
 	entry->addToScope(scope_entry(g,false));
 
 	asAtom ret=asAtomHandler::invalidAtom;
 	asAtom f =asAtomHandler::fromObject(entry);
-	asAtomHandler::callFunction(f,this->applicationDomain->getInstanceWorker(),ret,g,nullptr,0,false,false,false);
+	try
+	{
+		asAtomHandler::callFunction(f,this->applicationDomain->getInstanceWorker(),ret,g,nullptr,0,false,false,false);
+	}
+	catch(ASObject*& e)
+	{
+		ASATOM_DECREF(ret);
+		entry->setRefConstant(); // ensure function is kept alive for stacktrace in uncaught exception handling
+		throw e;
+	}
 
 	ASATOM_DECREF(ret);
 
diff -u -r -N lightspark-0.9.0/src/scripting/abc_methods.cpp lightspark-master/src/scripting/abc_methods.cpp
--- lightspark-0.9.0/src/scripting/abc_methods.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abc_methods.cpp	2025-03-05 20:13:02.160865080 +0100
@@ -973,7 +973,7 @@
 	RUNTIME_STACK_POP_CREATE_ASOBJECT(context,v2);
 
 	LOG_CALL("setSlot " << t << " "<< v2->toDebugString() << " "<< asAtomHandler::toDebugString(*v1));
-	if (!v2->setSlot(context->worker,t,*v1))
+	if (v2->setSlot(context->worker,t,*v1) == TFALSE)
 		ASATOM_DECREF_POINTER(v1);
 	v2->decRef();
 	++(context->exec_pos);
@@ -994,7 +994,9 @@
 
 	Global* globalscope = getGlobalScope(context);
 	RUNTIME_STACK_POP_CREATE(context,o);
-	globalscope->setSlot(context->worker,t-1,*o);
+	LOG_CALL( "setGlobalSlot "<<t<<" "<<asAtomHandler::toDebugString(*o) );
+	if (globalscope->setSlot(context->worker,t-1,*o) == TFALSE)
+		ASATOM_DECREF(*o);
 	++(context->exec_pos);
 }
 void ABCVm::abc_convert_s(call_context* context)
diff -u -r -N lightspark-0.9.0/src/scripting/abc_methods_optimized.cpp lightspark-master/src/scripting/abc_methods_optimized.cpp
--- lightspark-0.9.0/src/scripting/abc_methods_optimized.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abc_methods_optimized.cpp	2025-03-05 20:13:02.161865104 +0100
@@ -4404,7 +4404,7 @@
 	asAtom v2 = *context->exec_pos->arg2_constant;
 	uint32_t t = context->exec_pos->arg3_uint;
 	LOG_CALL("setSlot_cc " << t << " "<< asAtomHandler::toDebugString(v2) << " "<< asAtomHandler::toDebugString(v1));
-	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2))
+	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2)==TTRUE)
 		ASATOM_INCREF(v2);
 	++(context->exec_pos);
 }
@@ -4414,7 +4414,7 @@
 	asAtom v2 = *context->exec_pos->arg2_constant;
 	uint32_t t = context->exec_pos->arg3_uint;
 	LOG_CALL("setSlot_lc " << t << " "<< asAtomHandler::toDebugString(v2) << " "<< asAtomHandler::toDebugString(v1));
-	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2))
+	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2)==TTRUE)
 		ASATOM_INCREF(v2);
 	++(context->exec_pos);
 }
@@ -4424,7 +4424,7 @@
 	asAtom v2 = CONTEXT_GETLOCAL(context,context->exec_pos->local_pos2);
 	uint32_t t = context->exec_pos->arg3_uint;
 	LOG_CALL("setSlot_cl " << t << " "<< asAtomHandler::toDebugString(v2) << " "<< asAtomHandler::toDebugString(v1));
-	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2))
+	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2)==TTRUE)
 		ASATOM_INCREF(v2);
 	++(context->exec_pos);
 }
@@ -4434,7 +4434,7 @@
 	asAtom v2 = CONTEXT_GETLOCAL(context,context->exec_pos->local_pos2);
 	uint32_t t = context->exec_pos->arg3_uint;
 	LOG_CALL("setSlot_ll " << t << " "<< asAtomHandler::toDebugString(v2) << " "<< asAtomHandler::toDebugString(v1));
-	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2))
+	if (asAtomHandler::getObject(v1)->setSlot(context->worker,t,v2)==TTRUE)
 		ASATOM_INCREF(v2);
 	++(context->exec_pos);
 }
@@ -4878,7 +4878,7 @@
 	}
 	else
 		asAtomHandler::set(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),res);
-	asAtomHandler::increment(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),context->worker,context->exec_pos->local3.pos == context->exec_pos->local_pos1);
+	asAtomHandler::increment(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),context->worker,true);
 	++(context->exec_pos);
 }
 void ABCVm::abc_decrement_local(call_context* context)
@@ -4904,7 +4904,7 @@
 	}
 	else
 		asAtomHandler::set(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),res);
-	asAtomHandler::decrement(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),context->worker,context->exec_pos->local3.pos == context->exec_pos->local_pos1);
+	asAtomHandler::decrement(CONTEXT_GETLOCAL(context,context->exec_pos->local3.pos),context->worker,true);
 	++(context->exec_pos);
 }
 void ABCVm::abc_typeof_constant(call_context* context)
diff -u -r -N lightspark-0.9.0/src/scripting/abc_opcodes.cpp lightspark-master/src/scripting/abc_opcodes.cpp
--- lightspark-0.9.0/src/scripting/abc_opcodes.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abc_opcodes.cpp	2025-03-05 20:13:02.161865104 +0100
@@ -2830,6 +2830,7 @@
 	SyntheticFunction* cinit=Class<IFunction>::getSyntheticFunction(th->worker,m,m->numArgs()-m->numOptions());
 	cinit->fromNewFunction=true;
 	cinit->inClass = ret;
+	cinit->classInit = true;
 	cinit->setRefConstant();
 	//cinit must inherit the current scope
 	if (th->parent_scope_stack)
@@ -3029,12 +3030,13 @@
 
 ASObject* ABCVm::newFunction(call_context* th, int n)
 {
-	LOG_CALL("newFunction " << n);
 
 	method_info* m=&th->mi->context->methods[n];
 	SyntheticFunction* f=Class<IFunction>::getSyntheticFunction(th->worker,m,m->numArgs()-m->numOptions());
 	f->func_scope = _R<scope_entry_list>(new scope_entry_list());
 	f->fromNewFunction=true;
+	f->methodnumber=n;
+	LOG_CALL("newFunction " << n<<" "<<f->toDebugString());
 	if (th->parent_scope_stack)
 	{
 		f->func_scope->scope=th->parent_scope_stack->scope;
diff -u -r -N lightspark-0.9.0/src/scripting/abcutils.h lightspark-master/src/scripting/abcutils.h
--- lightspark-0.9.0/src/scripting/abcutils.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/abcutils.h	2025-03-05 20:13:02.161865104 +0100
@@ -34,6 +34,7 @@
 class Class_base;
 union asAtom;
 class SyntheticFunction;
+class AVM1Scope;
 
 struct scope_entry
 {
@@ -104,7 +105,10 @@
 private:
 	std::vector<uint32_t> avm1strings;
 public:
-	AVM1context():keepLocals(true), callDepth(0), actionsExecuted(0),swfversion(0),exceptionthrown(nullptr), callee(nullptr) {}
+	AVM1context();
+	AVM1context(const _R<DisplayObject>& target, SystemState* sys);
+	~AVM1context();
+
 	void AVM1ClearConstants()
 	{
 		avm1strings.clear();
@@ -120,6 +124,106 @@
 		LOG(LOG_ERROR,"AVM1:constant not found in pool:"<<index<<" "<<avm1strings.size());
 		return asAtomHandler::undefinedAtom;
 	}
+
+	// Resolves a target path string to an object.
+	// This only returns `ASObject`s, non-object values return `nullptr`.
+	//
+	// This can be either a `/` path, `.`, or a weird combination of the
+	// two. e.g. `_root/clip`, `clip.child._parent`, `clip:child`, etc.
+	// See Ruffle's `avm1/target_path` test for many different examples.
+	//
+	// A target path always resolves on the display list. It can also
+	// look in the prototype chain, but not the scope chain.
+	ASObject* resolveTargetPath
+	(
+		const asAtom& thisObj,
+		DisplayObject* baseClip,
+		DisplayObject* root,
+		const _R<ASObject>& start,
+		const tiny_string& _path,
+		bool hasSlash,
+		bool first = true
+	) const;
+
+	// Resolves a path for variable bindings.
+	// Returns both the parent object that this variable belongs to, and
+	// the variable name.
+	std::pair<ASObject*, tiny_string> resolveVariablePath
+	(
+		const asAtom& thisObj,
+		DisplayObject* baseClip,
+		const _R<DisplayObject>& clip,
+		const tiny_string& path
+	) const;
+
+	// Gets the value, referenced by a target path string.
+	//
+	// This can either be a normal variable name, `/` path, `.` path,
+	// or a weird combination thereof.
+	// e.g. `_root/clip.foo`, `clip:child:_parent`, and `bar`.
+	// See Ruffle's `avm1/target_path` test for many different examples.
+	//
+	// It first tries to resolve the string as a target path, with a
+	// variable name, such as `foo/bar/baz:biz`. The last `:`, or `.`
+	// denotes the variable name, with everything before it denoting the
+	// path of the target object. Note that the variable name on the
+	// right can contain a `/` in this case. This path (minus the
+	// variable name) is recursively resolved on the scope chain.
+	// If the path doesn't resolve on any scope, then `undefined` is
+	// returned.
+	//
+	// If there's no variable name, but the path contains `/`s, it'll
+	// try to resolve on the scope chain. If that fails, then it's
+	// treated as a variable name, and falls back to the variable case
+	// (i.e. `a/b` would be treated as a variable called `a/b`, rather
+	// than as a path).
+	//
+	// And finally, if none of the above it's a normal variable name,
+	// resolved on the scope chain.
+	asAtom getVariable
+	(
+		const asAtom& thisObj,
+		DisplayObject* baseClip,
+		DisplayObject* clip,
+		const tiny_string& path
+	) const;
+
+	// Sets the value, referenced by a target path string.
+	//
+	// This can either be a normal variable name, `/` path, `.` path,
+	// or a weird combination thereof.
+	// e.g. `_root/clip.foo`, `clip:child:_parent`, and `bar`.
+	// See Ruffle's `avm1/target_path` test for many different examples.
+	//
+	// It first tries to resolve the string as a target path, with a
+	// variable name, such as `foo/bar/baz:biz`. The last `:`, or `.`
+	// denotes the variable name, with everything before it denoting the
+	// path of the target object. Note that the variable name on the
+	// right can contain a `/` in this case. This path (minus the
+	// variable name) is recursively resolved on the scope chain.
+	// If the path doesn't resolve on any scope, then the set fails, and
+	// returns early. Otherwise, the variable name is either created, or
+	// overwritten on the target scope.
+	//
+	// This differs from `getVariable()` because `/` paths that have no
+	// variable segment are invalid. e.g. `a/b` sets a property called `a/b` on the
+	// stack frame, rather than traversing the display list.
+	//
+	// If the string couldn't resolve to a path, it's considered a normal
+	// variable name, and is set on the scope chain.
+	void setVariable
+	(
+		asAtom& thisObj,
+		DisplayObject* baseClip,
+		DisplayObject* clip,
+		const tiny_string& path,
+		const asAtom& value
+	);
+
+	// Returns whether property keys are case sensitive, based on the
+	// current SWF version.
+	bool isCaseSensitive() const { return swfversion > 6; }
+
 	bool keepLocals;
 	size_t callDepth;
 	size_t actionsExecuted;
@@ -127,6 +231,8 @@
 	uint8_t swfversion;
 	ASObject* exceptionthrown;
 	AVM1Function* callee;
+	_NR<AVM1Scope> scope;
+	_NR<AVM1Scope> globalScope;
 };
 
 
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/avm1array.cpp lightspark-master/src/scripting/avm1/avm1array.cpp
--- lightspark-0.9.0/src/scripting/avm1/avm1array.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1/avm1array.cpp	2025-03-05 20:13:02.161865104 +0100
@@ -219,6 +219,12 @@
 	}
 }
 
+void AVM1Array::resize(uint64_t n, bool removeMember)
+{
+	avm1_currentsize = n;
+	Array::resize(n, removeMember);
+}
+
 void AVM1Array::AVM1enumerate(std::stack<asAtom>& stack)
 {
 	for (auto it = name_enumeration.begin(); it != name_enumeration.end(); it++)
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/avm1array.h lightspark-master/src/scripting/avm1/avm1array.h
--- lightspark-0.9.0/src/scripting/avm1/avm1array.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1/avm1array.h	2025-03-05 20:13:02.161865104 +0100
@@ -60,6 +60,7 @@
 	uint32_t nextNameIndex(uint32_t cur_index) override;
 	void nextName(asAtom &ret, uint32_t index) override;
 	void nextValue(asAtom &ret, uint32_t index) override;
+	void resize(uint64_t n, bool removeMember = true) override;
 	void AVM1enumerate(std::stack<asAtom>& stack) override;
 };
 
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/avm1text.cpp lightspark-master/src/scripting/avm1/avm1text.cpp
--- lightspark-0.9.0/src/scripting/avm1/avm1text.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1/avm1text.cpp	2025-03-05 20:13:02.164865178 +0100
@@ -20,6 +20,7 @@
 #include "avm1text.h"
 #include "scripting/class.h"
 #include "scripting/argconv.h"
+#include "scripting/flash/display/Stage.h"
 
 using namespace std;
 using namespace lightspark;
@@ -29,10 +30,49 @@
 	InteractiveObject::AVM1SetupMethods(c);
 	TextField::sinit(c);
 	c->isSealed = false;
-	c->setDeclaredMethodByQName("setNewTextFormat","",c->getSystemState()->getBuiltinFunction(TextField::_setDefaultTextFormat),NORMAL_METHOD,true);
+	c->prototype->setVariableByQName("setNewTextFormat","",c->getSystemState()->getBuiltinFunction(TextField::_setDefaultTextFormat,1),DYNAMIC_TRAIT);
 }
 void AVM1TextFormat::sinit(Class_base* c)
 {
 	TextFormat::sinit(c);
 	c->isSealed = false;
 }
+
+void AVM1Selection::sinit(Class_base* c)
+{
+	CLASS_SETUP_NO_CONSTRUCTOR(c, ASObject, 0);
+	c->setDeclaredMethodByQName("addListener","",c->getSystemState()->getBuiltinFunction(addListener),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("getFocus","",c->getSystemState()->getBuiltinFunction(getFocus),NORMAL_METHOD,false);
+	c->setDeclaredMethodByQName("setFocus","",c->getSystemState()->getBuiltinFunction(getFocus),NORMAL_METHOD,false);
+}
+ASFUNCTIONBODY_ATOM(AVM1Selection,addListener)
+{
+	_NR<ASObject> listener;
+	ARG_CHECK(ARG_UNPACK(listener));
+	if (listener)
+		wrk->getSystemState()->stage->AVM1AddMouseListener(listener.getPtr());
+}
+ASFUNCTIONBODY_ATOM(AVM1Selection,getFocus)
+{
+	_NR<InteractiveObject> focus = wrk->getSystemState()->stage->getFocusTarget();
+	if (focus)
+		ret = asAtomHandler::fromString(wrk->getSystemState(),focus->AVM1GetPath());
+	else
+		ret = asAtomHandler::nullAtom;
+}
+ASFUNCTIONBODY_ATOM(AVM1Selection,setFocus)
+{
+	if (argslen==0)
+		return;
+	if (asAtomHandler::isNull(args[0]) || asAtomHandler::isUndefined(args[0]))
+		wrk->getSystemState()->stage->setFocusTarget(NullRef);
+	else if (asAtomHandler::is<InteractiveObject>(args[0]))
+	{
+		InteractiveObject* o = asAtomHandler::as<InteractiveObject>(args[0]);
+		o->incRef();
+		wrk->getSystemState()->stage->setFocusTarget(_MR(o));
+	}
+	else
+		LOG(LOG_ERROR,"invalid object for Selection.setFocus:"<<asAtomHandler::toDebugString(args[0]));
+}
+
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/avm1text.h lightspark-master/src/scripting/avm1/avm1text.h
--- lightspark-0.9.0/src/scripting/avm1/avm1text.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1/avm1text.h	2025-03-05 20:13:02.164865178 +0100
@@ -44,5 +44,16 @@
 	static void sinit(Class_base* c);
 };
 
+class AVM1Selection: public ASObject
+{
+public:
+	AVM1Selection(ASWorker* wrk,Class_base* c):ASObject(wrk,c)
+	{}
+	static void sinit(Class_base* c);
+	ASFUNCTION_ATOM(addListener);
+	ASFUNCTION_ATOM(getFocus);
+	ASFUNCTION_ATOM(setFocus);
+};
+
 }
 #endif // SCRIPTING_AVM1_AVM1TEXT_H
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/avm1xml.cpp lightspark-master/src/scripting/avm1/avm1xml.cpp
--- lightspark-0.9.0/src/scripting/avm1/avm1xml.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1/avm1xml.cpp	2025-03-05 20:13:02.164865178 +0100
@@ -65,7 +65,7 @@
 	c->prototype->setVariableByQName("createElement","",c->getSystemState()->getBuiltinFunction(createElement,1,Class<XMLNode>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("createTextNode","",c->getSystemState()->getBuiltinFunction(createTextNode,1,Class<XMLNode>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("load","",c->getSystemState()->getBuiltinFunction(load),DYNAMIC_TRAIT);
-	c->prototype->setVariableByQName("idmap","",c->getSystemState()->getBuiltinFunction(_idmap,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
+	c->prototype->setVariableByQName("idMap","",c->getSystemState()->getBuiltinFunction(_idmap,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("docTypeDecl	","",c->getSystemState()->getBuiltinFunction(_docTypeDecl,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("xmlDecl","",c->getSystemState()->getBuiltinFunction(_xmlDecl,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),DYNAMIC_TRAIT);
 	c->prototype->setVariableByQName("getBytesTotal","",c->getSystemState()->getBuiltinFunction(getBytesTotal),DYNAMIC_TRAIT);
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/scope.cpp lightspark-master/src/scripting/avm1/scope.cpp
--- lightspark-0.9.0/src/scripting/avm1/scope.cpp	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/scripting/avm1/scope.cpp	2025-03-05 20:13:02.164865178 +0100
@@ -0,0 +1,234 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2025  mr b0nk 500 (b0nk@b0nk.xyz)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#include "asobject.h"
+#include "scripting/avm1/scope.h"
+#include "scripting/class.h"
+#include "scripting/flash/display/RootMovieClip.h"
+#include "scripting/flash/system/flashsystem.h"
+#include "scripting/toplevel/Global.h"
+#include "swf.h"
+#include "swftypes.h"
+#include "utils/optional.h"
+
+using namespace lightspark;
+
+// Based on Ruffle's `avm1::scope::Scope`.
+
+AVM1Scope::AVM1Scope(const _R<Global>& globals) : AVM1Scope
+(
+	// `parent`
+	NullRef,
+	// `_class`
+	AVM1ScopeClass::Global,
+	// `values`
+	globals
+)
+{
+}
+
+AVM1Scope::AVM1Scope
+(
+	const _R<AVM1Scope>& parent,
+	const _R<DisplayObject>& clip
+) : AVM1Scope(parent, AVM1ScopeClass::Target, clip)
+{
+}
+
+AVM1Scope::AVM1Scope
+(
+	const _R<AVM1Scope>& parent,
+	ASWorker* wrk
+) : AVM1Scope(parent, AVM1ScopeClass::Local, _MR(new_asobject(wrk)))
+{
+}
+
+void AVM1Scope::setTargetScope(const _R<DisplayObject>& clip)
+{
+	if (isTargetScope())
+		setLocals(clip);
+	else if (!parent.isNull())
+		parent->setTargetScope(clip);
+}
+
+asAtom AVM1Scope::resolveRecursiveByMultiname
+(
+	DisplayObject* baseClip,
+	const multiname& name,
+	const GET_VARIABLE_OPTION& options,
+	ASWorker* wrk,
+	bool isTopLevel
+)
+{
+	asAtom ret = asAtomHandler::invalidAtom;
+	if (values->hasPropertyByMultiname(name, true, true, wrk))
+	{
+		values->AVM1getVariableByMultiname(ret, name, options, wrk, false);
+		return ret;
+	}
+
+	if (parent.isNull())
+		return ret;
+
+	ret = parent->getVariableByMultiname(baseClip, name, options, wrk);
+
+	if (asAtomHandler::isValid(ret) || !values->is<DisplayObject>())
+		return ret;
+
+	auto clip = values->as<DisplayObject>();
+	if (!isTopLevel || (clip->isOnStage() && !clip->hasPropertyByMultiname(name, true, true, wrk)))
+		return ret;
+
+	// If we failed to find the value in the scope chain, but would've
+	// resolved on `values`, if it were on stage, then try looking for
+	// it in the root clip instead.
+	auto root = baseClip->AVM1getRoot();
+	ret = asAtomHandler::invalidAtom;
+	root->AVM1getVariableByMultiname(ret, name, options, wrk, false);
+	return ret;
+}
+
+bool AVM1Scope::setVariableByMultiname
+(
+	multiname& name,
+	asAtom& value,
+	const ASObject::CONST_ALLOWED_FLAG& allowConst,
+	ASWorker* wrk
+)
+{
+	bool removed =
+	(
+		values->is<DisplayObject>() &&
+		!values->as<DisplayObject>()->isOnStage()
+	);
+
+	if (!removed && (isTargetScope() || values->hasPropertyByMultiname(name, true, true, wrk)))
+	{
+		// Found the variable on this object, overwrite it.
+		// Or, we've hit the currently running clip, so create it here.
+		return values->AVM1setVariableByMultiname(name, value, allowConst, wrk);
+	}
+	else if (!parent.isNull())
+	{
+		// Couldn't find the variable, traverse the scope chain.
+		return parent->setVariableByMultiname(name, value, allowConst, wrk);
+	}
+
+	// This probably shouldn't happen, since all AVM1 code runs in
+	// reference to a `MovieClip`, so we should always have a `MovieClip`
+	// scope. Define it on the top level scope.
+	LOG(LOG_ERROR, "AVM1Scope::setVariableByMultiname: No top level `MovieClip` scope.");
+	return values->AVM1setVariableByMultiname(name, value, allowConst, wrk);
+}
+
+bool AVM1Scope::defineLocalByMultiname
+(
+	multiname& name,
+	asAtom& value,
+	const ASObject::CONST_ALLOWED_FLAG& allowConst,
+	ASWorker* wrk
+)
+{
+	if (!isWithScope() || !parent.isNull())
+		return values->AVM1setVariableByMultiname(name, value, allowConst, wrk);
+	// When defining a local in a `with` scope, we also need to check if
+	// that local exists on the `with` target. If it does, the variable
+	// of the target should be modified. If not, the property should be
+	// defined in the first non-`with` parent scope.
+
+	// Does this variable already exist on the target?
+	if (values->hasPropertyByMultiname(name, true, true, wrk))
+		return values->AVM1setVariableByMultiname(name, value, allowConst, wrk);
+
+	// If not, go up the scope chain.
+	return parent->defineLocalByMultiname(name, value, allowConst, wrk);
+}
+
+bool AVM1Scope::forceDefineLocalByMultiname
+(
+	multiname& name,
+	asAtom& value,
+	const ASObject::CONST_ALLOWED_FLAG& allowConst,
+	ASWorker* wrk
+)
+{
+	bool alreadySet = false;
+	values->setVariableByMultiname(name, value, allowConst, &alreadySet, wrk);
+	return alreadySet;
+}
+
+bool AVM1Scope::forceDefineLocal
+(
+	const tiny_string& name,
+	asAtom& value,
+	const ASObject::CONST_ALLOWED_FLAG& allowConst,
+	ASWorker* wrk
+)
+{
+	return forceDefineLocal
+	(
+		wrk->getSystemState()->getUniqueStringId(name, true),
+		value,
+		allowConst,
+		wrk
+	);
+}
+
+bool AVM1Scope::forceDefineLocal
+(
+	uint32_t nameID,
+	asAtom& value,
+	const ASObject::CONST_ALLOWED_FLAG& allowConst,
+	ASWorker* wrk
+)
+{
+	multiname m(nullptr);
+	m.name_type = multiname::NAME_STRING;
+	m.name_s_id = nameID;
+	return forceDefineLocalByMultiname(m, value, allowConst, wrk);
+}
+
+bool AVM1Scope::deleteVariableByMultiname(const multiname& name, ASWorker* wrk)
+{
+	if (values && values->hasPropertyByMultiname(name, true, true, wrk))
+		return values->deleteVariableByMultiname(name, wrk);
+	else if (!parent.isNull())
+		return parent->deleteVariableByMultiname(name, wrk);
+	return false;
+}
+
+bool AVM1Scope::countAllCyclicMemberReferences(garbagecollectorstate& gcstate)
+{
+	if (gcstate.stopped)
+		return false;
+	bool ret = false;
+	if (values)
+		ret = values->countAllCylicMemberReferences(gcstate);
+	if (!parent.isNull())
+		ret = parent->countAllCyclicMemberReferences(gcstate) | ret;
+	return ret;
+}
+
+void AVM1Scope::prepareShutdown()
+{
+	if (values)
+		values->prepareShutdown();
+	if (!parent.isNull())
+		parent->prepareShutdown();
+}
diff -u -r -N lightspark-0.9.0/src/scripting/avm1/scope.h lightspark-master/src/scripting/avm1/scope.h
--- lightspark-0.9.0/src/scripting/avm1/scope.h	1970-01-01 01:00:00.000000000 +0100
+++ lightspark-master/src/scripting/avm1/scope.h	2025-03-05 20:13:02.164865178 +0100
@@ -0,0 +1,300 @@
+/**************************************************************************
+    Lightspark, a free flash player implementation
+
+    Copyright (C) 2025  mr b0nk 500 (b0nk@b0nk.xyz)
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+**************************************************************************/
+
+#ifndef SCRIPTING_AVM1_SCOPE_H
+#define SCRIPTING_AVM1_SCOPE_H 1
+
+#include "forwards/asobject.h"
+#include "forwards/scripting/flash/display/DisplayObject.h"
+#include "forwards/scripting/flash/system/flashsystem.h"
+#include "forwards/scripting/toplevel/Global.h"
+#include "forwards/swftypes.h"
+#include "smartrefs.h"
+
+// Based on Ruffle's `avm1::scope::Scope`.
+
+namespace lightspark
+{
+
+union asAtom;
+struct garbagecollectorstate;
+struct multiname;
+class ASObject;
+//enum ASObject::CONST_ALLOWED_FLAG;
+class ASWorker;
+class DisplayObject;
+class Global;
+enum GET_VARIABLE_RESULT;
+template<typename T>
+class Optional;
+
+// The type of scope.
+enum class AVM1ScopeClass
+{
+	// The global scope.
+	Global,
+
+	// A timeline scope. All timeline actions run with the current clip
+	// object, instead of a local scope. The timeline scope can be
+	// changed with `tellTarget()`.
+	Target,
+
+	// A local scope. Local scopes are inherited whenever a closure is
+	// defined.
+	Local,
+
+	// A scope that's been created using `with`. `with` scopes aren't
+	// inherited when closures are defined.
+	With,
+};
+
+// The scope chain of an AVM1 context.
+class AVM1Scope : public RefCountable
+{
+private:
+	_NR<AVM1Scope> parent;
+	AVM1ScopeClass _class;
+	_NR<ASObject> values;
+
+	// Replaces the current local scope object with another object.
+	void setLocals(const _R<ASObject>& newLocals)
+	{
+		if (values)
+		{
+			values->removeStoredMember();
+			values.fakeRelease();
+		}
+
+		newLocals->addStoredMember();
+
+		values = newLocals;
+	}
+public:
+	// Contructs/Creates an arbitrary scope.
+	AVM1Scope
+	(
+		_NR<AVM1Scope> _parent,
+		const AVM1ScopeClass& type,
+		const _NR<ASObject>& _values
+	) : parent(_parent), _class(type), values(_values)
+	{
+		values->addStoredMember();
+	}
+
+	// Constructs a global scope (A parentless scope).
+	AVM1Scope(const _R<Global>& globals);
+
+	// Constructs a target/timeline scope.
+	AVM1Scope(const _R<AVM1Scope>& _parent, const _R<DisplayObject>& clip);
+
+	// Constructs a child/local scope of another scope.
+	AVM1Scope(const _R<AVM1Scope>& _parent, ASWorker* wrk);
+
+	// Constructs a `with` scope, used as the scope in a `with` block.
+	//
+	// `with` blocks add an object to the top of the scope chain, so that
+	// unqualified references will attempt to resolve that object first.
+	AVM1Scope
+	(
+		const _R<AVM1Scope>& parent,
+		const _R<ASObject>& withObj
+	) : AVM1Scope(parent, AVM1ScopeClass::With, withObj) {}
+
+	AVM1Scope(const AVM1Scope& other) : AVM1Scope
+	(
+		other.parent,
+		other._class,
+		NullRef
+	)
+	{
+		setLocals(other.values);
+	}
+
+	AVM1Scope& operator=(const AVM1Scope& other)
+	{
+		parent = other.parent;
+		_class = other._class;
+		setLocals(other.values);
+		return *this;
+	}
+
+	~AVM1Scope()
+	{
+		ASObject* o = values.getPtr();
+		values.fakeRelease();
+		if (o)
+			o->removeStoredMember();
+	}
+
+	// Creates a global scope (A parentless scope).
+	static AVM1Scope makeGlobalScope(const _R<Global>& globals)
+	{
+		return AVM1Scope(globals);
+	}
+
+	// Creates a child/local scope of another scope.
+	static AVM1Scope makeLocalScope(const _R<AVM1Scope>& parent, ASWorker* wrk)
+	{
+		return AVM1Scope(parent, wrk);
+	}
+
+	// Creates a target/timeline scope.
+	static AVM1Scope makeTargetScope(const _R<AVM1Scope>& parent, const _R<DisplayObject>& clip)
+	{
+		return AVM1Scope(parent, clip);
+	}
+
+	// Creates a `with` scope, used as the scope in a `with` block.
+	//
+	// `with` blocks add an object to the top of the scope chain, so that
+	// unqualified references will attempt to resolve that object first.
+	static AVM1Scope makeWithScope(const _R<AVM1Scope>& parent, const _R<ASObject>& withObj)
+	{
+		return AVM1Scope(parent, withObj);
+	}
+
+	// Replaces the target/timeline scope with another object.
+	void setTargetScope(const _R<DisplayObject>& clip);
+
+	// Returns the parent scope.
+	_NR<AVM1Scope> getParent() const { return parent; }
+	const AVM1Scope* getParentPtr() const { return parent.getPtr(); }
+	AVM1Scope* getParentPtr() { return parent.getPtr(); }
+
+	// Returns the current local scope object.
+	_R<ASObject> getLocals() const { return values; }
+	const ASObject* getLocalsPtr() const { return values.getPtr(); }
+	ASObject* getLocalsPtr() { return values.getPtr(); }
+
+	// Returns the class type.
+	AVM1ScopeClass getClass() const { return _class; }
+
+	bool isGlobalScope() const { return _class == AVM1ScopeClass::Global; }
+	bool isTargetScope() const { return _class == AVM1ScopeClass::Target; }
+	bool isLocalScope() const { return _class == AVM1ScopeClass::Local; }
+	bool isWithScope() const { return _class == AVM1ScopeClass::With; }
+
+	template<typename F>
+	void forEachScope(F&& callback) const
+	{
+		if (callback(*this) && !parent.isNull())
+			parent->forEachScope(callback);
+	}
+
+	template<typename F>
+	void forEachScope(F&& callback)
+	{
+		if (callback(*this) && !parent.isNull())
+			parent->forEachScope(callback);
+	}
+
+	// Gets/Resolves a specific variable on the scope chain.
+	//
+	// Since scopes are just object chains, the same rules for
+	// `ASObject::AVM1getVariableByMultiname` still apply here.
+	asAtom getVariableByMultiname
+	(
+		DisplayObject* baseClip,
+		const multiname& name,
+		const GET_VARIABLE_OPTION& options,
+		ASWorker* wrk
+	)
+	{
+		return resolveRecursiveByMultiname(baseClip, name, options, wrk, true);
+	}
+
+	// Recursively resolve a variable on the scope chain.
+	// See `AVM1Scope::getVariableByMultiname` for details.
+	asAtom resolveRecursiveByMultiname
+	(
+		DisplayObject* baseClip,
+		const multiname& name,
+		const GET_VARIABLE_OPTION& options,
+		ASWorker* wrk,
+		bool isTopLevel
+	);
+
+	// Sets a specific variable on the scope chain.
+	//
+	// This traverses the scope chain, in search of a variable. If a
+	// variable already exists, it get's overwritten. The traversal
+	// ends when a target scope is reached, which represents the
+	// `MovieClip` timeline the code is executing in.
+	// If no variable is found, it'll be created in the current
+	// target scope.
+	bool setVariableByMultiname
+	(
+		multiname& name,
+		asAtom& value,
+		const ASObject::CONST_ALLOWED_FLAG& allowConst,
+		ASWorker* wrk
+	);
+
+	// Defines a named local variable on the scope.
+	//
+	// If the variable doesn't exist on the local scope, it'll be created.
+	// Otherwise, the existing variable will be set to `value`, which
+	// doesn't traverse the scope chain. Any variables that have the same
+	// name, but are deeper in the chain get shadowed.
+	bool defineLocalByMultiname
+	(
+		multiname& name,
+		asAtom& value,
+		const ASObject::CONST_ALLOWED_FLAG& allowConst,
+		ASWorker* wrk
+	);
+
+	// Creates a local variable on the activation.
+	//
+	// This inserts the value as a stored variable on the local
+	// scope. If the variable already exists, it'll be forcefully
+	// overwritten. Used internally for initializing objects.
+	bool forceDefineLocalByMultiname
+	(
+		multiname& name,
+		asAtom& value,
+		const ASObject::CONST_ALLOWED_FLAG& allowConst,
+		ASWorker* wrk
+	);
+
+	bool forceDefineLocal
+	(
+		const tiny_string& name,
+		asAtom& value,
+		const ASObject::CONST_ALLOWED_FLAG& allowConst,
+		ASWorker* wrk
+	);
+
+	bool forceDefineLocal
+	(
+		uint32_t nameID,
+		asAtom& value,
+		const ASObject::CONST_ALLOWED_FLAG& allowConst,
+		ASWorker* wrk
+	);
+
+	// Deletes a variable from the scope.
+	bool deleteVariableByMultiname(const multiname& name, ASWorker* wrk);
+
+	bool countAllCyclicMemberReferences(garbagecollectorstate& gcstate);
+	void prepareShutdown();
+};
+
+}
+#endif /* SCRIPTING_AVM1_SCOPE_H */
diff -u -r -N lightspark-0.9.0/src/scripting/avm1_interpreter.cpp lightspark-master/src/scripting/avm1_interpreter.cpp
--- lightspark-0.9.0/src/scripting/avm1_interpreter.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/avm1_interpreter.cpp	2025-03-05 20:13:02.164865178 +0100
@@ -21,12 +21,15 @@
 #include "scripting/class.h"
 #include "scripting/flash/geom/Rectangle.h"
 #include "scripting/flash/display/flashdisplay.h"
+#include "scripting/flash/system/flashsystem.h"
+#include "scripting/flash/errors/flasherrors.h"
 #include "scripting/toplevel/toplevel.h"
 #include "scripting/toplevel/AVM1Function.h"
 #include "scripting/toplevel/Global.h"
 #include "scripting/toplevel/Number.h"
 #include "scripting/avm1/avm1display.h"
 #include "scripting/avm1/avm1array.h"
+#include "scripting/avm1/scope.h"
 #include "parsing/tags.h"
 #include "backends/audio.h"
 
@@ -52,6 +55,491 @@
 		throw RunTimeException("AVM1: empty stack");
 	return stack.top();
 }
+AVM1context::AVM1context():keepLocals(true), callDepth(0), actionsExecuted(0),swfversion(0),
+	exceptionthrown(nullptr), callee(nullptr),scope(NullRef),globalScope(NullRef)
+{
+}
+
+AVM1context::AVM1context(const _R<DisplayObject>& target, SystemState* sys) :
+keepLocals(true),
+callDepth(0),
+actionsExecuted(0),
+swfversion(target->loadedFrom->version),
+exceptionthrown(nullptr),
+callee(nullptr),
+globalScope(_MNR(new AVM1Scope(_MR(sys->avm1global))))
+{
+	scope = _MNR(new AVM1Scope(globalScope, target));
+}
+
+AVM1context::~AVM1context()
+{
+}
+
+// Based on Ruffle's `avm1::activation::Activation::resolve_target_path()`.
+ASObject* AVM1context::resolveTargetPath
+(
+	const asAtom& thisObj,
+	DisplayObject* baseClip,
+	DisplayObject* root,
+	const _R<ASObject>& start,
+	const tiny_string& _path,
+	bool hasSlash,
+	bool first
+) const
+{
+	auto path = _path;
+	// An empty path resolves to the starting clip.
+	if (path.empty())
+	{
+		start->incRef();
+		return start.getPtr();
+	}
+
+	ASObject* obj = start.getPtr();
+	bool isSlashPath;
+	// A starting `/` means we have an absolute path, starting from the
+	// root. e.g. `/foo` == `_root.foo`.
+	if ((isSlashPath = path.startsWith("/")))
+	{
+		path = path.substr(1, UINT32_MAX);
+		obj = root;
+	}
+
+	while (!path.empty())
+	{
+		// Skip over any leading `:`s.
+		// e.g. `:foo`, and `::foo` are the same as `foo`.
+		path = path.trimStartMatches(':');
+
+		asAtom val = asAtomHandler::invalidAtom;
+		auto clip = obj->is<DisplayObject>() ? obj->as<DisplayObject>() : nullptr;
+
+		uint32_t ch = path.numChars() >= 3 ? path[2] : '\0';
+		// Check for an SWF 4 `_parent` path (`..[/:]`).
+		if (path.startsWith("..") && (ch == '\0' || ch == '/' || ch == ':'))
+		{
+			// SWF 4 style `_parent` path.
+			isSlashPath = ch == '/';
+			path = path.stripPrefix("..", ch != '\0');
+
+			if (clip == nullptr || clip->getParent() == nullptr)
+			{
+				// Tried to get the parent of a root clip, bail early.
+				return nullptr;
+			}
+
+			bool isStage = clip->getParent()->is<Stage>();
+			auto parent = isStage ? clip->AVM1getRoot() : clip->getParent();
+
+			val = asAtomHandler::fromObject(parent);
+		}
+		else
+		{
+			// Find the next delimiter.
+			// `:`, `.`, and `/` are all valid path delimiters, with the
+			// only restriction being that a `.` isn't considered a valid
+			// delimiter after a `/` appears.
+			size_t i;
+			bool done;
+			for (i = 0, done = false; i < path.numChars(); ++i)
+			{
+				switch (path[i])
+				{
+					case '/': isSlashPath = true;
+					// Falls through.
+					case ':': done = true; break;
+					case '.': done = !isSlashPath; break;
+					default: done = false; break;
+				}
+				if (done)
+					break;
+			}
+
+			auto name = path.substr(0, i);
+			path = path.substr(std::min(uint32_t(i + 1), path.numChars()), UINT32_MAX);
+
+			if (first && name == "this")
+				val = thisObj;
+			else if (first && name == "_root")
+				val = asAtomHandler::fromObject(baseClip->AVM1getRoot());
+			else
+			{
+				// Try to get the value from the object.
+				// NOTE: This resolves `DisplayObject`s first, and then
+				// locals, which is the opposite of what `ActionGetMember`'s
+				// property access does.
+				auto child =
+				(
+					obj->is<DisplayObjectContainer>() ?
+					obj->as<DisplayObjectContainer>()->getLegacyChildByName
+					(
+						name,
+						isCaseSensitive()
+					) : nullptr
+				);
+
+				if (child != nullptr)
+				{
+					// NOTE: If the object can't be represented as an
+					// AVM1 object, such as `Shape`, then any attempt to
+					// access it will return the parent instead.
+					if (!hasSlash && child->is<Shape>())
+						val = asAtomHandler::fromObject(child->getParent());
+					else
+						val = asAtomHandler::fromObject(child);
+				}
+				else
+				{
+					auto sys = baseClip->getSystemState();
+					multiname objName(nullptr);
+					objName.name_type = multiname::NAME_STRING;
+					objName.name_s_id = sys->getUniqueStringId(name, isCaseSensitive());
+					obj->AVM1getVariableByMultiname
+					(
+						val,
+						objName,
+						GET_VARIABLE_OPTION::NO_INCREF,
+						baseClip->getInstanceWorker(),
+						hasSlash
+					);
+				}
+			}
+		}
+
+		// NOTE: `this`, and `_root` are only allowed at the start of
+		// the path.
+		first = false;
+
+		// Convert the atom into an object, while we're traversing the path.
+		if (asAtomHandler::isObjectPtr(val))
+			obj = asAtomHandler::getObjectNoCheck(val);
+		else
+			return nullptr;
+	}
+
+	obj->incRef();
+	return obj;
+}
+
+// Based on Ruffle's `avm1::activation::Activation::resolve_variable_path()`.
+std::pair<ASObject*, tiny_string> AVM1context::resolveVariablePath
+(
+	const asAtom& thisObj,
+	DisplayObject* baseClip,
+	const _R<DisplayObject>& clip,
+	const tiny_string& path
+) const
+{
+	auto sys = clip->getSystemState();
+	auto wrk = clip->getInstanceWorker();
+
+	bool pathHasSlash = path.contains('/');
+
+	// Find the last `:`, or `.` in the path.
+	// If we've got one, then it must be resolved as a target path.
+	auto pos = path.findLast(":.");
+	if (pos != tiny_string::npos)
+	{
+		// We've got a `:`, or `.`, meaning it's an object path, and a
+		// variable name. Which has to be resolved directly on the target
+		// object.
+		auto varPath = path.substr(0, pos);
+		auto varName = path.substr(pos + 1, UINT32_MAX);
+		auto root = clip->AVM1getRoot();
+
+		multiname m(nullptr);
+		m.name_type = multiname::NAME_STRING;
+		m.isAttribute = false;
+		m.name_s_id = sys->getUniqueStringId(varName, isCaseSensitive());
+
+		ASObject* obj = nullptr;
+		scope->forEachScope([&](const AVM1Scope& scope)
+		{
+			obj = resolveTargetPath
+			(
+				thisObj,
+				baseClip,
+				root,
+				scope.getLocals(),
+				varPath,
+				pathHasSlash
+			);
+
+			if (obj == nullptr || !obj->hasPropertyByMultiname(m, true, true, wrk))
+			{
+				if (obj != nullptr)
+					obj->decRef();
+				obj = nullptr;
+				return true;
+			}
+
+			return false;
+		});
+		if (obj != nullptr)
+			return std::make_pair(obj, varName);
+		return std::make_pair(nullptr, "");
+	}
+
+	// It's a normal variable name.
+	// Return the starting clip, and path.
+	clip->incRef();
+	return std::make_pair(clip.getPtr(), path);
+}
+
+// Based on Ruffle's `avm1::activation::Activation::get_variable()`.
+asAtom AVM1context::getVariable
+(
+	const asAtom& thisObj,
+	DisplayObject* baseClip,
+	DisplayObject* clip,
+	const tiny_string& path
+) const
+{
+	// Try to resolve a variable path for `ActionGetVariable`.
+	if (clip == nullptr)
+		clip = baseClip->AVM1getRoot();
+
+	auto sys = clip->getSystemState();
+	auto wrk = clip->getInstanceWorker();
+
+	bool pathHasSlash = path.contains('/');
+
+	// Find the last `:`, or `.` in the path.
+	// If we've got one, then it must be resolved as a target path.
+	auto pos = path.findLast(":.");
+	if (pos != tiny_string::npos)
+	{
+		// We've got a `:`, or `.`, meaning it's an object path, and a
+		// variable name. Which has to be resolved directly on the target
+		// object.
+		auto varPath = path.substr(0, pos);
+		auto varName = path.substr(pos + 1, UINT32_MAX);
+		auto root = clip->AVM1getRoot();
+
+		multiname m(nullptr);
+		m.name_type = multiname::NAME_STRING;
+		m.isAttribute = false;
+		m.name_s_id = sys->getUniqueStringId(varName, isCaseSensitive());
+
+		asAtom ret = asAtomHandler::invalidAtom;
+		scope->forEachScope([&](const AVM1Scope& scope)
+		{
+			auto obj = resolveTargetPath
+			(
+				thisObj,
+				baseClip,
+				root,
+				scope.getLocals(),
+				varPath,
+				pathHasSlash
+			);
+
+			if (obj == nullptr || !obj->hasPropertyByMultiname(m, true, true, wrk))
+			{
+				if (obj != nullptr)
+					obj->decRef();
+				return true;
+			}
+
+			obj->AVM1getVariableByMultiname
+			(
+				ret,
+				m,
+				GET_VARIABLE_OPTION::NONE,
+				wrk
+			);
+			return false;
+		});
+		if (asAtomHandler::isValid(ret))
+			return ret;
+		return asAtomHandler::undefinedAtom;
+	}
+
+	// If the path doesn't have a trailing variable, it could still be a
+	// slash path.
+	if (pathHasSlash)
+	{
+		auto root = clip->AVM1getRoot();
+
+		asAtom ret = asAtomHandler::invalidAtom;
+		scope->forEachScope([&](const AVM1Scope& scope)
+		{
+			auto obj = resolveTargetPath
+			(
+				thisObj,
+				baseClip,
+				root,
+				scope.getLocals(),
+				path,
+				true,
+				pathHasSlash
+			);
+
+			if (obj == nullptr)
+				return true;
+
+			obj->incRef();
+			ret = asAtomHandler::fromObject(obj);
+			return false;
+		});
+
+		if (asAtomHandler::isValid(ret))
+			return ret;
+	}
+
+	if (path == "this")
+	{
+		ASATOM_INCREF(thisObj);
+		return thisObj;
+	}
+
+	multiname m(nullptr);
+	m.name_type = multiname::NAME_STRING;
+	m.isAttribute = false;
+	m.name_s_id = sys->getUniqueStringId
+	(
+		path,
+		isCaseSensitive()
+	);
+
+	// It's a normal variable name.
+	// Resolve it using the scope chain.
+	auto atom = scope->getVariableByMultiname
+	(
+		baseClip,
+		m,
+		GET_VARIABLE_OPTION::NONE,
+		wrk
+	);
+
+	if (asAtomHandler::isValid(atom))
+		return atom;
+
+	// If variable resolution on the scope chain failed, then fallback
+	// to looking in either the target, or root clip.
+	if (!clip->hasPropertyByMultiname(m, true, true, wrk))
+		return asAtomHandler::undefinedAtom;
+
+	clip->AVM1getVariableByMultiname
+	(
+		atom,
+		m,
+		GET_VARIABLE_OPTION::NONE,
+		wrk
+	);
+
+	if (asAtomHandler::isValid(atom))
+		return atom;
+	return asAtomHandler::undefinedAtom;
+}
+
+// Based on Ruffle's `avm1::activation::Activation::set_variable()`.
+void AVM1context::setVariable
+(
+	asAtom& thisObj,
+	DisplayObject* baseClip,
+	DisplayObject* clip,
+	const tiny_string& path,
+	const asAtom& value
+)
+{
+	// Try to resolve a variable path for `ActionSetVariable`.
+	if (clip == nullptr)
+		clip = baseClip->AVM1getRoot();
+
+	auto sys = clip->getSystemState();
+	auto wrk = clip->getInstanceWorker();
+
+	bool pathHasSlash = path.contains('/');
+
+	// If the path is empty, default to using the root clip for the
+	// variable path.
+	if (path.empty())
+		return;
+
+	// Special case for mutating `this`.
+	if (path == "this")
+	{
+		ASATOM_DECREF(thisObj);
+		ASATOM_INCREF(value);
+		thisObj = value;
+		return;
+	}
+
+	// Find the last `:`, or `.` in the path.
+	// If we've got one, then it must be resolved as a target path.
+	auto pos = path.findLast(":.");
+	if (pos != tiny_string::npos)
+	{
+		// We've got a `:`, or `.`, meaning it's an object path, and a
+		// variable name. Which has to be resolved directly on the target
+		// object.
+		auto varPath = path.substr(0, pos);
+		auto varName = path.substr(pos + 1, UINT32_MAX);
+		auto root = clip->AVM1getRoot();
+
+		multiname m(nullptr);
+		m.name_type = multiname::NAME_STRING;
+		m.isAttribute = false;
+		m.name_s_id = sys->getUniqueStringId(varName, isCaseSensitive());
+
+		scope->forEachScope([&](const AVM1Scope& scope)
+		{
+			auto obj = resolveTargetPath
+			(
+				thisObj,
+				baseClip,
+				root,
+				scope.getLocals(),
+				varPath,
+				true,
+				pathHasSlash
+			);
+
+			if (obj == nullptr || !obj->hasPropertyByMultiname(m, true, true, wrk))
+			{
+				if (obj)
+					obj->decRef();
+				return true;
+			}
+
+			bool alreadySet = obj->AVM1setVariableByMultiname
+			(
+				m,
+				(asAtom&)value,
+				ASObject::CONST_ALLOWED,
+				wrk
+			);
+			if (alreadySet)
+				ASATOM_DECREF(value)
+			obj->decRef();
+			return false;
+		});
+
+		return;
+	}
+
+	multiname m(nullptr);
+	m.name_type = multiname::NAME_STRING;
+	m.isAttribute = false;
+	m.name_s_id = sys->getUniqueStringId(path, isCaseSensitive());
+
+	// It's a normal variable name. Set it using the scope chain.
+	// This will overwrite the value, if the property already exists in
+	// the scope chain, otherwise, it's created on the top level object.
+	bool alreadySet = scope->setVariableByMultiname
+	(
+		m,
+		(asAtom&)value,
+		ASObject::CONST_ALLOWED,
+		wrk
+	);
+
+	if (alreadySet)
+		ASATOM_DECREF(value)
+}
+
 struct tryCatchBlock
 {
 	uint16_t trysize;
@@ -62,27 +550,71 @@
 	uint32_t startpos;
 };
 Mutex executeactionmutex;
-void ACTIONRECORD::executeActions(DisplayObject *clip, AVM1context* context, const std::vector<uint8_t> &actionlist, uint32_t startactionpos, std::map<uint32_t, asAtom> &scopevariables, bool fromInitAction, asAtom* result, asAtom* obj, asAtom *args, uint32_t num_args, const std::vector<uint32_t>& paramnames, const std::vector<uint8_t>& paramregisternumbers,
-								  bool preloadParent, bool preloadRoot, bool suppressSuper, bool preloadSuper, bool suppressArguments, bool preloadArguments, bool suppressThis, bool preloadThis, bool preloadGlobal, AVM1Function *caller, AVM1Function *callee, Activation_object *actobj, asAtom *superobj)
+void ACTIONRECORD::executeActions(DisplayObject *clip, AVM1context* context, const std::vector<uint8_t> &actionlist,
+								  uint32_t startactionpos, AVM1Scope* scope, bool fromInitAction,
+								  asAtom* result, asAtom* obj, asAtom *args, uint32_t num_args,
+								  const std::vector<uint32_t>& paramnames,
+								  const std::vector<uint8_t>& paramregisternumbers,
+								  bool preloadParent, bool preloadRoot, bool suppressSuper,
+								  bool preloadSuper, bool suppressArguments, bool preloadArguments,
+								  bool suppressThis, bool preloadThis, bool preloadGlobal,
+								  AVM1Function *caller, AVM1Function *callee,
+								  Activation_object *actobj, asAtom *superobj,bool isInternalCall)
 {
 	Locker l(executeactionmutex);
 	bool clip_isTarget=false;
 	assert(!clip->needsActionScript3());
-	ASWorker* wrk = clip->getSystemState()->worker;
+	SystemState* sys = clip->getSystemState();
+	ASWorker* wrk = sys->worker;
+	wrk->AVM1_cur_recursion_function++;
+	if (isInternalCall)
+		wrk->AVM1_cur_recursion_internal++;
+
 	if (context->callDepth == 0)
 		context->startTime = compat_now();
-	if (context->callDepth >= wrk->limits.max_recursion - 1)
+	if (context->callDepth >= wrk->limits.max_recursion - 1 ||
+		wrk->AVM1_cur_recursion_internal > AVM1_RECURSION_LIMIT_INTERN)
 	{
-		std::stringstream s;
-		s << "Reached maximum function recursion limit of " << wrk->limits.max_recursion;
-		throw ScriptLimitException
-		(
-			s.str(),
-			ScriptLimitException::MaxFunctionRecursion
-		);
+		if (!context->exceptionthrown)
+			wrk->throwStackOverflow();
+		return;
 	}
 	context->swfversion=clip->loadedFrom->version;
 	context->callee = callee;
+
+	if (context->globalScope.isNull())
+	{
+		auto global = clip->getSystemState()->avm1global;
+		context->globalScope = _MNR(new AVM1Scope(_MR(global)));
+	}
+
+	bool isClosure = context->swfversion >= 6;
+
+	if (!isClosure || !scope)
+		clip->incRef();
+	// NOTE: In SWF 5, function calls aren't closures, and always create
+	// a new target scope, regardless of the function's origin.
+	_NR<AVM1Scope> parentScope;
+	if (isClosure && scope)
+	{
+		scope->incRef();
+		parentScope = _MNR(scope);
+	}
+	else
+	{
+		parentScope = _MNR(new AVM1Scope
+		(
+			context->globalScope,
+			_MR(clip)
+		));
+	}
+
+	// Local scopes are only created for function calls.
+	context->scope = !scope ? parentScope : _MNR
+	(
+		new AVM1Scope(parentScope, wrk)
+	);
+
 	wrk->AVM1callStack.push_back(context);
 	context->callDepth++;
 	Log::calls_indent++;
@@ -92,27 +624,24 @@
 	std::stack<asAtom> stack;
 	asAtom registers[256];
 	std::fill_n(registers,256,asAtomHandler::undefinedAtom);
-	std::map<uint32_t,asAtom> locals;
-	if (caller)
-		caller->filllocals(locals);
 	int curdepth = 0;
-	int maxdepth= clip->loadedFrom->version < 6 ? 8 : 16;
-	asAtom* scopestack = g_newa(asAtom, maxdepth);
-	scopestack[0] = obj ? *obj : asAtomHandler::fromObject(clip);
-	ASATOM_INCREF(scopestack[0]);
+	int maxdepth = context->swfversion < 6 ? 8 : 16;
+	auto thisObj = obj != nullptr ? *obj : asAtomHandler::fromObject(clip);
 	std::vector<uint8_t>::const_iterator* scopestackstop = g_newa(std::vector<uint8_t>::const_iterator, maxdepth);
 	scopestackstop[0] = actionlist.end();
 	uint32_t currRegister = 1; // spec is not clear, but gnash starts at register 1
 	if (!suppressThis || preloadThis)
 	{
-		LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" preload this:"<<asAtomHandler::toDebugString(scopestack[0]));
+		LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" preload this:"<<asAtomHandler::toDebugString(thisObj));
 		if (!suppressThis)
-			ASATOM_INCREF(scopestack[0]);
-		registers[currRegister++] = !suppressThis ? scopestack[0] : asAtomHandler::undefinedAtom;
+			ASATOM_INCREF(thisObj);
+		registers[currRegister++] = !suppressThis ? thisObj : asAtomHandler::undefinedAtom;
 	}
+
+	AVM1Array* argsArray = nullptr;
 	if (!suppressArguments || preloadArguments)
 	{
-		AVM1Array* argsArray = Class<AVM1Array>::getInstanceS(wrk);
+		argsArray = Class<AVM1Array>::getInstanceS(wrk);
 		argsArray->resize(num_args);
 		for (uint32_t i = 0; i < num_args; i++)
 		{
@@ -140,19 +669,20 @@
 			argsArray->setVariableAtomByQName("callee", tmpns, c, DYNAMIC_TRAIT, false, 5);
 		}
 
+		argsArray->incRef();
+		auto argsAtom = asAtomHandler::fromObject(argsArray);
 		if (preloadArguments)
-			registers[currRegister++] = asAtomHandler::fromObject(argsArray);
+			registers[currRegister++] = argsAtom;
 		else
 		{
-			auto argumentsStr = clip->getSystemState()->getUniqueStringId("arguments");
-			locals[argumentsStr] = asAtomHandler::fromObject(argsArray);
-
-			for (uint32_t i = 0; i < paramnames.size() && i < num_args; i++)
-			{
-				ASATOM_INCREF(args[i]);
-				ASATOM_DECREF(locals[paramnames[i]]);
-				locals[paramnames[i]] = args[i];
-			}
+			if (context->scope->forceDefineLocal
+			(
+				"arguments",
+				argsAtom,
+				ASObject::CONST_ALLOWED,
+				wrk
+			))
+				argsArray->decRef();
 		}
 	}
 	asAtom super = asAtomHandler::invalidAtom;
@@ -160,24 +690,30 @@
 	{
 		if (superobj && asAtomHandler::isObject(*superobj))
 		{
-			LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" super for "<<asAtomHandler::toDebugString(scopestack[0])<<" "<<asAtomHandler::toDebugString(*superobj));
+			LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" super for "<<asAtomHandler::toDebugString(thisObj)<<" "<<asAtomHandler::toDebugString(*superobj));
 			super.uintval=superobj->uintval;
 		}
 		if (asAtomHandler::isInvalid(super))
-			LOG(LOG_ERROR,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" no super class found for "<<asAtomHandler::toDebugString(scopestack[0]));
-		ASATOM_INCREF(super);
+			LOG(LOG_ERROR,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" no super class found for "<<asAtomHandler::toDebugString(thisObj));
 		if (preloadSuper)
 		{
 			// NOTE: The `super` register is set to `undefined`, if both
 			// flags are set.
+			if (!suppressSuper)
+				ASATOM_INCREF(super);
 			registers[currRegister++] = (!suppressSuper) ? super : asAtomHandler::undefinedAtom;
 		}
 		else
 		{
-			auto superStr = clip->getSystemState()->getUniqueStringId("super");
-			if (locals.find(superStr) != locals.end())
-				ASATOM_DECREF(locals[superStr]);
-			locals[superStr] = super;
+			ASATOM_INCREF(super);
+			if (context->scope->forceDefineLocal
+			(
+				BUILTIN_STRINGS::STRING_SUPER,
+				super,
+				ASObject::CONST_ALLOWED,
+				wrk
+			))
+				ASATOM_DECREF(super);
 		}
 	}
 	if (preloadRoot)
@@ -202,34 +738,43 @@
 		clip->getSystemState()->avm1global->incRef();
 		registers[currRegister++] = asAtomHandler::fromObject(clip->getSystemState()->avm1global);
 	}
-	for (uint32_t i = 0; i < paramregisternumbers.size() && i < num_args; i++)
+	for (uint32_t i = 0; i < paramnames.size() && i < num_args; i++)
 	{
-		LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" set argument "<<i<<" "<<(int)paramregisternumbers[i]<<" "<<clip->getSystemState()->getStringFromUniqueId(paramnames[i])<<" "<<asAtomHandler::toDebugString(args[i]));
-		ASATOM_INCREF(args[i]);
-		ASATOM_DECREF(locals[paramnames[i]]);
-		locals[paramnames[i]] = args[i];
-		if (context->keepLocals)
+		auto reg = i < paramregisternumbers.size() ? paramregisternumbers[i] : 0;
+		LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" set argument "<<i<<" "<<(int)reg<<" "<<clip->getSystemState()->getStringFromUniqueId(paramnames[i])<<" "<<asAtomHandler::toDebugString(args[i]));
+
+		if (reg != 0)
 		{
 			ASATOM_INCREF(args[i]);
-			tiny_string s = clip->getSystemState()->getStringFromUniqueId(paramnames[i]).lowercase();
-			clip->AVM1SetVariable(s,args[i],false);
+			ASATOM_DECREF(registers[reg]);
+			registers[reg] = args[i];
 		}
-		if (paramregisternumbers[i] != 0)
+		else
 		{
 			ASATOM_INCREF(args[i]);
-			ASATOM_DECREF(registers[paramregisternumbers[i]]);
-			registers[paramregisternumbers[i]] = args[i];
+			if (context->scope->forceDefineLocal
+			(
+				paramnames[i],
+				args[i],
+				ASObject::CONST_ALLOWED,
+				wrk
+			))
+				ASATOM_DECREF(args[i]);
 		}
 	}
 	std::vector<tryCatchBlock> trycatchblocks;
 	bool inCatchBlock = false;
 
-	AVM1Array* argarray = nullptr;
 	DisplayObject *originalclip = clip;
 	auto it = actionlist.begin()+startactionpos;
 	auto tryblockstart = actionlist.end();
 	while (it != actionlist.end())
 	{
+		if (wrk->AVM1_cur_recursion_internal <= AVM1_RECURSION_LIMIT_INTERN && context->exceptionthrown && context->exceptionthrown->is<StackOverflowError>())
+		{
+			// stackoverflow exceptions on non-internal calls are never caught
+			break;
+		}
 		if (!(context->actionsExecuted % 2000))
 		{
 			auto delta = compat_now() - context->startTime;
@@ -253,9 +798,22 @@
 				it = tryblockstart + trycatchblock.trysize;
 				if (!trycatchblock.name.empty())
 				{
-					uint32_t nameID = clip->getSystemState()->getUniqueStringId(trycatchblock.name.lowercase());
-					ASATOM_DECREF(locals[nameID]);
-					locals[nameID] = asAtomHandler::fromObject(context->exceptionthrown);
+					uint32_t nameID = sys->getUniqueStringId
+					(
+						trycatchblock.name,
+						context->isCaseSensitive()
+					);
+					auto e = asAtomHandler::fromObject(context->exceptionthrown);
+					multiname m(nullptr);
+					m.name_type = multiname::NAME_STRING;
+					m.name_s_id = nameID;
+					context->scope->setVariableByMultiname
+					(
+						m,
+						e,
+						ASObject::CONST_ALLOWED,
+						wrk
+					);
 				}
 				else if(trycatchblock.reg != UINT8_MAX)
 				{
@@ -286,10 +844,8 @@
 		}
 		while (curdepth > 0 && it == scopestackstop[curdepth])
 		{
-			LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" end with "<<asAtomHandler::toDebugString(scopestack[curdepth]));
-			if (asAtomHandler::is<DisplayObject>(scopestack[curdepth]))
-				clip = originalclip;
-			ASATOM_DECREF(scopestack[curdepth]);
+			LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" end with "<<context->scope->getLocalsPtr()->toDebugString());
+			context->scope = context->scope->getParent();
 			curdepth--;
 			Log::calls_indent--;
 		}
@@ -528,142 +1084,8 @@
 			{
 				asAtom name = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionGetVariable "<<asAtomHandler::toDebugString(name));
-				tiny_string s = asAtomHandler::toString(name,wrk);
-				asAtom res=asAtomHandler::invalidAtom;
-				if (s=="this")
-				{
-					if(asAtomHandler::isValid(scopestack[curdepth]))
-						res = scopestack[curdepth];
-					else
-						res = asAtomHandler::fromObject(clip);
-					ASATOM_INCREF(res);
-				}
-				else if (s == "_global")
-				{
-					res = asAtomHandler::fromObjectNoPrimitive(clip->getSystemState()->avm1global);
-					ASATOM_INCREF(res);
-				}
-				else if (s.numBytes()>6 && s.startsWith("_level"))
-				{
-					if (s.numBytes() == 7 && s.charAt(6)=='0')
-						res = asAtomHandler::fromObjectNoPrimitive(clip->loadedFrom);
-					else
-						LOG(LOG_NOT_IMPLEMENTED,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionGetVariable for "<<s);
-					ASATOM_INCREF(res);
-				}
-				else if (context->keepLocals && s.find(".") == tiny_string::npos)
-				{
-					uint32_t nameidlower=clip->getSystemState()->getUniqueStringId(s.lowercase());
-					auto it = locals.find(nameidlower);
-					if (it != locals.end()) // local variable
-					{
-						res = it->second;
-						ASATOM_INCREF(res);
-					}
-					else if (!caller)
-					{
-						auto it = clip->avm1locals.find(nameidlower);
-						if (it != clip->avm1locals.end())
-						{
-							res = it->second;
-							ASATOM_INCREF(res);
-						}
-					}
-				}
-				if (asAtomHandler::isInvalid(res) && !clip_isTarget)
-				{
-					if (actobj)
-					{
-						multiname m(nullptr);
-						m.name_type=multiname::NAME_STRING;
-						m.isAttribute = false;
-						m.name_s_id=asAtomHandler::toStringId(name,wrk);
-						actobj->getVariableByMultiname(res,m,GET_VARIABLE_OPTION::NONE,wrk);
-					}
-				}
-				if (asAtomHandler::isInvalid(res) && !clip_isTarget)
-				{
-					if (asAtomHandler::isObject(scopestack[0]))
-					{
-						ASObject* o =asAtomHandler::getObjectNoCheck(scopestack[0]);
-						multiname m(nullptr);
-						m.name_type=multiname::NAME_STRING;
-						m.isAttribute = false;
-						if (s.startsWith("_")) // internal variable names are always lowercase (e.g. "_x","_y"...)
-							m.name_s_id=wrk->getSystemState()->getUniqueStringId(s.lowercase());
-						else
-							m.name_s_id=asAtomHandler::toStringId(name,wrk);
-						o->getVariableByMultiname(res,m,GET_VARIABLE_OPTION::NONE,wrk);
-					}
-				}
-				if (asAtomHandler::isInvalid(res) && !scopevariables.empty())
-				{
-					// scopevariables are locals of the caller, so we have to test case insensitive
-					uint32_t nameID = clip->getSystemState()->getUniqueStringId(s.lowercase());
-					auto it = scopevariables.find(nameID);
-					if (it != scopevariables.end())
-					{
-						res = it->second;
-						ASATOM_INCREF(res);
-					}
-				}
-				if (asAtomHandler::isInvalid(res))
-				{
-					if (!curdepth && !s.startsWith("/") && !s.startsWith(":"))
-					{
-						// first look for member of clip
-						multiname m(nullptr);
-						m.name_type=multiname::NAME_STRING;
-						m.name_s_id=asAtomHandler::toStringId(name,wrk);
-						m.isAttribute = false;
-						if (clip_isTarget)
-						{
-							clip->getVariableByMultiname(res,m,GET_VARIABLE_OPTION::NONE,wrk);
-							if (asAtomHandler::isInvalid(res))
-								res = clip->AVM1GetVariable(s,false);
-						}
-						else
-						{
-							originalclip->getVariableByMultiname(res,m,GET_VARIABLE_OPTION::NONE,wrk);
-							if (asAtomHandler::isInvalid(res))
-								res = originalclip->AVM1GetVariable(s,false);
-						}
-					}
-					else
-						res = clip->AVM1GetVariable(s,false);
-				}
-				if (asAtomHandler::isInvalid(res))
-				{
-					// it seems adobe allows paths in form of "x.y.z" that point to objects in global object
-					tiny_string s1 = s;
-					ASObject* o = clip->getSystemState()->avm1global;
-					multiname m(nullptr);
-					m.name_type=multiname::NAME_STRING;
-					m.isAttribute = false;
-					while (true)
-					{
-						uint32_t pos = s1.find(".");
-						if (pos == tiny_string::npos)
-						{
-							m.name_s_id=clip->getSystemState()->getUniqueStringId(s1);
-							o->getVariableByMultiname(res,m,GET_VARIABLE_OPTION::NONE,wrk);
-							break;
-						}
-						else
-						{
-							tiny_string s2 = s1.substr_bytes(0,pos);
-							s1 = s1.substr_bytes(pos+1,s1.numBytes()-(pos+1));
-							asAtom r = asAtomHandler::invalidAtom;
-							m.name_s_id=clip->getSystemState()->getUniqueStringId(s2);
-							o->getVariableByMultiname(r,m,GET_VARIABLE_OPTION::NONE,wrk);
-							if (asAtomHandler::isInvalid(r))
-								break;
-							o = asAtomHandler::toObject(r,wrk);
-						}
-					}
-				}
-				if (asAtomHandler::isInvalid(res))
-					asAtomHandler::setUndefined(res);
+				auto s = asAtomHandler::AVM1toString(name, wrk);
+				auto res = context->getVariable(thisObj, originalclip, clip, s);
 				ASATOM_DECREF(name);
 				PushStack(stack,res);
 				break;
@@ -673,34 +1095,9 @@
 				asAtom value = PopStack(stack);
 				asAtom name = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionSetVariable "<<asAtomHandler::toDebugString(name)<<" "<<asAtomHandler::toDebugString(value));
-				tiny_string s = asAtomHandler::toString(name,wrk);
+				auto s = asAtomHandler::AVM1toString(name, wrk);
 				ASATOM_DECREF(name);
-				if (context->keepLocals && s.find(".") == tiny_string::npos)
-				{
-					// variable names are case insensitive
-					uint32_t nameidlower = clip->getSystemState()->getUniqueStringId(s.lowercase());
-					auto it = locals.find(nameidlower);
-					if (it != locals.end()) // local variable
-					{
-						ASATOM_INCREF(value);
-						ASATOM_DECREF(it->second);
-						it->second = value;
-					}
-					else if (!caller)
-					{
-						auto it = clip->avm1locals.find(nameidlower);
-						if (it != clip->avm1locals.end())
-						{
-							ASATOM_ADDSTOREDMEMBER(value);
-							ASATOM_REMOVESTOREDMEMBER(it->second);
-							it->second = value;
-						}
-					}
-				}
-				if (!curdepth && !s.startsWith("/") && !s.startsWith(":") && !clip_isTarget)
-					originalclip->AVM1SetVariable(s,value);
-				else
-					clip->AVM1SetVariable(s,value);
+				context->setVariable(thisObj, originalclip, clip, s, value);
 				break;
 			}
 			case 0x20: // ActionSetTarget2
@@ -726,6 +1123,7 @@
 					{
 						LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionSetTarget2 "<<s);
 					}
+
 					if (clip_isTarget)
 						clip->decRef();
 					clip_isTarget=false;
@@ -736,12 +1134,13 @@
 					else
 					{
 						DisplayObject* c = clip->AVM1GetClipFromPath(s);
-						if (!c)
+						clip = c != nullptr ? c : clip->AVM1getRoot();
+						if (c == nullptr)
 							LOG(LOG_ERROR,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionSetTarget2 clip not found:"<<s);
-						else
-							clip = c;
 					}
 				}
+				clip->incRef();
+				context->scope->setTargetScope(_MR(clip));
 				break;
 			}
 			case 0x21: // ActionStringAdd
@@ -768,75 +1167,14 @@
 					tiny_string s = asAtomHandler::toString(target,wrk);
 					o = clip->AVM1GetClipFromPath(s);
 				}
-				asAtom ret = asAtomHandler::undefinedAtom;
-				if (o)
+				asAtom ret = asAtomHandler::invalidAtom;
+				if (o != nullptr)
 				{
-					asAtom obj = asAtomHandler::fromObject(o);
-					switch (asAtomHandler::toInt(index))
-					{
-						case 0:// x
-							DisplayObject::_getX(ret,wrk,obj,nullptr,0);
-							break;
-						case 1:// y
-							DisplayObject::_getY(ret,wrk,obj,nullptr,0);
-							break;
-						case 2:// xscale
-							DisplayObject::AVM1_getScaleX(ret,wrk,obj,nullptr,0);
-							break;
-						case 3:// xscale
-							DisplayObject::AVM1_getScaleY(ret,wrk,obj,nullptr,0);
-							break;
-						case 4:// currentframe
-							if (o->is<MovieClip>())
-								MovieClip::_getCurrentFrame(ret,wrk,obj,nullptr,0);
-							break;
-						case 5:// totalframes
-							if (o->is<MovieClip>())
-								MovieClip::_getTotalFrames(ret,wrk,obj,nullptr,0);
-							break;
-						case 6:// alpha
-							DisplayObject::AVM1_getAlpha(ret,wrk,obj,nullptr,0);
-							break;
-						case 7:// visible
-							DisplayObject::_getVisible(ret,wrk,obj,nullptr,0);
-							break;
-						case 8:// width
-							DisplayObject::_getWidth(ret,wrk,obj,nullptr,0);
-							break;
-						case 9:// height
-							DisplayObject::_getHeight(ret,wrk,obj,nullptr,0);
-							break;
-						case 10:// rotation
-							DisplayObject::_getRotation(ret,wrk,obj,nullptr,0);
-							break;
-						case 12:// framesloaded
-							if (o->is<MovieClip>())
-								MovieClip::_getFramesLoaded(ret,wrk,obj,nullptr,0);
-							break;
-						case 13:// name
-							DisplayObject::_getter_name(ret,wrk,obj,nullptr,0);
-							break;
-						case 15:// url
-							ret = asAtomHandler::fromString(clip->getSystemState(),clip->getSystemState()->mainClip->getOrigin().getURL());
-							break;
-						case 17:// focusrect
-							if (asAtomHandler::is<InteractiveObject>(obj))
-								InteractiveObject::AVM1_getfocusrect(ret,wrk,obj,nullptr,0);
-							break;
-						case 19:// quality
-							DisplayObject::AVM1_getQuality(ret,wrk,obj,nullptr,0);
-							break;
-						case 20:// xmouse
-							DisplayObject::_getMouseX(ret,wrk,obj,nullptr,0);
-							break;
-						case 21:// ymouse
-							DisplayObject::_getMouseY(ret,wrk,obj,nullptr,0);
-							break;
-						default:
-							LOG(LOG_NOT_IMPLEMENTED,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" GetProperty type:"<<asAtomHandler::toInt(index));
-							break;
-					}
+					size_t idx = asAtomHandler::toInt(index);
+					ret = o->getPropertyByIndex(idx, wrk);
 				}
+				if (asAtomHandler::isInvalid(ret))
+					ret = asAtomHandler::undefinedAtom;
 				ASATOM_DECREF(index);
 				ASATOM_DECREF(target);
 				PushStack(stack,ret);
@@ -860,62 +1198,10 @@
 					if (!o) // it seems that Adobe falls back to the current clip if the path is invalid
 						o = clip;
 				}
-				if (o)
+				if (o != nullptr)
 				{
-					asAtom obj = asAtomHandler::fromObject(o);
-					asAtom ret=asAtomHandler::invalidAtom;
-					switch (asAtomHandler::toInt(index))
-					{
-						case 0:// x
-							DisplayObject::_setX(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 1:// y
-							DisplayObject::_setY(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 2:// xscale
-							DisplayObject::AVM1_setScaleX(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 3:// xscale
-							DisplayObject::AVM1_setScaleY(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 6:// alpha
-							DisplayObject::AVM1_setAlpha(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 7:// visible
-							DisplayObject::_setVisible(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 8:// width
-							DisplayObject::_setWidth(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 9:// height
-							DisplayObject::_setHeight(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 10:// rotation
-							DisplayObject::_setRotation(ret,wrk,obj,&value,1);
-							ASATOM_DECREF(value);
-							break;
-						case 13:// name
-							DisplayObject::_setter_name(ret,wrk,obj,&value,1);
-							break;
-						case 17:// focusrect
-							if (asAtomHandler::is<InteractiveObject>(obj))
-								InteractiveObject::AVM1_setfocusrect(ret,wrk,obj,&value,1);
-							break;
-						case 19:// quality
-							DisplayObject::AVM1_setQuality(ret,wrk,obj,&value,1);
-							break;
-						default:
-							LOG(LOG_NOT_IMPLEMENTED,"AVM1: SetProperty type:"<<asAtomHandler::toInt(index));
-							break;
-					}
+					size_t idx = asAtomHandler::toInt(index);
+					o->setPropertyByIndex(idx, value, wrk);
 				}
 				else
 					LOG(LOG_ERROR,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionSetProperty target clip not found:"<<asAtomHandler::toDebugString(target)<<" "<<asAtomHandler::toDebugString(index)<<" "<<asAtomHandler::toDebugString(value));
@@ -1154,7 +1440,11 @@
 					ASObject* o = asAtomHandler::getObject(scriptobject);
 					multiname m(nullptr);
 					m.name_type=multiname::NAME_STRING;
-					m.name_s_id=asAtomHandler::toStringId(name,wrk);
+					m.name_s_id = sys->getUniqueStringId
+					(
+						asAtomHandler::AVM1toString(name, wrk),
+						context->isCaseSensitive()
+					);
 					m.ns.emplace_back(clip->getSystemState(),BUILTIN_STRINGS::EMPTY,NAMESPACE);
 					m.isAttribute = false;
 					if (o->deleteVariableByMultiname(m,wrk))
@@ -1171,24 +1461,19 @@
 			{
 				asAtom name = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionDelete2 "<<asAtomHandler::toDebugString(name));
-				DisplayObject* o = clip;
-				asAtom ret = asAtomHandler::falseAtom;
-				while (o)
-				{
-					multiname m(nullptr);
-					m.name_type=multiname::NAME_STRING;
-					m.name_s_id=asAtomHandler::toStringId(name,wrk);
-					m.ns.emplace_back(clip->getSystemState(),BUILTIN_STRINGS::EMPTY,NAMESPACE);
-					m.isAttribute = false;
-					if (o->deleteVariableByMultiname(m,wrk))
-					{
-						ret = asAtomHandler::trueAtom;
-						break;
-					}
-					o = o->getParent();
-				}
+				multiname m(nullptr);
+				m.name_type = multiname::NAME_STRING;
+				m.name_s_id = sys->getUniqueStringId
+				(
+					asAtomHandler::AVM1toString(name, wrk),
+					context->isCaseSensitive()
+				);
+				m.ns.emplace_back(clip->getSystemState(),BUILTIN_STRINGS::EMPTY,NAMESPACE);
+
+				bool ret = context->scope->deleteVariableByMultiname(m, wrk);
+
 				ASATOM_DECREF(name);
-				PushStack(stack,asAtom(ret)); // spec doesn't mention this, but it seems that a bool indicating wether a property was deleted is pushed on the stack
+				PushStack(stack,asAtomHandler::fromBool(ret)); // spec doesn't mention this, but it seems that a bool indicating wether a property was deleted is pushed on the stack
 				break;
 			}
 			case 0x3c: // ActionDefineLocal
@@ -1196,32 +1481,27 @@
 				asAtom value = PopStack(stack);
 				asAtom name = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionDefineLocal "<<asAtomHandler::toDebugString(name)<<" " <<asAtomHandler::toDebugString(value));
-				if (context->keepLocals)
-				{
-					ASATOM_INCREF(value);
-					tiny_string s =asAtomHandler::toString(name,wrk).lowercase();
-					clip->AVM1SetVariable(s,value,false);
-				}
-				uint32_t nameID = clip->getSystemState()->getUniqueStringId(asAtomHandler::toString(name,wrk).lowercase());
-				if (caller)
-				{
-					ASATOM_DECREF(locals[nameID]);
-					locals[nameID] = value;
-				}
-				else
-				{
-					ASObject* v = asAtomHandler::getObject(value);
-					if (v)
-						v->addStoredMember();
-					auto it = clip->avm1locals.find(nameID);
-					if (it == clip->avm1locals.end())
-						clip->avm1locals.insert(make_pair(nameID,value));
-					else
-					{
-						ASATOM_REMOVESTOREDMEMBER(it->second);
-						it->second = value;
-					}
-				}
+
+				multiname m(nullptr);
+				m.name_type = multiname::NAME_STRING;
+				m.name_s_id = sys->getUniqueStringId
+				(
+					asAtomHandler::AVM1toString
+					(
+						name,
+						wrk
+					),
+					context->isCaseSensitive()
+				);
+
+				context->scope->defineLocalByMultiname
+				(
+					m,
+					value,
+					ASObject::CONST_ALLOWED,
+					wrk
+				);
+
 				ASATOM_DECREF(name);
 				break;
 			}
@@ -1234,84 +1514,29 @@
 				for (uint32_t i = 0; i < numargs; i++)
 					args[i] = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
-				uint32_t nameID = asAtomHandler::toStringId(name,wrk);
-				tiny_string s = clip->getSystemState()->getStringFromUniqueId(nameID);
-				asAtom ret=asAtomHandler::invalidAtom;
-				AVM1Function* f =nullptr;
-				if (asAtomHandler::isUndefined(name)|| asAtomHandler::toStringId(name,wrk) == BUILTIN_STRINGS::EMPTY)
-					LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction without name "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
-				else
+
+				asAtom ret = asAtomHandler::undefinedAtom;
+				auto s = asAtomHandler::AVM1toString(name, wrk);
+				auto func = context->getVariable(thisObj, originalclip, clip, s);
+
+				if (asAtomHandler::is<AVM1Function>(func))
 				{
-					tiny_string s = asAtomHandler::toString(name,wrk).lowercase();
-					asAtom func = clip->AVM1GetVariable(s);
-					if (asAtomHandler::isInvalid(func) && clip != originalclip)
-						func = originalclip->AVM1GetVariable(s);
-					if (asAtomHandler::is<AVM1Function>(func))
-					{
-						asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
-						asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,args,numargs,caller,&locals);
-						asAtomHandler::as<AVM1Function>(func)->decRef();
-					}
-					else if (asAtomHandler::is<Function>(func))
-					{
-						asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
-						asAtomHandler::as<Function>(func)->call(ret,wrk,obj,args,numargs);
-						asAtomHandler::as<Function>(func)->decRef();
-					}
-					else if (asAtomHandler::is<Class_base>(func))
-					{
-						asAtomHandler::as<Class_base>(func)->generator(wrk,ret,args,numargs);
-					}
-					else
-					{
-						if (clip->loadedFrom->version > 4)
-						{
-							func = asAtomHandler::invalidAtom;
-							multiname m(nullptr);
-							m.name_type=multiname::NAME_STRING;
-							m.name_s_id=nameID;
-							m.isAttribute = false;
-							clip->getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-							if (asAtomHandler::isInvalid(func))// get Variable from root movie
-								clip->loadedFrom->getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-							if (asAtomHandler::isInvalid(func))// get Variable from global object
-								clip->getSystemState()->avm1global->getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,wrk);
-						}
-						if (asAtomHandler::isInvalid(func))
-						{
-							uint32_t nameIDlower = clip->getSystemState()->getUniqueStringId(asAtomHandler::toString(name,wrk).lowercase());
-							f =clip->AVM1GetFunction(nameIDlower);
-							if (f)
-								f->call(&ret,nullptr, args,numargs,caller,&locals);
-							else
-							{
-								LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction function not found "<<asAtomHandler::toDebugString(name)<<" "<<asAtomHandler::toDebugString(func)<<" "<<numargs);
-								ret = asAtomHandler::undefinedAtom;
-							}
-						}
-						else if (asAtomHandler::is<AVM1Function>(func))
-						{
-							asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
-							asAtomHandler::as<AVM1Function>(func)->call(&ret,&obj,args,numargs,caller,&locals);
-							asAtomHandler::as<AVM1Function>(func)->decRef();
-						}
-						else if (asAtomHandler::is<Function>(func))
-						{
-							asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
-							asAtomHandler::as<Function>(func)->call(ret,wrk,obj,args,numargs);
-							asAtomHandler::as<Function>(func)->decRef();
-						}
-						else if (asAtomHandler::is<Class_base>(func))
-						{
-							asAtomHandler::as<Class_base>(func)->generator(wrk,ret,args,numargs);
-						}
-						else
-						{
-							LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction function not found "<<asAtomHandler::toDebugString(name)<<" "<<asAtomHandler::toDebugString(func)<<" "<<numargs);
-							ret = asAtomHandler::undefinedAtom;
-						}
-					}
+					asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
+					auto f = asAtomHandler::as<AVM1Function>(func);
+					f->call(&ret,&obj,args,numargs,caller);
+					f->decRef();
+				}
+				else if (asAtomHandler::is<Function>(func))
+				{
+					asAtom obj = asAtomHandler::fromObjectNoPrimitive(clip);
+					asAtomHandler::as<Function>(func)->call(ret,wrk,obj,args,numargs);
+					asAtomHandler::as<Function>(func)->decRef();
 				}
+				else if (asAtomHandler::is<Class_base>(func))
+					asAtomHandler::as<Class_base>(func)->generator(wrk,ret,args,numargs);
+				else
+					LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction function not found "<<asAtomHandler::toDebugString(name)<<" "<<asAtomHandler::toDebugString(func)<<" "<<numargs);
+
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallFunction done "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
 				for (uint32_t i = 0; i < numargs; i++)
 					ASATOM_DECREF(args[i]);
@@ -1350,10 +1575,10 @@
 				for (size_t i = 0; i < numargs; i++)
 					args[i] = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionNewObject "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
-				AVM1Function* f =nullptr;
-				uint32_t nameID = asAtomHandler::toStringId(name,wrk);
+				auto s = asAtomHandler::AVM1toString(name, wrk);
+				auto nameID = sys->getUniqueStringId(s, context->isCaseSensitive());
 				asAtom ret=asAtomHandler::invalidAtom;
-				if (asAtomHandler::isUndefined(name) || asAtomHandler::toStringId(name,wrk) == BUILTIN_STRINGS::EMPTY)
+				if (asAtomHandler::isUndefined(name) || s.empty())
 					LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionNewObject without name "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
 				else
 				{
@@ -1361,8 +1586,15 @@
 					m.name_type=multiname::NAME_STRING;
 					m.name_s_id=nameID;
 					m.isAttribute = false;
-					asAtom cls=asAtomHandler::invalidAtom;
-					clip->getSystemState()->avm1global->getVariableByMultiname(cls,m,GET_VARIABLE_OPTION::NONE,wrk);
+
+					auto cls = context->scope->getVariableByMultiname
+					(
+						originalclip,
+						m,
+						GET_VARIABLE_OPTION::NONE,
+						wrk
+					);
+
 					if (asAtomHandler::is<Class_base>(cls))
 					{
 						asAtomHandler::as<Class_base>(cls)->getInstance(wrk,ret,true,args,numargs);
@@ -1373,37 +1605,12 @@
 						o->setprop_prototype(asAtomHandler::as<AVM1Function>(cls)->prototype);
 						o->setprop_prototype(asAtomHandler::as<AVM1Function>(cls)->prototype,BUILTIN_STRINGS::STRING_PROTO);
 						ret = asAtomHandler::fromObject(o);
-						asAtomHandler::as<AVM1Function>(cls)->call(nullptr,&ret, args,numargs,caller,&locals);
-						asAtomHandler::as<AVM1Function>(cls)->decRef();
-					}
-					else
-					{
-						uint32_t nameIDlower = clip->getSystemState()->getUniqueStringId(asAtomHandler::toString(name,wrk).lowercase());
-						f =clip->AVM1GetFunction(nameIDlower);
+						auto func = asAtomHandler::as<AVM1Function>(cls);
+						func->call(nullptr,&ret, args,numargs,caller);
+						func->decRef();
 					}
 				}
-				if (f)
-				{
-					ASObject* pr = f->getprop_prototype();
-					ASObject* o = nullptr;
-					if (pr)
-					{
-						pr->incRef();
-						_NR<ASObject> proto = _MR(pr);
-						o = new_functionObject(proto);
-						o->setprop_prototype(proto);
-						o->setprop_prototype(proto,BUILTIN_STRINGS::STRING_PROTO);
-					}
-					else
-					{
-						o = new_functionObject(f->prototype);
-						o->setprop_prototype(f->prototype);
-						o->setprop_prototype(f->prototype,BUILTIN_STRINGS::STRING_PROTO);
-					}
-					ret = asAtomHandler::fromObject(o);
-					f->call(nullptr,&ret, args,numargs,caller,&locals);
-				}
-				else if (asAtomHandler::isInvalid(ret))
+				if (asAtomHandler::isInvalid(ret))
 					LOG(LOG_NOT_IMPLEMENTED, "AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionNewObject class not found "<<asAtomHandler::toDebugString(name)<<" "<<numargs);
 				ASATOM_DECREF(name);
 				ASATOM_DECREF(na);
@@ -1415,17 +1622,16 @@
 			{
 				asAtom name = PopStack(stack);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionDefineLocal2 "<<asAtomHandler::toDebugString(name));
-				tiny_string namelower = asAtomHandler::toString(name,wrk).lowercase();
-				uint32_t nameID = clip->getSystemState()->getUniqueStringId(namelower);
-				if (caller)
-				{
-					if (locals.find(nameID) == locals.end())
-						locals[nameID] = asAtomHandler::undefinedAtom;
-				}
-				else
+				tiny_string s = asAtomHandler::AVM1toString(name, wrk);
+				uint32_t nameID = sys->getUniqueStringId(s, context->isCaseSensitive());
+				multiname m(nullptr);
+				m.name_type = multiname::NAME_STRING;
+				m.name_s_id = nameID;
+
+				if (!context->scope->getLocals()->hasPropertyByMultiname(m, true, false, wrk))
 				{
-					if (clip->avm1locals.find(nameID) == clip->avm1locals.end())
-						clip->avm1locals[nameID] = asAtomHandler::undefinedAtom;
+					auto atom = asAtomHandler::undefinedAtom;
+					context->scope->defineLocalByMultiname(m, atom, ASObject::CONST_ALLOWED, wrk);
 				}
 				ASATOM_DECREF(name);
 				break;
@@ -1483,8 +1689,8 @@
 			case 0x46: // ActionEnumerate
 			{
 				asAtom path = PopStack(stack);
-				tiny_string s = asAtomHandler::toString(path,wrk).lowercase();
-				asAtom obj = clip->AVM1GetVariable(s);
+				tiny_string s = asAtomHandler::AVM1toString(path, wrk);
+				asAtom obj = context->getVariable(thisObj, originalclip, clip, s);
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionEnumerate "<<s<<" "<<asAtomHandler::toDebugString(obj));
 				if (asAtomHandler::isObject(obj) && !asAtomHandler::isNumeric(obj))
 				{
@@ -1577,81 +1783,36 @@
 				}
 				else
 				{
-					uint32_t nameID = asAtomHandler::toStringId(name,wrk);
+					auto s = asAtomHandler::AVM1toString(name, wrk);
+					auto nameID = sys->getUniqueStringId(s, context->isCaseSensitive());
 					ASObject* o = asAtomHandler::toObject(scriptobject,wrk);
-					int step = 2; // we search in two steps, first with the normal name, then with name in lowercase (TODO find some faster method for case insensitive check for members)
-					while (step)
+					multiname m(nullptr);
+					m.isAttribute = false;
+					switch (asAtomHandler::getObjectType(name))
 					{
-						multiname m(nullptr);
-						m.isAttribute = false;
-						switch (asAtomHandler::getObjectType(name))
-						{
-							case T_INTEGER:
-								m.name_type=multiname::NAME_INT;
-								m.name_i=asAtomHandler::getInt(name);
-								break;
-							case T_UINTEGER:
-								m.name_type=multiname::NAME_UINT;
-								m.name_ui=asAtomHandler::getUInt(name);
-								break;
-							case T_NUMBER:
-								m.name_type=multiname::NAME_NUMBER;
-								m.name_d=asAtomHandler::toNumber(name);
-								break;
-							default:
-								m.name_type=multiname::NAME_STRING;
-								m.name_s_id=nameID;
-								break;
-						}
-						if(o)
-						{
-							o->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::DONT_CHECK_CLASS,wrk);
-							if (!asAtomHandler::isValid(ret))
-							{
-								ASObject* pr = o->is<Class_base>() && o->as<Class_base>()->getPrototype(wrk) ? o->as<Class_base>()->getPrototype(wrk)->getObj() : o->getprop_prototype();
-								size_t depth = 0;
-								// search the prototype before searching the AS3 class
-								while (pr)
-								{
-									if (depth >= 255)
-									{
-										throw ScriptLimitException
-										(
-											"Reached maximum prototype recursion limit",
-
-											ScriptLimitException::MaxPrototypeRecursion
-										);
-									}
-									bool isGetter = pr->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::DONT_CALL_GETTER,wrk) & GET_VARIABLE_RESULT::GETVAR_ISGETTER;
-									if (isGetter) // getter from prototype has to be called with o as target
-									{
-										IFunction* f = asAtomHandler::as<IFunction>(ret);
-										ret = asAtom();
-										asAtom closure = asAtomHandler::fromObject(o);
-										f->callGetter(ret,closure,wrk);
-										break;
-									}
-									else if (!asAtomHandler::isInvalid(ret))
-										break;
-									pr = pr->getprop_prototype();
-									depth++;
-								}
-							}
-							if (!asAtomHandler::isValid(ret))
-								o->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::NONE,wrk);
-						}
-						if (asAtomHandler::isInvalid(ret))
-						{
-							step--;
-							if (step)
-							{
-								tiny_string namelower = asAtomHandler::toString(name,wrk).lowercase();
-								nameID = clip->getSystemState()->getUniqueStringId(namelower);
-							}
-						}
-						else
+						case T_INTEGER:
+							m.name_type=multiname::NAME_INT;
+							m.name_i=asAtomHandler::getInt(name);
+							break;
+						case T_UINTEGER:
+							m.name_type=multiname::NAME_UINT;
+							m.name_ui=asAtomHandler::getUInt(name);
+							break;
+						case T_NUMBER:
+							m.name_type=multiname::NAME_NUMBER;
+							m.name_d=asAtomHandler::toNumber(name);
+							break;
+						default:
+							m.name_type=multiname::NAME_STRING;
+							m.name_s_id=nameID;
 							break;
 					}
+					if (o != nullptr)
+					{
+						o->AVM1getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::DONT_CHECK_CLASS,wrk,false);
+						if (asAtomHandler::isInvalid(ret))
+							o->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::NONE,wrk);
+					}
 					if (asAtomHandler::isInvalid(ret))
 					{
 						switch (asAtomHandler::getObjectType(scriptobject))
@@ -1684,36 +1845,9 @@
 											LOG(LOG_NOT_IMPLEMENTED,"AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionGetMember for scriptobject without class "<<asAtomHandler::toDebugString(scriptobject)<<" " <<asAtomHandler::toDebugString(name));
 										break;
 									}
-									case BUILTIN_STRINGS::STRING_AVM1_TARGET:
-										if (o->is<DisplayObject>())
-											ret = asAtomHandler::fromString(clip->getSystemState(),o->as<DisplayObject>()->AVM1GetPath());
-										else
-											asAtomHandler::setUndefined(ret);
-										break;
 									default:
 									{
-										multiname m(nullptr);
-										m.isAttribute = false;
-										switch (asAtomHandler::getObjectType(name))
-										{
-											case T_INTEGER:
-												m.name_type=multiname::NAME_INT;
-												m.name_i=asAtomHandler::getInt(name);
-												break;
-											case T_UINTEGER:
-												m.name_type=multiname::NAME_UINT;
-												m.name_ui=asAtomHandler::getUInt(name);
-												break;
-											case T_NUMBER:
-												m.name_type=multiname::NAME_NUMBER;
-												m.name_d=asAtomHandler::toNumber(name);
-												break;
-											default:
-												m.name_type=multiname::NAME_STRING;
-												m.name_s_id=nameID;
-												break;
-										}
-										o->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::NONE,wrk);
+										o->AVM1getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::NONE,wrk,false);
 										break;
 									}
 								}
@@ -1723,11 +1857,6 @@
 								break;
 						}
 					}
-					if (asAtomHandler::isInvalid(ret))
-					{
-						if (o && o->is<DisplayObject>())
-							ret = o->as<DisplayObject>()->AVM1GetVariable(asAtomHandler::toString(name,wrk),false);
-					}
 					if (context->exceptionthrown)
 					{
 						context->exceptionthrown->decRef();
@@ -1750,9 +1879,9 @@
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionSetMember "<<asAtomHandler::toDebugString(scriptobject)<<" " <<asAtomHandler::toDebugString(name)<<" "<<asAtomHandler::toDebugString(value));
 				if (asAtomHandler::isObject(scriptobject) || asAtomHandler::isFunction(scriptobject) || asAtomHandler::isArray(scriptobject))
 				{
+					auto s = asAtomHandler::AVM1toString(name, wrk);
+					auto nameID = sys->getUniqueStringId(s, context->isCaseSensitive());
 					ASObject* o = asAtomHandler::getObject(scriptobject);
-					if (o->is<DisplayObject>())
-						ASATOM_INCREF(value);// incref here to make sure value is not destructed when setting value, reference is consumed in AVM1SetVariableDirect
 					multiname m(nullptr);
 					switch (asAtomHandler::getObjectType(name))
 					{
@@ -1770,7 +1899,7 @@
 							break;
 						default:
 							m.name_type=multiname::NAME_STRING;
-							m.name_s_id=asAtomHandler::toStringId(name,wrk);
+							m.name_s_id=nameID;
 							break;
 					}
 					m.isAttribute = false;
@@ -1805,33 +1934,7 @@
 								}
 							}
 						}
-						bool hassetter=false;
-						if (!fromInitAction)
-						{
-							ASObject* pr = o->getprop_prototype();
-							while (pr)
-							{
-								variable* var = pr->findVariableByMultiname(m,nullptr,nullptr,nullptr,false,wrk);
-								if (var && asAtomHandler::is<AVM1Function>(var->setter))
-								{
-									ASATOM_INCREF(value);
-									asAtomHandler::as<AVM1Function>(var->setter)->call(nullptr,&scriptobject,&value,1,caller,&locals);
-									hassetter=true;
-									break;
-								}
-								pr = pr->getprop_prototype();
-							}
-						}
-						if (!hassetter)
-						{
-							o->setVariableByMultiname(m,value,ASObject::CONST_ALLOWED,nullptr,wrk);
-						}
-					}
-					if (o->is<DisplayObject>())
-					{
-						o->as<DisplayObject>()->AVM1UpdateVariableBindings(m.name_s_id,value);
-						uint32_t nameIDlower = clip->getSystemState()->getUniqueStringId(asAtomHandler::toString(name,wrk).lowercase());
-						o->as<DisplayObject>()->AVM1SetVariableDirect(nameIDlower,value);
+						(void)o->AVM1setVariableByMultiname(m,value,ASObject::CONST_ALLOWED,wrk);
 					}
 				}
 				else
@@ -1872,22 +1975,27 @@
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallMethod "<<asAtomHandler::toDebugString(name)<<" "<<numargs<<" "<<asAtomHandler::toDebugString(scriptobject));
 				asAtom ret=asAtomHandler::invalidAtom;
 				bool done=false;
-				if (asAtomHandler::isUndefined(name)|| asAtomHandler::toStringId(name,wrk) == BUILTIN_STRINGS::EMPTY)
+				tiny_string s;
+				if (asAtomHandler::isValid(name) && !asAtomHandler::isUndefined(name))
+					s = asAtomHandler::AVM1toString(name, wrk);
+				auto nameID = sys->getUniqueStringId(s, context->isCaseSensitive());
+				if (s.empty())
 				{
 					if (asAtomHandler::is<Function>(scriptobject))
 					{
-						asAtomHandler::as<Function>(scriptobject)->call(ret,wrk,scopestack[0],args,numargs);
+						asAtomHandler::as<Function>(scriptobject)->call(ret,wrk,thisObj,args,numargs);
 					}
 					else if (asAtomHandler::is<AVM1Function>(scriptobject))
 					{
-						asAtomHandler::as<AVM1Function>(scriptobject)->call(&ret,&scopestack[0],args,numargs,caller,&locals);
+						auto func = asAtomHandler::as<AVM1Function>(scriptobject);
+						func->call(&ret,&thisObj,args,numargs);
 					}
 					else if (asAtomHandler::is<Class_base>(scriptobject))
 					{
 						Class_base* cls = asAtomHandler::as<Class_base>(scriptobject);
-						if (!asAtomHandler::getObjectNoCheck(scopestack[0])->isConstructed() && !fromInitAction)
+						if (!asAtomHandler::getObjectNoCheck(thisObj)->isConstructed() && !fromInitAction)
 						{
-							cls->handleConstruction(scopestack[0],args,numargs,true);
+							cls->handleConstruction(thisObj,args,numargs,true);
 						}
 						LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallMethod from class done "<<asAtomHandler::toDebugString(name)<<" "<<numargs<<" "<<asAtomHandler::toDebugString(scriptobject));
 					}
@@ -1903,19 +2011,20 @@
 						{
 							if (asAtomHandler::is<Function>(constr))
 							{
-								asAtomHandler::as<Function>(constr)->call(ret,wrk,scopestack[0],args,numargs);
+								asAtomHandler::as<Function>(constr)->call(ret,wrk,thisObj,args,numargs);
 								asAtomHandler::as<Function>(constr)->decRef();
 							}
 							else if (asAtomHandler::is<AVM1Function>(constr))
 							{
-								asAtomHandler::as<AVM1Function>(constr)->call(&ret,&scopestack[0],args,numargs,caller,&locals);
-								asAtomHandler::as<AVM1Function>(constr)->decRef();
+								auto f = asAtomHandler::as<AVM1Function>(constr);
+								f->call(&ret,&thisObj,args,numargs,caller);
+								f->decRef();
 							}
 							else if (asAtomHandler::is<Class_base>(constr))
 							{
 								Class_base* cls = asAtomHandler::as<Class_base>(constr);
-								if (!asAtomHandler::getObjectNoCheck(scopestack[0])->isConstructed() && !fromInitAction)
-									cls->handleConstruction(scopestack[0],args,numargs,true);
+								if (!asAtomHandler::getObjectNoCheck(thisObj)->isConstructed() && !fromInitAction)
+									cls->handleConstruction(thisObj,args,numargs,true);
 								LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallMethod constructor from class done "<<asAtomHandler::toDebugString(name)<<" "<<numargs<<" "<<asAtomHandler::toDebugString(scriptobject));
 							}
 						}
@@ -1930,11 +2039,10 @@
 				{
 					if (asAtomHandler::is<DisplayObject>(scriptobject))
 					{
-						uint32_t nameIDlower = clip->getSystemState()->getUniqueStringId(asAtomHandler::toString(name,wrk).lowercase());
-						AVM1Function* f = asAtomHandler::as<DisplayObject>(scriptobject)->AVM1GetFunction(nameIDlower);
+						AVM1Function* f = asAtomHandler::as<DisplayObject>(scriptobject)->AVM1GetFunction(nameID);
 						if (f)
 						{
-							f->call(&ret,&scriptobject,args,numargs,caller,&locals);
+							f->call(&ret,&scriptobject,args,numargs);
 							LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCallMethod from displayobject done "<<asAtomHandler::toDebugString(name)<<" "<<numargs<<" "<<asAtomHandler::toDebugString(scriptobject));
 							done=true;
 						}
@@ -1992,16 +2100,17 @@
 						}
 						if (asAtomHandler::is<Function>(func))
 						{
-							asAtomHandler::as<Function>(func)->call(ret,wrk,scriptobject.uintval == super.uintval ? scopestack[0] : scriptobject,args,numargs);
+							asAtomHandler::as<Function>(func)->call(ret,wrk,scriptobject.uintval == super.uintval ? thisObj : scriptobject,args,numargs);
 							asAtomHandler::as<Function>(func)->decRef();
 						}
 						else if (asAtomHandler::is<AVM1Function>(func))
 						{
+							auto f = asAtomHandler::as<AVM1Function>(func);
 							if (scriptobject.uintval == super.uintval)
-								asAtomHandler::as<AVM1Function>(func)->call(&ret,&scopestack[0],args,numargs,caller,&locals);
+								f->call(&ret,&thisObj,args,numargs,caller);
 							else
-								asAtomHandler::as<AVM1Function>(func)->call(&ret,&scriptobject,args,numargs,caller,&locals);
-							asAtomHandler::as<AVM1Function>(func)->decRef();
+								f->call(&ret,&scriptobject,args,numargs,caller);
+							f->decRef();
 						}
 						else
 						{
@@ -2094,7 +2203,8 @@
 				}
 				else if (asAtomHandler::is<AVM1Function>(func))
 				{
-					asAtomHandler::as<AVM1Function>(func)->call(nullptr,&ret,args,numargs,caller,&locals);
+					auto f = asAtomHandler::as<AVM1Function>(func);
+					f->call(nullptr,&ret,args,numargs,caller);
 				}
 				else if (asAtomHandler::is<Class_base>(func))
 				{
@@ -2282,7 +2392,7 @@
 				{
 					tiny_string s((const char*)&(*it),true);
 					it += s.numBytes()+1;
-					context->AVM1AddConstant(clip->getSystemState()->getUniqueStringId(s));
+					context->AVM1AddConstant(sys->getUniqueStringId(s, true));
 				}
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionConstantPool "<<c);
 				break;
@@ -2339,6 +2449,8 @@
 					if (newTarget == nullptr)
 						LOG(LOG_ERROR,"AVM1: ActionSetTarget clip not found:"<<s);
 				}
+				clip->incRef();
+				context->scope->setTargetScope(_MR(clip));
 				break;
 			}
 			case 0x8c: // ActionGotoLabel
@@ -2377,7 +2489,11 @@
 					uint8_t regnum = *it++;
 					tiny_string n((const char*)&(*it),true);
 					it += n.numBytes()+1;
-					funcparamnames.push_back(clip->getSystemState()->getUniqueStringId(n.lowercase()));
+					funcparamnames.push_back(sys->getUniqueStringId
+					(
+						n,
+						context->isCaseSensitive()
+					));
 					registernumber.push_back(regnum);
 				}
 				uint32_t codesize = uint32_t(*it++) | ((*it++)<<8);
@@ -2386,22 +2502,12 @@
 				it += codesize;
 				Activation_object* act = name == "" ? new_activationObject(wrk) : nullptr;
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionDefineFunction2 "<<name<<" "<<paramcount<<" "<<flag1<<flag2<<flag3<<flag4<<flag5<<flag6<<flag7<<flag8<<flag9<<" "<<codesize<<" "<<act);
-				AVM1Function* f = Class<IFunction>::getAVM1Function(wrk,clip,act,context,funcparamnames,code,registernumber,flag1, flag2, flag3, flag4, flag5, flag6, flag7, flag8, flag9);
+				AVM1Function* f = Class<IFunction>::getAVM1Function(wrk,clip,act,context,funcparamnames,code,context->scope,registernumber,flag1, flag2, flag3, flag4, flag5, flag6, flag7, flag8, flag9);
 				//Create the prototype object
 				f->prototype = _MR(new_asobject(f->getSystemState()->worker));
 				f->prototype->addStoredMember();
 				if (name == "")
 				{
-					for (uint32_t i = 0; i < paramnames.size(); i++)
-					{
-						multiname m(nullptr);
-						m.name_type=multiname::NAME_STRING;
-						m.isAttribute = false;
-						m.name_s_id=paramnames[i];
-						asAtom v = locals[paramnames[i]];
-						ASATOM_INCREF(v);
-						act->setVariableByMultiname(m,v,ASObject::CONST_ALLOWED,nullptr,wrk);
-					}
 					asAtom a = asAtomHandler::fromObject(f);
 					PushStack(stack,a);
 				}
@@ -2424,14 +2530,14 @@
 				Log::calls_indent++;
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionWith "<<codesize<<" "<<asAtomHandler::toDebugString(obj));
 				++curdepth;
-				if (clip_isTarget)
-					clip->decRef();
-				clip_isTarget=true;
-				if (asAtomHandler::is<DisplayObject>(obj))
-					clip = asAtomHandler::as<DisplayObject>(obj);
-				ASATOM_INCREF(obj);
-				scopestack[curdepth] = obj;
 				scopestackstop[curdepth] = itend;
+				ASObject* o= asAtomHandler::toObject(obj, wrk);
+				o->incRef();
+				context->scope = _MNR(new AVM1Scope
+				(
+					context->scope,
+					_MR(o)
+				));
 				break;
 			}
 			case 0x96: // ActionPush
@@ -2449,7 +2555,7 @@
 							tiny_string val((const char*)&(*it),true);
 							len -= val.numBytes()+1;
 							it += val.numBytes()+1;
-							asAtom a = asAtomHandler::fromStringID(clip->getSystemState()->getUniqueStringId(val));
+							asAtom a = asAtomHandler::fromStringID(sys->getUniqueStringId(val, true));
 							PushStack(stack,a);
 							LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionPush 0 "<<asAtomHandler::toDebugString(a));
 							break;
@@ -2602,7 +2708,7 @@
 				{
 					tiny_string n((const char*)&(*it),true);
 					it += n.numBytes()+1;
-					paramnames.push_back(clip->getSystemState()->getUniqueStringId(n.lowercase()));
+					paramnames.push_back(sys->getUniqueStringId(n, context->isCaseSensitive()));
 				}
 				uint32_t codesize = uint32_t(*it++) | ((*it++)<<8);
 				vector<uint8_t> code;
@@ -2610,22 +2716,12 @@
 				it += codesize;
 				LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionDefineFunction "<<name<<" "<<paramcount);
 				Activation_object* act = name == "" ? new_activationObject(wrk) : nullptr;
-				AVM1Function* f = Class<IFunction>::getAVM1Function(wrk,clip,act,context,paramnames,code);
+				AVM1Function* f = Class<IFunction>::getAVM1Function(wrk,clip,act,context,paramnames,code,context->scope);
 				//Create the prototype object
 				f->prototype = _MR(new_asobject(f->getSystemState()->worker));
 				f->prototype->addStoredMember();
 				if (name == "")
 				{
-					for (uint32_t i = 0; i < paramnames.size(); i++)
-					{
-						multiname m(nullptr);
-						m.name_type=multiname::NAME_STRING;
-						m.isAttribute = false;
-						m.name_s_id=paramnames[i];
-						asAtom v = locals[paramnames[i]];
-						ASATOM_INCREF(v);
-						act->setVariableByMultiname(m,v,ASObject::CONST_ALLOWED,nullptr,wrk);
-					}
 					asAtom a = asAtomHandler::fromObject(f);
 					PushStack(stack,a);
 				}
@@ -2664,18 +2760,18 @@
 					LOG(LOG_ERROR,"AVM1:"<<clip->getTagID()<<" no MovieClip for ActionCall "<<clip->toDebugString());
 					break;
 				}
-				if (asAtomHandler::isString(a))
-				{
-					tiny_string s = asAtomHandler::toString(a,wrk);
-					LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCall label "<<s);
-					clip->as<MovieClip>()->AVM1ExecuteFrameActionsFromLabel(s);
-				}
-				else
+				if (asAtomHandler::isNumeric(a))
 				{
 					uint32_t frame = asAtomHandler::toUInt(a);
 					LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCall frame "<<frame);
 					clip->as<MovieClip>()->AVM1ExecuteFrameActions(frame);
 				}
+				else
+				{
+					tiny_string s = asAtomHandler::AVM1toString(a,wrk);
+					LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" ActionCall label "<<s);
+					clip->as<MovieClip>()->AVM1ExecuteFrameActionsFromLabel(s);
+				}
 				ASATOM_DECREF(a);
 				break;
 			}
@@ -2779,10 +2875,9 @@
 			}
 			case 0x33: // ActionAsciiToChar
 			{
-				SystemState* sys = clip->getSystemState();
 				asAtom a = PopStack(stack);
 				uint16_t c = asAtomHandler::toUInt(a);
-				auto id = sys->getUniqueStringId(tiny_string::fromChar(c));
+				auto id = sys->getUniqueStringId(tiny_string::fromChar(c), true);
 				asAtom ret = asAtomHandler::fromStringID(id);
 				ASATOM_DECREF(a);
 				PushStack(stack,ret);
@@ -2831,14 +2926,18 @@
 		}
 		++context->actionsExecuted;
 	}
-	for (int i = 0; i <= curdepth; i++)
+
+	if (scope && isClosure)
 	{
-		ASATOM_DECREF(scopestack[i]);
+		scope->incRef();
+		context->scope = _MR(scope);
 	}
-	for (auto it = locals.begin(); it != locals.end(); it++)
+	else
 	{
-		ASATOM_DECREF(it->second);
+		context->scope.reset();
+		context->globalScope.reset();
 	}
+
 	for (uint32_t i = 0; i < 256; i++)
 	{
 		ASATOM_DECREF(registers[i]);
@@ -2851,13 +2950,16 @@
 	}
 	if (clip_isTarget)
 		clip->decRef();
-	if (argarray)
-		argarray->decRef();
+	if (argsArray != nullptr)
+		argsArray->decRef();
 	LOG_CALL("AVM1:"<<clip->getTagID()<<" "<<(clip->is<MovieClip>() ? clip->as<MovieClip>()->state.FP : 0)<<" executeActions done");
 	Log::calls_indent--;
 	context->callDepth--;
+	wrk->AVM1_cur_recursion_function--;
+	if (isInternalCall && !context->exceptionthrown)
+		wrk->AVM1_cur_recursion_internal--;
 	wrk->AVM1callStack.pop_back();
-	if (context->exceptionthrown && context->callDepth==0)
+	if (wrk->AVM1_cur_recursion_internal>65 || (context->exceptionthrown && context->callDepth==0 ))
 	{
 		if (wrk->AVM1callStack.empty())
 		{
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/DisplayObject.cpp lightspark-master/src/scripting/flash/display/DisplayObject.cpp
--- lightspark-0.9.0/src/scripting/flash/display/DisplayObject.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/DisplayObject.cpp	2025-03-05 20:13:02.167865251 +0100
@@ -51,6 +51,7 @@
 #include "scripting/toplevel/Global.h"
 #include "scripting/toplevel/Number.h"
 #include <algorithm>
+#include <array>
 
 // adobe seems to use twips as the base of the internal coordinate system, so we have to "round" coordinates to twips
 // TODO I think we should also use a twips-based coordinate system
@@ -2461,47 +2462,486 @@
 	}
 }
 
-multiname* DisplayObject::setVariableByMultiname(multiname& name, asAtom& o, CONST_ALLOWED_FLAG allowConst, bool *alreadyset, ASWorker* wrk)
+bool DisplayObject::isMouseEvent(uint32_t nameID) const
 {
-	multiname* res = EventDispatcher::setVariableByMultiname(name,o,allowConst,alreadyset,wrk);
-	if (!needsActionScript3())
+	return is<InteractiveObject>() &&
+	(
+		nameID == BUILTIN_STRINGS::STRING_ONMOUSEMOVE ||
+		nameID == BUILTIN_STRINGS::STRING_ONMOUSEDOWN ||
+		nameID == BUILTIN_STRINGS::STRING_ONMOUSEUP ||
+		nameID == BUILTIN_STRINGS::STRING_ONPRESS ||
+		nameID == BUILTIN_STRINGS::STRING_ONMOUSEWHEEL ||
+		nameID == BUILTIN_STRINGS::STRING_ONROLLOVER ||
+		nameID == BUILTIN_STRINGS::STRING_ONROLLOUT ||
+		nameID == BUILTIN_STRINGS::STRING_ONRELEASEOUTSIDE ||
+		nameID == BUILTIN_STRINGS::STRING_ONRELEASE
+	);
+}
+
+asAtom DisplayObject::getPropertyByIndex(size_t idx, ASWorker* wrk)
+{
+	auto sys = getSystemState();
+	asAtom ret = asAtomHandler::invalidAtom;
+	asAtom obj = asAtomHandler::fromObject(this);
+	switch (idx)
 	{
-		if (name.name_s_id == BUILTIN_STRINGS::STRING_ONENTERFRAME ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONLOAD)
+		case 0:// x
+			_getX(ret,wrk,obj,nullptr,0);
+			break;
+		case 1:// y
+			_getY(ret,wrk,obj,nullptr,0);
+			break;
+		case 2:// xscale
+			AVM1_getScaleX(ret,wrk,obj,nullptr,0);
+			break;
+		case 3:// xscale
+			AVM1_getScaleY(ret,wrk,obj,nullptr,0);
+			break;
+		case 4:// currentframe
+			if (is<MovieClip>())
+				MovieClip::_getCurrentFrame(ret,wrk,obj,nullptr,0);
+			break;
+		case 5:// totalframes
+			if (is<MovieClip>())
+				MovieClip::_getTotalFrames(ret,wrk,obj,nullptr,0);
+			break;
+		case 6:// alpha
+			AVM1_getAlpha(ret,wrk,obj,nullptr,0);
+			break;
+		case 7:// visible
+			_getVisible(ret,wrk,obj,nullptr,0);
+			break;
+		case 8:// width
+			_getWidth(ret,wrk,obj,nullptr,0);
+			break;
+		case 9:// height
+			_getHeight(ret,wrk,obj,nullptr,0);
+			break;
+		case 10:// rotation
+			_getRotation(ret,wrk,obj,nullptr,0);
+			break;
+		case 11:// target
+			ret = asAtomHandler::fromString(sys, AVM1GetPath());
+			break;
+		case 12:// framesloaded
+			if (is<MovieClip>())
+				MovieClip::_getFramesLoaded(ret,wrk,obj,nullptr,0);
+			break;
+		case 13:// name
+			_getter_name(ret,wrk,obj,nullptr,0);
+			break;
+		case 15:// url
+			return asAtomHandler::fromString(sys, sys->mainClip->getOrigin().getURL());
+			break;
+		case 17:// focusrect
+			if (is<InteractiveObject>())
+				InteractiveObject::AVM1_getfocusrect(ret,wrk,obj,nullptr,0);
+			break;
+		case 19:// quality
+			AVM1_getQuality(ret,wrk,obj,nullptr,0);
+			break;
+		case 20:// xmouse
+			_getMouseX(ret,wrk,obj,nullptr,0);
+			break;
+		case 21:// ymouse
+			_getMouseY(ret,wrk,obj,nullptr,0);
+			break;
+		default:
+			LOG(LOG_NOT_IMPLEMENTED, "getPropertyByIndex: Unknown property index " << idx);
+			break;
+	}
+	return ret;
+}
+
+void DisplayObject::setPropertyByIndex(size_t idx, const asAtom& val, ASWorker* wrk)
+{
+	asAtom ret = asAtomHandler::invalidAtom;
+	asAtom obj = asAtomHandler::fromObject(this);
+
+	asAtom value = val;
+	switch (idx)
+	{
+		case 0:// x
+			_setX(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 1:// y
+			_setY(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 2:// xscale
+			AVM1_setScaleX(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 3:// xscale
+			AVM1_setScaleY(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 6:// alpha
+			AVM1_setAlpha(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 7:// visible
+			_setVisible(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 8:// width
+			_setWidth(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 9:// height
+			_setHeight(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 10:// rotation
+			_setRotation(ret,wrk,obj,&value,1);
+			ASATOM_DECREF(value);
+			break;
+		case 13:// name
+			_setter_name(ret,wrk,obj,&value,1);
+			break;
+		case 17:// focusrect
+			if (is<InteractiveObject>())
+				InteractiveObject::AVM1_setfocusrect(ret,wrk,obj,&value,1);
+			break;
+		case 19:// quality
+			AVM1_setQuality(ret,wrk,obj,&value,1);
+			break;
+		default:
+			LOG(LOG_NOT_IMPLEMENTED, "setPropertyByIndex: Unknown property index " << idx);
+			break;
+	}
+}
+
+template<typename T, typename... Args>
+constexpr std::array<T, sizeof...(Args) + 1> makeArray(const T& arg, Args&&... args)
+{
+	return std::array<T, sizeof...(Args) + 1> { arg, args... };
+}
+
+// NOTE: Can't use `tiny_string` here because it isn't `constexpr`.
+static constexpr auto propTable = makeArray<const char*>
+(
+	"_x",
+	"_y",
+	"_xscale",
+	"_yscale",
+	"_currentframe",
+	"_totalframes",
+	"_alpha",
+	"_visible",
+	"_width",
+	"_height",
+	"_rotation",
+	"_target",
+	"_framesloaded",
+	"_name",
+	"_droptarget",
+	"_url",
+	"_highquality",
+	"_focusrect",
+	"_soundbuftime",
+	"_quality",
+	"_xmouse",
+	"_ymouse"
+);
+
+bool DisplayObject::hasPropertyName(const tiny_string& name) const
+{
+	return getPropertyIndex(name) != size_t(-1);
+}
+
+size_t DisplayObject::getPropertyIndex(const tiny_string& name) const
+{
+	auto it = std::find_if
+	(
+		propTable.begin(),
+		propTable.end(),
+		[&](const char* prop)
 		{
-			if (asAtomHandler::isFunction(o))
-			{
-				getSystemState()->registerFrameListener(this);
-				getSystemState()->stage->AVM1AddEventListener(this);
-				avm1framelistenercount++;
-				setIsEnumerable(name, false);
-			}
-			else // value is not a function, we remove the FrameListener
-			{
-				avm1framelistenercount--;
-				if (avm1framelistenercount==0)
-					getSystemState()->unregisterFrameListener(this);
-			}
+			return name.caselessEquals(prop);
 		}
-		if (this->is<InteractiveObject>() && (
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEMOVE ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEDOWN ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEUP ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONPRESS ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEWHEEL ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONROLLOVER ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONROLLOUT ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONRELEASEOUTSIDE ||
-			name.name_s_id == BUILTIN_STRINGS::STRING_ONRELEASE))
-		{
-			this->as<InteractiveObject>()->setMouseEnabled(true);
-			getSystemState()->stage->AVM1AddMouseListener(this);
-			avm1mouselistenercount++;
+	);
+	if (it == propTable.end())
+		return size_t(-1);
+	return std::distance(propTable.begin(), it);
+}
+
+asAtom DisplayObject::getPropertyByName(const tiny_string& name, ASWorker* wrk)
+{
+	return getPropertyByIndex(getPropertyIndex(name), wrk);
+}
+
+void DisplayObject::setPropertyByName(const tiny_string& name, const asAtom& value, ASWorker* wrk)
+{
+	setPropertyByIndex(getPropertyIndex(name), value, wrk);
+}
+
+static int parseLevelId(const tiny_string& digits)
+{
+	bool isNegative = digits.startsWith("-");
+
+	int levelID = 0;
+	for (size_t i = isNegative; i < digits.numChars() && isdigit(digits[i]); ++i)
+		levelID = (levelID * 10) + (digits[i] - '0');
+
+	return isNegative ? -levelID : levelID;
+}
+
+// TODO: Move this into `AVM1context`, once `originalclip` is moved into
+// there.
+DisplayObject* DisplayObject::getLevel(int levelID) const
+{
+	auto stage = AVM1getStage();
+	if (stage == nullptr)
+		return nullptr;
+	if (!stage->is<DisplayObjectContainer>())
+		return nullptr;
+	auto stageContainer = stage->as<DisplayObjectContainer>();
+	levelID -= 16384;
+	if (!stageContainer->hasLegacyChildAt(levelID))
+		return nullptr;
+	return stageContainer->getLegacyChildAt(levelID);
+}
+
+asAtom DisplayObject::resolvePathProperty(const tiny_string& name, ASWorker* wrk)
+{
+	auto sys = getSystemState();
+	bool caseSensitive = wrk->AVM1isCaseSensitive();
+
+	if (name.equalsWithCase("_root", caseSensitive))
+		return asAtomHandler::fromObject(AVM1getRoot());
+	else if (name.equalsWithCase("_parent", caseSensitive))
+	{
+		if (parent != nullptr)
+			return asAtomHandler::fromObject(parent);
+		return asAtomHandler::undefinedAtom;
+	}
+	else if (name.equalsWithCase("_global", caseSensitive))
+		return asAtomHandler::fromObject(sys->avm1global);
+
+	// Resolve level names (`_level<depth>`).
+	auto prefix = name.substr(0, 6);
+	bool isLevelName =
+	(
+		prefix.equalsWithCase("_level", caseSensitive) ||
+		// NOTE: `_flash` is an alias for `_level`, which is a relic of
+		// the earliest versions of Flash Player.
+		prefix.equalsWithCase("_flash", caseSensitive)
+	);
+
+	if (!isLevelName)
+		return asAtomHandler::invalidAtom;
+
+	auto levelClip = getLevel(parseLevelId(name.substr(6, UINT32_MAX)));
+	if (levelClip != nullptr)
+		return asAtomHandler::fromObject(levelClip);
+	return asAtomHandler::undefinedAtom;
+
+}
+
+GET_VARIABLE_RESULT DisplayObject::AVM1getVariableByMultiname
+(
+	asAtom& ret,
+	const multiname& name,
+	GET_VARIABLE_OPTION opt,
+	ASWorker* wrk,
+	bool isSlashPath
+)
+{
+	auto s = name.normalizedName(wrk);
+	bool caseSensitive = wrk->AVM1isCaseSensitive();
+
+	// Property search order for `DisplayObject`s.
+	// 1. Expandos (user defined properties on the underlying object).
+	auto result = ASObject::AVM1getVariableByMultiname
+	(
+		ret,
+		name,
+		opt,
+		wrk,
+		isSlashPath
+	);
+
+	if (asAtomHandler::isValid(ret))
+		return result;
+
+	result = GETVAR_NORMAL;
+
+	bool isInternalProp = s.startsWith("_");
+	// 2. Path properties. i.e. `_root`, `_parent`, `_level<depth>`
+	// (honours case sensitivity).
+	if (isInternalProp)
+		ret = resolvePathProperty(name.normalizedName(wrk), wrk);
+
+	if (asAtomHandler::isValid(ret))
+	{
+		ASATOM_INCREF(ret);
+		return result;
+	}
+
+	// 3. Child `DisplayObject`s with the supplied instance name.
+	auto child =
+	(
+		is<DisplayObjectContainer>() ?
+		as<DisplayObjectContainer>()->getLegacyChildByName
+		(
+			name.normalizedName(wrk),
+			caseSensitive
+		) : nullptr
+	);
+	if (child != nullptr)
+	{
+		// NOTE: If the object can't be represented as an AVM1 object,
+		// such as `Shape`, then any attempt to access it'll return the
+		// parent instead.
+		if (!isSlashPath && child->is<Shape>())
+			ret = asAtomHandler::fromObject(child->getParent());
+		else
+			ret = asAtomHandler::fromObject(child);
+		ASATOM_INCREF(ret);
+		return result;
+	}
+
+	// 4. Internal properties, such as `_x`, and `_y` (always case
+	// insensitive).
+	if (isInternalProp)
+		ret = getPropertyByName(s, wrk);
+
+	ASATOM_INCREF(ret);
+	return result;
+}
+
+bool DisplayObject::AVM1setLocalByMultiname
+(
+	multiname& name,
+	asAtom& value,
+	CONST_ALLOWED_FLAG allowConst,
+	ASWorker* wrk
+)
+{
+	assert(!needsActionScript3());
+	auto sys = getSystemState();
+
+	bool alreadySet = false;
+	bool caseSensitive = wrk->AVM1isCaseSensitive();
+	auto s = name.normalizedName(wrk);
+	auto nameID = sys->getUniqueStringId(s, caseSensitive);
+
+	// If a `TextField` was bound to this property, update it's text.
+	AVM1UpdateVariableBindings(nameID, value);
+
+	// Property search order for `DisplayObject`s.
+	// 1. Expandos (user defined properties on the underlying object).
+	if (ASObject::hasPropertyByMultiname(name, true, false, wrk))
+	{
+		EventDispatcher::setVariableByMultiname
+		(
+			name,
+			value,
+			allowConst,
+			&alreadySet,
+			wrk
+		);
+	}
+	// 2. Internal properties, such as `_x`, and `_y`.
+	else if (hasPropertyName(s))
+		setPropertyByName(s, value, wrk);
+	// 3. Prototype.
+	else if (hasprop_prototype())
+	{
+		auto proto = getprop_prototype();
+		alreadySet = proto->AVM1setLocalByMultiname(name, value, allowConst, wrk);
+	}
+	else
+	{
+		EventDispatcher::setVariableByMultiname
+		(
+			name,
+			value,
+			allowConst,
+			&alreadySet,
+			wrk
+		);
+	}
+
+	bool isFrameEvent =
+	(
+		name.name_s_id == BUILTIN_STRINGS::STRING_ONENTERFRAME ||
+		name.name_s_id == BUILTIN_STRINGS::STRING_ONLOAD
+	);
+
+	if (isFrameEvent)
+	{
+		if (asAtomHandler::isFunction(value))
+		{
+			sys->registerFrameListener(this);
+			sys->stage->AVM1AddEventListener(this);
+			avm1framelistenercount++;
 			setIsEnumerable(name, false);
 		}
+		else // value is not a function, we remove the FrameListener
+		{
+			avm1framelistenercount--;
+			if (avm1framelistenercount==0)
+				sys->unregisterFrameListener(this);
+		}
 	}
-	return res;
+	else if (isMouseEvent(name.name_s_id))
+	{
+		as<InteractiveObject>()->setMouseEnabled(true);
+		sys->stage->AVM1AddMouseListener(this);
+		avm1mouselistenercount++;
+		setIsEnumerable(name, false);
+	}
+	return alreadySet;
+}
+
+bool DisplayObject::hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype, ASWorker* wrk)
+{
+	if (needsActionScript3())
+	{
+		return ASObject::hasPropertyByMultiname
+		(
+			name,
+			considerDynamic,
+			considerPrototype,
+			wrk
+		);
+	}
+
+	auto s = name.normalizedName(wrk);
+	bool caseSensitive = wrk->AVM1isCaseSensitive();
+
+	bool isExpando = isOnStage() && ASObject::hasPropertyByMultiname
+	(
+		name,
+		considerDynamic,
+		considerPrototype,
+		wrk
+	);
+
+	if (isExpando)
+		return true;
+
+	bool isInternalProp = s.startsWith("_");
+	if (isInternalProp && hasPropertyName(s))
+		return true;
+
+	if (isOnStage() && is<DisplayObjectContainer>())
+	{
+		auto container = as<DisplayObjectContainer>();
+		if (container->hasLegacyChildByName(s, caseSensitive))
+			return true;
+	}
+
+	return
+	(
+		isInternalProp &&
+		asAtomHandler::isValid(resolvePathProperty(s, wrk))
+	);
 }
+
 void DisplayObject::AVM1registerPrototypeListeners()
 {
 	assert(!needsActionScript3());
@@ -2605,16 +3045,7 @@
 			if (avm1framelistenercount==0)
 				getSystemState()->unregisterFrameListener(this);
 		}
-		if (this->is<InteractiveObject>() && (
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEMOVE ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEDOWN ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEUP ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONPRESS ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONMOUSEWHEEL ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONROLLOVER ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONROLLOUT ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONRELEASEOUTSIDE ||
-				name.name_s_id == BUILTIN_STRINGS::STRING_ONRELEASE))
+		if (isMouseEvent(name.name_s_id))
 		{
 			this->as<InteractiveObject>()->setMouseEnabled(false);
 			avm1mouselistenercount--;
@@ -2943,80 +3374,30 @@
 	
 	c->destroyContents();
 	c->borrowedVariables.destroyContents();
-	c->setDeclaredMethodByQName("_x","",c->getSystemState()->getBuiltinFunction(_getX),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_x","",c->getSystemState()->getBuiltinFunction(_setX),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_y","",c->getSystemState()->getBuiltinFunction(_getY),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_y","",c->getSystemState()->getBuiltinFunction(_setY),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_visible","",c->getSystemState()->getBuiltinFunction(_getVisible),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_visible","",c->getSystemState()->getBuiltinFunction(_setVisible),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_xscale","",c->getSystemState()->getBuiltinFunction(AVM1_getScaleX),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_xscale","",c->getSystemState()->getBuiltinFunction(AVM1_setScaleX),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_yscale","",c->getSystemState()->getBuiltinFunction(AVM1_getScaleY),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_yscale","",c->getSystemState()->getBuiltinFunction(AVM1_setScaleY),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_width","",c->getSystemState()->getBuiltinFunction(_getWidth),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_width","",c->getSystemState()->getBuiltinFunction(_setWidth),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_height","",c->getSystemState()->getBuiltinFunction(_getHeight),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_height","",c->getSystemState()->getBuiltinFunction(_setHeight),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_parent","",c->getSystemState()->getBuiltinFunction(AVM1_getParent),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_root","",c->getSystemState()->getBuiltinFunction(AVM1_getRoot),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_url","",c->getSystemState()->getBuiltinFunction(AVM1_getURL),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("hitTest","",c->getSystemState()->getBuiltinFunction(AVM1_hitTest),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("localToGlobal","",c->getSystemState()->getBuiltinFunction(AVM1_localToGlobal),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("globalToLocal","",c->getSystemState()->getBuiltinFunction(AVM1_globalToLocal),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("getBytesLoaded","",c->getSystemState()->getBuiltinFunction(AVM1_getBytesLoaded),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("getBytesTotal","",c->getSystemState()->getBuiltinFunction(AVM1_getBytesTotal),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("_xmouse","",c->getSystemState()->getBuiltinFunction(_getMouseX),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_ymouse","",c->getSystemState()->getBuiltinFunction(_getMouseY),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_quality","",c->getSystemState()->getBuiltinFunction(AVM1_getQuality),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_quality","",c->getSystemState()->getBuiltinFunction(AVM1_setQuality),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_alpha","",c->getSystemState()->getBuiltinFunction(AVM1_getAlpha),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_alpha","",c->getSystemState()->getBuiltinFunction(AVM1_setAlpha),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("getBounds","",c->getSystemState()->getBuiltinFunction(AVM1_getBounds),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("swapDepths","",c->getSystemState()->getBuiltinFunction(AVM1_swapDepths),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("getDepth","",c->getSystemState()->getBuiltinFunction(AVM1_getDepth),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("setMask","",c->getSystemState()->getBuiltinFunction(_setMask),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("transform","",c->getSystemState()->getBuiltinFunction(_getTransform),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("transform","",c->getSystemState()->getBuiltinFunction(_setTransform),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_rotation","",c->getSystemState()->getBuiltinFunction(_getRotation),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("_rotation","",c->getSystemState()->getBuiltinFunction(_setRotation),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("toString","",c->getSystemState()->getBuiltinFunction(AVM1_toString,0,Class<ASString>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 	REGISTER_GETTER_SETTER_RESULTTYPE(c,scrollRect,Rectangle);
-	c->prototype->setDeclaredMethodByQName("_x","",c->getSystemState()->getBuiltinFunction(_getX),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_x","",c->getSystemState()->getBuiltinFunction(_setX),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_y","",c->getSystemState()->getBuiltinFunction(_getY),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_y","",c->getSystemState()->getBuiltinFunction(_setY),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_visible","",c->getSystemState()->getBuiltinFunction(_getVisible),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_visible","",c->getSystemState()->getBuiltinFunction(_setVisible),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_xscale","",c->getSystemState()->getBuiltinFunction(AVM1_getScaleX),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_xscale","",c->getSystemState()->getBuiltinFunction(AVM1_setScaleX),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_yscale","",c->getSystemState()->getBuiltinFunction(AVM1_getScaleY),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_yscale","",c->getSystemState()->getBuiltinFunction(AVM1_setScaleY),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_width","",c->getSystemState()->getBuiltinFunction(_getWidth),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_width","",c->getSystemState()->getBuiltinFunction(_setWidth),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_height","",c->getSystemState()->getBuiltinFunction(_getHeight),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_height","",c->getSystemState()->getBuiltinFunction(_setHeight),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_parent","",c->getSystemState()->getBuiltinFunction(AVM1_getParent),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_root","",c->getSystemState()->getBuiltinFunction(AVM1_getRoot),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_url","",c->getSystemState()->getBuiltinFunction(AVM1_getURL),GETTER_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("hitTest","",c->getSystemState()->getBuiltinFunction(AVM1_hitTest),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("localToGlobal","",c->getSystemState()->getBuiltinFunction(AVM1_localToGlobal),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("globalToLocal","",c->getSystemState()->getBuiltinFunction(AVM1_globalToLocal),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("getBytesLoaded","",c->getSystemState()->getBuiltinFunction(AVM1_getBytesLoaded),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("getBytesTotal","",c->getSystemState()->getBuiltinFunction(AVM1_getBytesTotal),NORMAL_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_xmouse","",c->getSystemState()->getBuiltinFunction(_getMouseX),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_ymouse","",c->getSystemState()->getBuiltinFunction(_getMouseY),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_quality","",c->getSystemState()->getBuiltinFunction(AVM1_getQuality),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_quality","",c->getSystemState()->getBuiltinFunction(AVM1_setQuality),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_alpha","",c->getSystemState()->getBuiltinFunction(AVM1_getAlpha),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_alpha","",c->getSystemState()->getBuiltinFunction(AVM1_setAlpha),SETTER_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("getBounds","",c->getSystemState()->getBuiltinFunction(AVM1_getBounds),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("swapDepths","",c->getSystemState()->getBuiltinFunction(AVM1_swapDepths),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("getDepth","",c->getSystemState()->getBuiltinFunction(AVM1_getDepth),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("setMask","",c->getSystemState()->getBuiltinFunction(_setMask),NORMAL_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("transform","",c->getSystemState()->getBuiltinFunction(_getTransform),GETTER_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("transform","",c->getSystemState()->getBuiltinFunction(_setTransform),SETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_rotation","",c->getSystemState()->getBuiltinFunction(_getRotation),GETTER_METHOD,false);
-	c->prototype->setDeclaredMethodByQName("_rotation","",c->getSystemState()->getBuiltinFunction(_setRotation),SETTER_METHOD,false);
 	c->prototype->setDeclaredMethodByQName("toString","",c->getSystemState()->getBuiltinFunction(AVM1_toString,0,Class<ASString>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,false);
 }
 DisplayObject *DisplayObject::AVM1GetClipFromPath(tiny_string &path, asAtom* member)
@@ -3031,7 +3412,7 @@
 	{
 		if (member)
 			*member=asAtomHandler::invalidAtom;
-		return this->getRoot().getPtr();
+		return this->AVM1getRoot();
 	}
 	if (path =="_parent")
 	{
@@ -3122,6 +3503,7 @@
 
 void DisplayObject::AVM1SetVariable(tiny_string &name, asAtom v, bool setMember)
 {
+	bool caseSensitive = loadedFrom->version > 6;
 	if (name.empty())
 		return;
 	if (name.startsWith("/"))
@@ -3138,10 +3520,14 @@
 	if (pos == tiny_string::npos)
 	{
 		ASATOM_INCREF(v); // ensure value is not destructed during binding
-		tiny_string localname = name.lowercase();
-		uint32_t nameIdOriginal = getSystemState()->getUniqueStringId(name);
-		uint32_t nameId = getSystemState()->getUniqueStringId(localname);
-		auto it = avm1variables.find(nameId);
+		auto nameID = getSystemState()->getUniqueStringId
+		(
+			name,
+			// NOTE: Internal property keys are always case insensitive
+			// (e.g. `_x`, `_y`, etc).
+			caseSensitive && !name.startsWith("_")
+		);
+		auto it = avm1variables.find(nameID);
 		if (it != avm1variables.end())
 		{
 			ASObject* o = asAtomHandler::getObject(it->second);
@@ -3149,19 +3535,19 @@
 				o->removeStoredMember();
 		}
 		if (asAtomHandler::isUndefined(v))
-			avm1variables.erase(nameId);
+			avm1variables.erase(nameID);
 		else
 		{
 			ASObject* o = asAtomHandler::getObject(v);
 			if (o)
 				o->addStoredMember();
-			avm1variables[nameId] = v;
+			avm1variables[nameID] = v;
 		}
 		if (setMember)
 		{
 			multiname objName(nullptr);
 			objName.name_type=multiname::NAME_STRING;
-			objName.name_s_id=nameIdOriginal;
+			objName.name_s_id=nameID;
 			ASObject* o = this;
 			while (o && !o->hasPropertyByMultiname(objName,true,true,loadedFrom->getInstanceWorker()))
 			{
@@ -3176,13 +3562,13 @@
 			if (alreadyset)
 				ASATOM_DECREF(v);
 		}
-		AVM1UpdateVariableBindings(nameId,v);
+		AVM1UpdateVariableBindings(nameID,v);
 		ASATOM_DECREF(v);
 	}
 	else if (pos == 0)
 	{
-		tiny_string localname = name.substr_bytes(pos+1,name.numBytes()-pos-1).lowercase();
-		uint32_t nameId = getSystemState()->getUniqueStringId(localname);
+		tiny_string localname = name.substr_bytes(pos+1,name.numBytes()-pos-1);
+		uint32_t nameId = getSystemState()->getUniqueStringId(localname, caseSensitive);
 		auto it = avm1variables.find(nameId);
 		if (it != avm1variables.end())
 		{
@@ -3247,22 +3633,24 @@
 
 asAtom DisplayObject::AVM1GetVariable(const tiny_string &name, bool checkrootvars)
 {
+	bool caseSensitive = loadedFrom->version > 6;
 	uint32_t pos = name.find(":");
 	if (pos == tiny_string::npos)
 	{
+		auto nameID = getSystemState()->getUniqueStringId(name, caseSensitive);
 		if (loadedFrom->version > 4 && getSystemState()->avm1global)
 		{
 			// first check for class names
 			asAtom ret=asAtomHandler::invalidAtom;
 			multiname m(nullptr);
 			m.name_type=multiname::NAME_STRING;
-			m.name_s_id=getSystemState()->getUniqueStringId(name);
+			m.name_s_id=nameID;
 			m.isAttribute = false;
 			getSystemState()->avm1global->getVariableByMultiname(ret,m,GET_VARIABLE_OPTION::NONE,getInstanceWorker());
 			if(!asAtomHandler::isInvalid(ret))
 				return ret;
 		}
-		auto it = avm1variables.find(getSystemState()->getUniqueStringId(name.lowercase()));
+		auto it = avm1variables.find(nameID);
 		if (it != avm1variables.end())
 		{
 			ASATOM_INCREF(it->second);
@@ -3272,7 +3660,7 @@
 	else if (pos == 0)
 	{
 		tiny_string localname = name.substr_bytes(pos+1,name.numBytes()-pos-1);
-		return AVM1GetVariable(localname.lowercase());
+		return AVM1GetVariable(localname);
 	}
 	else
 	{
@@ -3281,7 +3669,7 @@
 		if (clip)
 		{
 			tiny_string localname = name.substr_bytes(pos+1,name.numBytes()-pos-1);
-			return clip->AVM1GetVariable(localname.lowercase());
+			return clip->AVM1GetVariable(localname);
 		}
 	}
 	asAtom ret=asAtomHandler::invalidAtom;
@@ -3321,39 +3709,68 @@
 }
 void DisplayObject::AVM1UpdateVariableBindings(uint32_t nameID, asAtom& value)
 {
-	auto it = variablebindings.find(nameID);
-	while (it != variablebindings.end() && it->first == nameID)
+	auto pair = variablebindings.equal_range(nameID);
+	for (auto it = pair.first; it != pair.second; ++it)
 	{
-		ASATOM_INCREF(value); // ensure value is not destructed during binding
-		(*it).second->UpdateVariableBinding(value);
-		it++;
+		// Make sure that the value isn't `free()`'d while updating the
+		// bindings.
+		ASATOM_INCREF(value);
+		it->second->UpdateVariableBinding(value);
 		ASATOM_DECREF(value);
 	}
 }
+
 asAtom DisplayObject::getVariableBindingValue(const tiny_string &name)
 {
-	uint32_t pos = name.find(".");
-	asAtom ret=asAtomHandler::invalidAtom;
-	if (pos == tiny_string::npos)
-	{
-		ret = AVM1GetVariable(name);
-	}
-	else
-	{
-		tiny_string firstpart = name.substr_bytes(0,pos);
-		asAtom obj = AVM1GetVariable(firstpart);
-		if (asAtomHandler::isValid(obj))
-		{
-			tiny_string localname = name.substr_bytes(pos+1,name.numBytes()-pos-1);
-			ret = asAtomHandler::toObject(obj,getInstanceWorker())->getVariableBindingValue(localname);
-			ASATOM_DECREF(obj);
-		}
-	}
+	auto sys = getSystemState();
+	auto wrk = getInstanceWorker();
+
+	if (needsActionScript3())
+		return asAtomHandler::invalidAtom;
+
+	AVM1context fallback(_MR(this), sys);
+	const auto& ctx =
+	(
+		!wrk->AVM1callStack.empty() ?
+		*wrk->AVM1callStack.back() :
+		fallback
+	);
+
+	auto pair = ctx.resolveVariablePath
+	(
+		asAtomHandler::fromObject(this),
+		this,
+		_MR(this),
+		name
+	);
+
+	if (pair.first == nullptr)
+		return asAtomHandler::invalidAtom;
+
+	multiname m(nullptr);
+	m.name_type = multiname::NAME_STRING;
+	m.name_s_id = sys->getUniqueStringId
+	(
+		pair.second,
+		wrk->AVM1isCaseSensitive()
+	);
+
+	asAtom ret = asAtomHandler::invalidAtom;
+	pair.first->AVM1getVariableByMultiname
+	(
+		ret,
+		m,
+		GET_VARIABLE_OPTION::NONE,
+		wrk,
+		name.contains('/')
+	);
+	pair.first->decRef();
 	return ret;
 }
 void DisplayObject::setVariableBinding(tiny_string &name, _NR<DisplayObject> obj)
 {
-	uint32_t key = getSystemState()->getUniqueStringId(name);
+	bool caseSensitive = loadedFrom->version > 6;
+	uint32_t key = getSystemState()->getUniqueStringId(name, caseSensitive);
 	if (obj)
 	{
 		obj->incRef();
@@ -3375,10 +3792,10 @@
 }
 void DisplayObject::AVM1SetFunction(const tiny_string& name, _NR<AVM1Function> obj)
 {
-	uint32_t nameID = getSystemState()->getUniqueStringId(name);
-	uint32_t nameIDlower = getSystemState()->getUniqueStringId(name.lowercase());
+	bool caseSensitive = getInstanceWorker()->AVM1callStack.back()->isCaseSensitive();
+	uint32_t nameID = getSystemState()->getUniqueStringId(name, caseSensitive);
 	
-	auto it = avm1variables.find(nameIDlower);
+	auto it = avm1variables.find(nameID);
 	if (it != avm1variables.end())
 	{
 		if (obj && asAtomHandler::isObject(it->second) && asAtomHandler::getObjectNoCheck(it->second) == obj.getPtr())
@@ -3392,7 +3809,7 @@
 		asAtom v = asAtomHandler::fromObjectNoPrimitive(obj.getPtr());
 		obj->incRef();
 		obj->addStoredMember();
-		avm1variables[nameIDlower] = v;
+		avm1variables[nameID] = v;
 		
 		multiname objName(nullptr);
 		objName.name_type=multiname::NAME_STRING;
@@ -3405,7 +3822,7 @@
 	}
 	else
 	{
-		avm1variables.erase(nameIDlower);
+		avm1variables.erase(nameID);
 	}
 }
 AVM1Function* DisplayObject::AVM1GetFunction(uint32_t nameID)
@@ -3416,6 +3833,16 @@
 	return nullptr;
 }
 
+DisplayObject* DisplayObject::AVM1getStage() const
+{
+	if (parent == nullptr)
+		return const_cast<DisplayObject*>(this);
+
+	if (parent->is<Loader>() || parent->is<Stage>())
+		return parent;
+	return parent->AVM1getStage();
+}
+
 DisplayObject* DisplayObject::AVM1getRoot()
 {
 	if (this->needsActionScript3())
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/DisplayObject.h lightspark-master/src/scripting/flash/display/DisplayObject.h
--- lightspark-0.9.0/src/scripting/flash/display/DisplayObject.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/DisplayObject.h	2025-03-05 20:13:02.167865251 +0100
@@ -227,7 +227,21 @@
 	void globalToLocal(number_t xin, number_t yin, number_t& xout, number_t& yout, bool fromcurrentrendering=true) const;
 	float getConcatenatedAlpha() const;
 	virtual float getScaleFactor() const;
-	multiname* setVariableByMultiname(multiname& name, asAtom& o, CONST_ALLOWED_FLAG allowConst, bool* alreadyset, ASWorker* wrk) override;
+	bool isMouseEvent(uint32_t nameID) const;
+
+	asAtom getPropertyByIndex(size_t idx, ASWorker* wrk);
+	void setPropertyByIndex(size_t idx, const asAtom& value, ASWorker* wrk);
+	bool hasPropertyName(const tiny_string& name) const;
+	size_t getPropertyIndex(const tiny_string& name) const;
+	asAtom getPropertyByName(const tiny_string& name, ASWorker* wrk);
+	void setPropertyByName(const tiny_string& name, const asAtom& value, ASWorker* wrk);
+	DisplayObject* getLevel(int levelID) const;
+	asAtom resolvePathProperty(const tiny_string& name, ASWorker* wrk);
+
+	GET_VARIABLE_RESULT AVM1getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt, ASWorker* wrk, bool isSlashPath = true) override;
+	bool AVM1setLocalByMultiname(multiname& name, asAtom& value, CONST_ALLOWED_FLAG allowConst, ASWorker* wrk) override;
+	bool hasPropertyByMultiname(const multiname& name, bool considerDynamic, bool considerPrototype, ASWorker* wrk) override;
+
 	bool deleteVariableByMultiname(const multiname& name, ASWorker* wrk) override;
 	virtual void removeAVM1Listeners();
 	void AVM1registerPrototypeListeners();
@@ -375,6 +389,7 @@
 	void AVM1SetFunction(const tiny_string& name, _NR<AVM1Function> obj);
 	AVM1Function *AVM1GetFunction(uint32_t nameID);
 	virtual void AVM1AfterAdvance() {}
+	DisplayObject* AVM1getStage() const;
 	DisplayObject* AVM1getRoot();
 	std::string toDebugString() const override;
 };
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/flashdisplay.cpp lightspark-master/src/scripting/flash/display/flashdisplay.cpp
--- lightspark-0.9.0/src/scripting/flash/display/flashdisplay.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/flashdisplay.cpp	2025-03-05 20:13:02.171865349 +0100
@@ -728,6 +728,42 @@
 	return mapDepthToLegacyChild.at(depth);
 }
 
+bool DisplayObjectContainer::hasLegacyChildByName
+(
+	const tiny_string& name,
+	bool caseSensitive
+)
+{
+	for (const auto& pair : mapDepthToLegacyChild)
+	{
+		auto child = pair.second;
+		if (child->name == BUILTIN_STRINGS::EMPTY)
+			continue;
+		const auto& childName = getSystemState()->getStringFromUniqueId(child->name);
+		if (name.equalsWithCase(childName, caseSensitive))
+			return true;
+	}
+	return false;
+};
+
+DisplayObject* DisplayObjectContainer::getLegacyChildByName
+(
+	const tiny_string& name,
+	bool caseSensitive
+)
+{
+	for (const auto& pair : mapDepthToLegacyChild)
+	{
+		auto child = pair.second;
+		if (child->name == BUILTIN_STRINGS::EMPTY)
+			continue;
+		const auto& childName = getSystemState()->getStringFromUniqueId(child->name);
+		if (name.equalsWithCase(childName, caseSensitive))
+			return child;
+	}
+	return nullptr;
+}
+
 
 void DisplayObjectContainer::setupClipActionsAt(int32_t depth,const CLIPACTIONS& actions)
 {
@@ -777,8 +813,8 @@
 		objName.name_type=multiname::NAME_STRING;
 		objName.name_s_id=obj->name;
 		objName.ns.emplace_back(getSystemState(),BUILTIN_STRINGS::EMPTY,NAMESPACE);
-		setVariableByMultiname(objName,needsActionScript3() ? asAtomHandler::nullAtom : asAtomHandler::undefinedAtom, ASObject::CONST_NOT_ALLOWED,nullptr,loadedFrom->getInstanceWorker());
-		
+		if (this->hasPropertyByMultiname(objName,true,false,this->getInstanceWorker()))
+			setVariableByMultiname(objName,needsActionScript3() ? asAtomHandler::nullAtom : asAtomHandler::undefinedAtom, ASObject::CONST_NOT_ALLOWED,nullptr,loadedFrom->getInstanceWorker());
 	}
 	obj->placeFrame=UINT32_MAX;
 	obj->afterLegacyDelete(inskipping);
@@ -820,9 +856,10 @@
 			}
 		}
 	}
-	if (!this->loadedFrom->usesActionScript3 && obj->legacy && obj->name == BUILTIN_STRINGS::EMPTY && obj->is<InteractiveObject>())
+	bool needsDefaultName = obj->legacy && obj->name == BUILTIN_STRINGS::EMPTY && obj->is<InteractiveObject>();
+	if (needsDefaultName)
 	{
-		// AVM1 seems to assign a unique name "instance{x}" to all children that
+		// adobe seems to assign a unique name "instance{x}" to all children that
 		// - are InteractiveObjects (?) and
 		// - don't have a name and
 		// - are added by tags
@@ -833,7 +870,7 @@
 		tiny_string s(buf);
 		obj->name = getSystemState()->getUniqueStringId(s);
 	}
-	if(obj->name != BUILTIN_STRINGS::EMPTY)
+	if(obj->name != BUILTIN_STRINGS::EMPTY && !needsDefaultName)
 	{
 		multiname objName(nullptr);
 		objName.name_type=multiname::NAME_STRING;
@@ -910,7 +947,8 @@
 				objName.name_type=multiname::NAME_STRING;
 				objName.name_s_id=obj->name;
 				objName.ns.emplace_back(getSystemState(),BUILTIN_STRINGS::EMPTY,NAMESPACE);
-				setVariableByMultiname(objName,needsActionScript3() ? asAtomHandler::nullAtom : asAtomHandler::undefinedAtom,ASObject::CONST_NOT_ALLOWED,nullptr,loadedFrom->getInstanceWorker());
+				if (this->hasPropertyByMultiname(objName,true,false,this->getInstanceWorker()))
+					setVariableByMultiname(objName,needsActionScript3() ? asAtomHandler::nullAtom : asAtomHandler::undefinedAtom,ASObject::CONST_NOT_ALLOWED,nullptr,loadedFrom->getInstanceWorker());
 			}
 		}
 		i++;
@@ -2227,9 +2265,8 @@
 
 void AVM1scriptToExecute::execute()
 {
-	std::map<uint32_t, asAtom> scopevariables;
 	if (actions)
-		ACTIONRECORD::executeActions(clip,avm1context,*actions, startactionpos,scopevariables);
+		ACTIONRECORD::executeActions(clip,avm1context,*actions, startactionpos);
 	if (this->event_name_id != UINT32_MAX)
 	{
 		asAtom func=asAtomHandler::invalidAtom;
@@ -2237,7 +2274,7 @@
 		m.name_type=multiname::NAME_STRING;
 		m.isAttribute = false;
 		m.name_s_id= this->event_name_id;
-		clip->AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,clip->getInstanceWorker());
+		clip->AVM1getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,clip->getInstanceWorker(), false);
 		if (asAtomHandler::is<AVM1Function>(func))
 		{
 			asAtom ret=asAtomHandler::invalidAtom;
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/flashdisplay.h lightspark-master/src/scripting/flash/display/flashdisplay.h
--- lightspark-0.9.0/src/scripting/flash/display/flashdisplay.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/flashdisplay.h	2025-03-05 20:13:02.171865349 +0100
@@ -83,6 +83,10 @@
 		else
 			return true;
 	}
+	virtual bool isFocusable()
+	{
+		return true;
+	}
 	InteractiveObject(ASWorker* wrk,Class_base* c);
 	ASPROPERTY_GETTER_SETTER(_NR<AccessibilityImplementation>,accessibilityImplementation);
 	ASPROPERTY_GETTER_SETTER(_NR<ASObject>,contextMenu); // adobe seems to allow DisplayObjects, too
@@ -181,6 +185,8 @@
 	bool hasLegacyChildAt(int32_t depth);
 	// this does not test if a DisplayObject exists at the provided depth
 	DisplayObject* getLegacyChildAt(int32_t depth);
+	bool hasLegacyChildByName(const tiny_string& name, bool caseSensitive);
+	DisplayObject* getLegacyChildByName(const tiny_string& name, bool caseSensitive);
 	void setupClipActionsAt(int32_t depth, const CLIPACTIONS& actions);
 	void checkRatioForLegacyChildAt(int32_t depth, uint32_t ratio, bool inskipping);
 	void checkColorTransformForLegacyChildAt(int32_t depth, const CXFORMWITHALPHA& colortransform);
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/MovieClip.cpp lightspark-master/src/scripting/flash/display/MovieClip.cpp
--- lightspark-0.9.0/src/scripting/flash/display/MovieClip.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/MovieClip.cpp	2025-03-05 20:13:02.169865300 +0100
@@ -757,6 +757,7 @@
 {
 	getSystemState()->stage->AVM1RemoveMouseListener(this);
 	getSystemState()->stage->AVM1RemoveKeyboardListener(this);
+	Sprite::afterLegacyDelete(inskipping);
 }
 bool MovieClip::AVM1HandleKeyboardEvent(KeyboardEvent *e)
 {
@@ -821,8 +822,7 @@
 			}
 			if (exec)
 			{
-				std::map<uint32_t,asAtom> m;
-				ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
+				ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 			}
 		}
 	}
@@ -858,8 +858,7 @@
 					|| (e->type == "mouseMove" && it->EventFlags.ClipEventMouseMove)
 					)
 				{
-					std::map<uint32_t,asAtom> m;
-					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
+					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 				}
 				if( dispobj &&
 					((e->type == "mouseUp" && it->EventFlags.ClipEventRelease)
@@ -869,8 +868,7 @@
 					|| (e->type == "releaseOutside" && it->EventFlags.ClipEventReleaseOutside)
 					))
 				{
-					std::map<uint32_t,asAtom> m;
-					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
+					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 				}
 			}
 		}
@@ -880,7 +878,6 @@
 }
 void MovieClip::AVM1HandleEvent(EventDispatcher *dispatcher, Event* e)
 {
-	std::map<uint32_t,asAtom> m;
 	if (dispatcher == this)
 	{
 		if (this->actions)
@@ -889,7 +886,7 @@
 			{
 				if (e->type == "complete" && it->EventFlags.ClipEventLoad)
 				{
-					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
+					ACTIONRECORD::executeActions(this,this->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 				}
 			}
 		}
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/MovieClip.h lightspark-master/src/scripting/flash/display/MovieClip.h
--- lightspark-0.9.0/src/scripting/flash/display/MovieClip.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/MovieClip.h	2025-03-05 20:13:02.169865300 +0100
@@ -21,6 +21,7 @@
 #define SCRIPTING_FLASH_DISPLAY_MOVIECLIP_H 1
 
 #include "scripting/flash/display/flashdisplay.h"
+#include "scripting/avm1/scope.h"
 
 namespace lightspark
 {
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/RootMovieClip.cpp lightspark-master/src/scripting/flash/display/RootMovieClip.cpp
--- lightspark-0.9.0/src/scripting/flash/display/RootMovieClip.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/RootMovieClip.cpp	2025-03-05 20:13:02.170865325 +0100
@@ -167,7 +167,7 @@
 	}
 	// add to stage before continuing construction to make sure stage is available from AS code
 	incRef();
-	getSystemState()->stage->_addChildAt(this,0);
+	getSystemState()->stage->insertLegacyChildAt(-16384, this, false, false);
 
 	MovieClip::constructionComplete(_explicit);
 
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/SimpleButton.cpp lightspark-master/src/scripting/flash/display/SimpleButton.cpp
--- lightspark-0.9.0/src/scripting/flash/display/SimpleButton.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/SimpleButton.cpp	2025-03-05 20:13:02.170865325 +0100
@@ -99,7 +99,7 @@
 		if (dispobj!= this)
 			return false;
 	}
-	BUTTONSTATE oldstate = currentState;
+	oldstate = currentState;
 	if(e->type == "mouseDown")
 	{
 		currentState = DOWN;
@@ -120,7 +120,6 @@
 		currentState = STATE_OUT;
 		reflectState(oldstate);
 	}
-	bool handled = false;
 	if (buttontag)
 	{
 		for (auto it = buttontag->condactions.begin(); it != buttontag->condactions.end(); it++)
@@ -130,7 +129,6 @@
 				||(it->CondOutDownToOverDown && oldstate==DOWN && currentState==OVER)
 				||(it->CondOverDownToOutDown && (oldstate==DOWN || oldstate==OVER) && currentState==STATE_OUT)
 				||(it->CondOverDownToOverUp && (oldstate==DOWN || oldstate==OVER) && currentState==UP)
-				||(it->CondOverUpToOverDown && (oldstate==UP || oldstate==OVER) && currentState==DOWN)
 				||(it->CondOverUpToIdle && (oldstate==UP || oldstate==OVER) && currentState==STATE_OUT)
 				||(it->CondIdleToOverUp && oldstate==STATE_OUT && currentState==OVER)
 				||(it->CondOverDownToIdle && oldstate==DOWN && currentState==OVER)
@@ -141,18 +139,34 @@
 					c = c->getParent();
 				if (c)
 				{
-					std::map<uint32_t,asAtom> m;
-					ACTIONRECORD::executeActions(c->as<MovieClip>(),c->as<MovieClip>()->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
-					handled = true;
+					ACTIONRECORD::executeActions(c->as<MovieClip>(),c->as<MovieClip>()->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 				}
-				
 			}
 		}
 	}
-	handled |= AVM1HandleMouseEventStandard(dispobj,e);
-	return handled;
+	return AVM1HandleMouseEventStandard(dispobj,e);
+}
+void SimpleButton::AVM1HandlePressedEvent(ASObject* dispatcher)
+{
+	if (buttontag)
+	{
+		for (auto it = buttontag->condactions.begin(); it != buttontag->condactions.end(); it++)
+		{
+			if ((it->CondOverUpToOverDown && (oldstate==UP || oldstate==OVER) && currentState==DOWN)
+				)
+			{
+				DisplayObjectContainer* c = getParent();
+				while (c && !c->is<MovieClip>())
+					c = c->getParent();
+				if (c)
+				{
+					ACTIONRECORD::executeActions(c->as<MovieClip>(),c->as<MovieClip>()->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
+				}
+			}
+		}
+	}
+	DisplayObjectContainer::AVM1HandlePressedEvent(dispatcher);
 }
-
 void SimpleButton::handleMouseCursor(bool rollover)
 {
 	if (rollover)
@@ -315,8 +329,7 @@
 			DisplayObjectContainer* c = getParent();
 			while (c && !c->is<MovieClip>())
 				c = c->getParent();
-			std::map<uint32_t,asAtom> m;
-			ACTIONRECORD::executeActions(c->as<MovieClip>(),c->as<MovieClip>()->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos,m);
+			ACTIONRECORD::executeActions(c->as<MovieClip>(),c->as<MovieClip>()->getCurrentFrame()->getAVM1Context(),it->actions,it->startactionpos);
 			handled=true;
 		}
 	}
@@ -443,7 +456,7 @@
 SimpleButton::SimpleButton(ASWorker* wrk, Class_base* c, DisplayObject *dS, DisplayObject *hTS,
 				DisplayObject *oS, DisplayObject *uS, DefineButtonTag *tag)
 	: DisplayObjectContainer(wrk,c), downState(dS), hitTestState(hTS), overState(oS), upState(uS),
-	  buttontag(tag),currentState(STATE_OUT),enabled(true),useHandCursor(true),hasMouse(false)
+	  buttontag(tag),currentState(STATE_OUT),oldstate(STATE_OUT),enabled(true),useHandCursor(true),hasMouse(false)
 {
 	subtype = SUBTYPE_SIMPLEBUTTON;
 	/* When called from DefineButton2Tag::instance, they are not constructed yet
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/SimpleButton.h lightspark-master/src/scripting/flash/display/SimpleButton.h
--- lightspark-0.9.0/src/scripting/flash/display/SimpleButton.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/SimpleButton.h	2025-03-05 20:13:02.170865325 +0100
@@ -53,6 +53,7 @@
 		STATE_OUT
 	};
 	BUTTONSTATE currentState;
+	BUTTONSTATE oldstate;
 	bool enabled;
 	bool useHandCursor;
 	bool hasMouse;
@@ -95,6 +96,7 @@
 	void afterLegacyDelete(bool inskipping) override;
 	bool AVM1HandleKeyboardEvent(KeyboardEvent* e) override;
 	bool AVM1HandleMouseEvent(EventDispatcher* dispatcher, MouseEvent *e) override;
+	void AVM1HandlePressedEvent(ASObject* dispatcher) override;
 	void handleMouseCursor(bool rollover) override;
 	bool allowAsMask() const override
 	{
diff -u -r -N lightspark-0.9.0/src/scripting/flash/display/Stage.cpp lightspark-master/src/scripting/flash/display/Stage.cpp
--- lightspark-0.9.0/src/scripting/flash/display/Stage.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/display/Stage.cpp	2025-03-05 20:13:02.170865325 +0100
@@ -300,7 +300,10 @@
 	if (nativeWindow)
 		nativeWindow->prepareShutdown();
 	if (focus)
+	{
 		focus->prepareShutdown();
+		focus.reset();
+	}
 	if (root)
 		root->prepareShutdown();
 	avm1KeyboardListeners.clear();
@@ -515,16 +518,24 @@
 void Stage::setFocusTarget(_NR<InteractiveObject> f)
 {
 	Locker l(focusSpinlock);
+	if (f==focus || (f && !f->isFocusable()))
+		return;
+	_NR<InteractiveObject> oldfocus = focus;
 	if (focus)
 	{
 		focus->lostFocus();
-		getVm(getSystemState())->addEvent(_MR(focus),_MR(Class<FocusEvent>::getInstanceS(getInstanceWorker(),"focusOut")));
+		_NR<InteractiveObject> newfocus = f;
+		if (newfocus && (newfocus.getPtr()==this || newfocus.getPtr()->is<RootMovieClip>()))
+			newfocus.reset();
+		getVm(getSystemState())->addEvent(_MR(focus),_MR(Class<FocusEvent>::getInstanceS(getInstanceWorker(),"focusOut",newfocus)));
 	}
 	focus = f;
 	if (focus)
 	{
 		focus->gotFocus();
-		getVm(getSystemState())->addEvent(_MR(focus),_MR(Class<FocusEvent>::getInstanceS(getInstanceWorker(),"focusIn")));
+		if (oldfocus && (oldfocus.getPtr()==this || oldfocus.getPtr()->is<RootMovieClip>()))
+			oldfocus.reset();
+		getVm(getSystemState())->addEvent(_MR(focus),_MR(Class<FocusEvent>::getInstanceS(getInstanceWorker(),"focusIn",oldfocus)));
 	}
 }
 
@@ -815,17 +826,40 @@
 	else if (e->is<MouseEvent>())
 	{
 		avm1listenerMutex.lock();
+		// eventhandlers may change the listener list, so we work on a copy
 		vector<ASObject*> tmplisteners = avm1MouseListeners;
 		for (auto it = tmplisteners.begin(); it != tmplisteners.end(); it++)
 			(*it)->incRef();
 		avm1listenerMutex.unlock();
-		// eventhandlers may change the listener list, so we work on a copy
-		auto it = tmplisteners.rbegin();
-		while (it != tmplisteners.rend())
+		if (e->type=="mouseDown")
 		{
-			(*it)->AVM1HandleMouseEvent(dispatcher, e->as<MouseEvent>());
-			(*it)->decRef();
-			it++;
+			// AVM1 mouseDown events trigger multiple handlers that have to be handled in the correct order:
+			// - onMouseDown
+			// - onSetFocus
+			// - onPressed
+			for (auto it = tmplisteners.rbegin(); it != tmplisteners.rend(); it++)
+			{
+				(*it)->AVM1HandleMouseEvent(dispatcher, e->as<MouseEvent>());
+			}
+			for (auto it = tmplisteners.rbegin(); it != tmplisteners.rend(); it++)
+			{
+				(*it)->AVM1HandleSetFocusEvent(dispatcher);
+			}
+			for (auto it = tmplisteners.rbegin(); it != tmplisteners.rend(); it++)
+			{
+				(*it)->AVM1HandlePressedEvent(dispatcher);
+				(*it)->decRef();
+			}
+		}
+		else
+		{
+			auto it = tmplisteners.rbegin();
+			while (it != tmplisteners.rend())
+			{
+				(*it)->AVM1HandleMouseEvent(dispatcher, e->as<MouseEvent>());
+				(*it)->decRef();
+				it++;
+			}
 		}
 	}
 	else
@@ -857,7 +891,7 @@
 				multiname m(nullptr);
 				m.name_type=multiname::NAME_STRING;
 				m.isAttribute = false;
-				m.name_s_id=getSystemState()->getUniqueStringId("onResize");
+				m.name_s_id=BUILTIN_STRINGS::STRING_ONRESIZE;
 				(*it)->getVariableByMultiname(func,m,GET_VARIABLE_OPTION::NONE,getInstanceWorker());
 				if (asAtomHandler::is<AVM1Function>(func))
 				{
@@ -998,8 +1032,9 @@
 {
 	Stage* th=asAtomHandler::as<Stage>(obj);
 	_NR<InteractiveObject> focus = th->getFocusTarget();
-	if (focus.isNull())
+	if (focus.isNull() || focus.getPtr()==th || focus->is<RootMovieClip>())
 	{
+		ret = asAtomHandler::nullAtom;
 		return;
 	}
 	else
diff -u -r -N lightspark-0.9.0/src/scripting/flash/errors/flasherrors.h lightspark-master/src/scripting/flash/errors/flasherrors.h
--- lightspark-0.9.0/src/scripting/flash/errors/flasherrors.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/errors/flasherrors.h	2025-03-05 20:13:02.173865398 +0100
@@ -87,7 +87,7 @@
 {
 public:
 	StackOverflowError(ASWorker* wrk,Class_base* c, const tiny_string& error_message = "", int id = 0):
-		ASError(wrk,c, error_message, id, "StackOverflowError"){}
+		ASError(wrk,c, error_message, id, "StackOverflowError",SUBTYPE_STACKOVERFLOWERROR){}
 	ASFUNCTION_ATOM(_constructor);
 	static void sinit(Class_base* c);
 	static void buildTraits(ASObject* o);
diff -u -r -N lightspark-0.9.0/src/scripting/flash/events/flashevents.cpp lightspark-master/src/scripting/flash/events/flashevents.cpp
--- lightspark-0.9.0/src/scripting/flash/events/flashevents.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/events/flashevents.cpp	2025-03-05 20:13:02.173865398 +0100
@@ -141,7 +141,7 @@
 	c->setVariableAtomByQName("VIDEO_FRAME",nsNameAndKind(),asAtomHandler::fromString(c->getSystemState(),"videoFrame"),DECLARED_TRAIT);
 	c->setVariableAtomByQName("WORKER_STATE",nsNameAndKind(),asAtomHandler::fromString(c->getSystemState(),"workerState"),DECLARED_TRAIT);
 
-	c->setDeclaredMethodByQName("formatToString","",c->getSystemState()->getBuiltinFunction(formatToString),NORMAL_METHOD,true);
+	c->setDeclaredMethodByQName("formatToString","",c->getSystemState()->getBuiltinFunction(formatToString,1,Class<ASString>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("isDefaultPrevented","",c->getSystemState()->getBuiltinFunction(_isDefaultPrevented),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("preventDefault","",c->getSystemState()->getBuiltinFunction(_preventDefault),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("clone","",c->getSystemState()->getBuiltinFunction(clone),NORMAL_METHOD,true);
@@ -281,8 +281,16 @@
 	c->setVariableAtomByQName("AT_TARGET",nsNameAndKind(),asAtomHandler::fromUInt(AT_TARGET),DECLARED_TRAIT);
 }
 
-FocusEvent::FocusEvent(ASWorker* wrk, Class_base* c, tiny_string _type):Event(wrk,c, _type,true)
+FocusEvent::FocusEvent(ASWorker* wrk, Class_base* c)
+	:Event(wrk,c, "focusEvent",true),relatedObject(NullRef)
 {
+	subtype=SUBTYPE_FOCUSEVENT;
+}
+
+FocusEvent::FocusEvent(ASWorker* wrk, Class_base* c, tiny_string _type, _NR<InteractiveObject> _relatedObject)
+	:Event(wrk,c, _type,true),relatedObject(_relatedObject)
+{
+	subtype=SUBTYPE_FOCUSEVENT;
 }
 
 void FocusEvent::sinit(Class_base* c)
@@ -292,7 +300,9 @@
 	c->setVariableAtomByQName("FOCUS_OUT",nsNameAndKind(),asAtomHandler::fromString(c->getSystemState(),"focusOut"),DECLARED_TRAIT);
 	c->setVariableAtomByQName("MOUSE_FOCUS_CHANGE",nsNameAndKind(),asAtomHandler::fromString(c->getSystemState(),"mouseFocusChange"),DECLARED_TRAIT);
 	c->setVariableAtomByQName("KEY_FOCUS_CHANGE",nsNameAndKind(),asAtomHandler::fromString(c->getSystemState(),"keyFocusChange"),DECLARED_TRAIT);
+	REGISTER_GETTER_RESULTTYPE(c,relatedObject,InteractiveObject);
 }
+ASFUNCTIONBODY_GETTER_SETTER(FocusEvent,relatedObject)
 
 ASFUNCTIONBODY_ATOM(FocusEvent,_constructor)
 {
@@ -919,6 +929,7 @@
 		//Clone always exists since it's implemented in Event itself
 		if(!asAtomHandler::getObject(cloned) || !asAtomHandler::getObject(cloned)->is<Event>())
 		{
+			ASATOM_DECREF(cloned);
 			asAtomHandler::setBool(ret,false);
 			return;
 		}
diff -u -r -N lightspark-0.9.0/src/scripting/flash/events/flashevents.h lightspark-master/src/scripting/flash/events/flashevents.h
--- lightspark-0.9.0/src/scripting/flash/events/flashevents.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/events/flashevents.h	2025-03-05 20:13:02.173865398 +0100
@@ -138,9 +138,11 @@
 class FocusEvent: public Event
 {
 public:
-	FocusEvent(ASWorker* wrk,Class_base* c, tiny_string _type="focusEvent");
+	FocusEvent(ASWorker* wrk, Class_base* c);
+	FocusEvent(ASWorker* wrk, Class_base* c, tiny_string _type,_NR<InteractiveObject> _relatedObject=NullRef);
 	static void sinit(Class_base*);
 	ASFUNCTION_ATOM(_constructor);
+	ASPROPERTY_GETTER_SETTER(_NR<InteractiveObject>, relatedObject);
 };
 
 class FullScreenEvent: public Event
diff -u -r -N lightspark-0.9.0/src/scripting/flash/filters/BlurFilter.cpp lightspark-master/src/scripting/flash/filters/BlurFilter.cpp
--- lightspark-0.9.0/src/scripting/flash/filters/BlurFilter.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/filters/BlurFilter.cpp	2025-03-05 20:13:02.174865423 +0100
@@ -64,10 +64,11 @@
 
 	uint32_t width = sourceRect.Xmax-sourceRect.Xmin;
 	uint32_t height = sourceRect.Ymax-sourceRect.Ymin;
+	uint32_t targetwidth = target->getWidth();
 	uint8_t* data = target->getData();
 	for (uint32_t i = 0; i < height; i++)
 	{
-		memcpy(data+((int(ypos)+i)*width+int(xpos))*4, tmpdata+i*width*4,width*4);
+		memcpy(data+((int(ypos)+i)*targetwidth+int(xpos))*4, tmpdata+i*width*4,width*4);
 	}
 	delete[] tmpdata;
 }
diff -u -r -N lightspark-0.9.0/src/scripting/flash/geom/flashgeom.cpp lightspark-master/src/scripting/flash/geom/flashgeom.cpp
--- lightspark-0.9.0/src/scripting/flash/geom/flashgeom.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/geom/flashgeom.cpp	2025-03-05 20:13:02.175865447 +0100
@@ -21,11 +21,13 @@
 #include "scripting/flash/geom/flashgeom.h"
 #include "scripting/flash/geom/Matrix3D.h"
 #include "scripting/flash/geom/Point.h"
+#include "scripting/flash/geom/Rectangle.h"
 #include "scripting/argconv.h"
 #include "scripting/toplevel/Number.h"
 #include "scripting/toplevel/UInteger.h"
 #include "scripting/toplevel/Vector.h"
 #include "scripting/flash/display/BitmapContainer.h"
+#include "scripting/flash/display/Stage.h"
 
 using namespace lightspark;
 using namespace std;
@@ -351,6 +353,8 @@
 	c->setDeclaredMethodByQName("matrix","",c->getSystemState()->getBuiltinFunction(_setMatrix),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("matrix","",c->getSystemState()->getBuiltinFunction(_getMatrix,0,Class<Matrix>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("concatenatedMatrix","",c->getSystemState()->getBuiltinFunction(_getConcatenatedMatrix,0,Class<Matrix>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("pixelBounds","",c->getSystemState()->getBuiltinFunction(_getPixelBounds,0,Class<Rectangle>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("getRelativeMatrix3D","",c->getSystemState()->getBuiltinFunction(getRelativeMatrix3D,1,Class<Matrix3D>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 	REGISTER_GETTER_SETTER_RESULTTYPE(c, perspectiveProjection, PerspectiveProjection);
 	REGISTER_GETTER_SETTER_RESULTTYPE(c, matrix3D, Matrix3D);
 }
@@ -424,7 +428,47 @@
 ASFUNCTIONBODY_ATOM(Transform,_getConcatenatedMatrix)
 {
 	Transform* th=asAtomHandler::as<Transform>(obj);
-	ret = asAtomHandler::fromObject(Class<Matrix>::getInstanceS(wrk,th->owner->getConcatenatedMatrix()));
+	ret = asAtomHandler::fromObject(Class<Matrix>::getInstanceS(wrk,th->getConcatenatedMatrix()));
+}
+MATRIX Transform::getConcatenatedMatrix()
+{
+	MATRIX m = owner->getConcatenatedMatrix(true);
+	if (!owner->isOnStage() || owner->is<Stage>())
+	{
+		// for some strange reason the stage quality seems to affect the concatenated matrix if we are not on stage
+		// see https://stackoverflow.com/questions/72766754/flash-stage-quality-affects-displayobject-transform-concatenatedmatrix-scali
+		MATRIX sm;
+		tiny_string s= getSystemState()->stage->quality;
+		if (s == "low")
+			sm.scale(20.0,20.0);
+		else if (s == "medium")
+			sm.scale(10.0,10.0);
+		else if (s == "best" || s=="high")
+			sm.scale(5.0,5.0);
+		else if (s == "8x8" || s=="8x8linear")
+			sm.scale(2.5,2.5);
+		else if (s == "16x16" || s=="16x16linear")
+			sm.scale(1.25,1.25);
+		m = m.multiplyMatrix(sm);
+	}
+	return m;
+}
+ASFUNCTIONBODY_ATOM(Transform,_getPixelBounds)
+{
+	Transform* th=asAtomHandler::as<Transform>(obj);
+	assert_and_throw(argslen==0);
+	Rectangle* rc = Class<Rectangle>::getInstanceSNoArgs(wrk);
+	number_t xmax,ymax;
+	MATRIX m = th->getConcatenatedMatrix();
+	th->owner->getBounds(rc->x,xmax,rc->y,ymax,m);
+	rc->width=xmax-rc->x;
+	rc->height=ymax-rc->y;
+	ret = asAtomHandler::fromObject(rc);
+}
+ASFUNCTIONBODY_ATOM(Transform,getRelativeMatrix3D)
+{
+	//Transform* th=asAtomHandler::as<Transform>(obj);
+	LOG(LOG_NOT_IMPLEMENTED,"Transform.getRelativeMatrix3D");
 }
 
 Matrix::Matrix(ASWorker* wrk, Class_base* c):ASObject(wrk,c,T_OBJECT,SUBTYPE_MATRIX)
diff -u -r -N lightspark-0.9.0/src/scripting/flash/geom/flashgeom.h lightspark-master/src/scripting/flash/geom/flashgeom.h
--- lightspark-0.9.0/src/scripting/flash/geom/flashgeom.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/geom/flashgeom.h	2025-03-05 20:13:02.175865447 +0100
@@ -132,6 +132,7 @@
 private:
 	_NR<DisplayObject> owner;
 	void onSetMatrix3D(_NR<Matrix3D> oldValue);
+	MATRIX getConcatenatedMatrix();
 public:
 	Transform(ASWorker* wrk,Class_base* c);
 	Transform(ASWorker* wrk, Class_base* c, _R<DisplayObject> o);
@@ -146,6 +147,8 @@
 	ASFUNCTION_ATOM(_getMatrix);
 	ASFUNCTION_ATOM(_setMatrix);
 	ASFUNCTION_ATOM(_getConcatenatedMatrix);
+	ASFUNCTION_ATOM(_getPixelBounds);
+	ASFUNCTION_ATOM(getRelativeMatrix3D);
 	ASPROPERTY_GETTER_SETTER(_NR<PerspectiveProjection>, perspectiveProjection);
 	ASPROPERTY_GETTER_SETTER(_NR<Matrix3D>, matrix3D);
 
diff -u -r -N lightspark-0.9.0/src/scripting/flash/net/flashnet.cpp lightspark-master/src/scripting/flash/net/flashnet.cpp
--- lightspark-0.9.0/src/scripting/flash/net/flashnet.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/net/flashnet.cpp	2025-03-05 20:13:02.179865545 +0100
@@ -2410,7 +2410,7 @@
 			nameStart=cur;
 		if(*cur == '=')
 		{
-			if(nameStart==nullptr || valueStart!=nullptr) //Skip this
+			if(nameStart==nullptr) //Skip this
 			{
 				nameStart=nullptr;
 				nameEnd=nullptr;
@@ -2419,8 +2419,11 @@
 				cur++;
 				continue;
 			}
-			nameEnd=cur;
-			valueStart=cur+1;
+			if (nameEnd==nullptr)
+			{
+				nameEnd=cur;
+				valueStart=cur+1;
+			}
 		}
 		else if(*cur == '&' || *cur==0)
 		{
@@ -2430,6 +2433,8 @@
 				nameEnd=nullptr;
 				valueStart=nullptr;
 				valueEnd=nullptr;
+				if (*cur==0)
+					break;
 				cur++;
 				continue;
 			}
@@ -2444,6 +2449,8 @@
 			{
 				g_free(name);
 				g_free(value);
+				if (*cur==0)
+					break;
 				cur++;
 				continue;
 			}
@@ -2455,7 +2462,7 @@
 			propName.ns.push_back(nsNameAndKind(getSystemState(),"",NAMESPACE));
 			asAtom curValue=asAtomHandler::invalidAtom;
 			getVariableByMultiname(curValue,propName,GET_VARIABLE_OPTION::NONE,getInstanceWorker());
-			if(asAtomHandler::isValid(curValue))
+			if(asAtomHandler::isValid(curValue) && !asAtomHandler::isNull(curValue))
 			{
 				//If the variable already exists we have to create an Array of values
 				Array* arr=nullptr;
diff -u -r -N lightspark-0.9.0/src/scripting/flash/system/flashsystem.cpp lightspark-master/src/scripting/flash/system/flashsystem.cpp
--- lightspark-0.9.0/src/scripting/flash/system/flashsystem.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/system/flashsystem.cpp	2025-03-05 20:13:02.180865570 +0100
@@ -24,6 +24,7 @@
 #include "scripting/flash/errors/flasherrors.h"
 #include "scripting/flash/display/Loader.h"
 #include "scripting/flash/display/Stage.h"
+#include "scripting/avm1/scope.h"
 #include "scripting/abc.h"
 #include "scripting/argconv.h"
 #include "compat.h"
@@ -36,6 +37,7 @@
 #include "scripting/toplevel/XMLList.h"
 #include "scripting/toplevel/Vector.h"
 #include "scripting/toplevel/Undefined.h"
+#include "scripting/toplevel/toplevel.h"
 #include "parsing/streams.h"
 #include "platforms/engineutils.h"
 #ifdef __APPLE__
@@ -388,12 +390,13 @@
 
 ASFUNCTIONBODY_GETTER_SETTER_CB(ApplicationDomain,domainMemory,cbDomainMemory)
 ASFUNCTIONBODY_GETTER(ApplicationDomain,parentDomain)
-
 void ApplicationDomain::cbDomainMemory(_NR<ByteArray> oldvalue)
 {
 	if (!this->domainMemory.isNull() && this->domainMemory->getLength() < MIN_DOMAIN_MEMORY_LIMIT)
 	{
 		createError<ASError>(this->getInstanceWorker(),kEndOfFileError);
+		if (domainMemory)
+			domainMemory->incRef(); //  will be decreffed when handling exception after setter call
 		domainMemory=oldvalue;
 		return;
 	}
@@ -569,7 +572,7 @@
 	// tag not found, also check case insensitive
 	if(it==dictionary.end())
 	{
-		
+
 		tiny_string namelower = getSystemState()->getStringFromUniqueId(nameID).lowercase();
 		it = dictionary.begin();
 		for(;it!=dictionary.end();++it)
@@ -659,7 +662,7 @@
 {
 	if (cls->isBinded() || classesToBeBound.empty())
 		return;
-	
+
 	auto it=classesToBeBound.find(classname);
 	if(it!=classesToBeBound.end())
 	{
@@ -690,7 +693,7 @@
 	multiname clsname(nullptr);
 	clsname.name_type=multiname::NAME_STRING;
 	clsname.isAttribute = false;
-	
+
 	uint32_t pos = tag->bindingclassname.rfind(".");
 	tiny_string ns;
 	tiny_string nm;
@@ -707,7 +710,7 @@
 	}
 	clsname.name_s_id=getSystemState()->getUniqueStringId(nm);
 	clsname.ns.push_back(nsNameAndKind(getSystemState(),ns,NAMESPACE));
-	
+
 	ASObject* typeObject = nullptr;
 	auto i = classesBeingDefined.cbegin();
 	while (i != classesBeingDefined.cend())
@@ -1271,7 +1274,7 @@
 		return;
 	}
 	fclose(f);
-	
+
 	uint32_t memsize = 0;
 	pugi::xml_document xmldoc;
 	xmldoc.load_buffer((void*)buf,size);
@@ -1337,7 +1340,9 @@
 	EventDispatcher(this,nullptr),parser(nullptr),
 	giveAppPrivileges(false),started(false),inGarbageCollection(false),inShutdown(false),inFinalize(false),
 	stage(nullptr),
-	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),cur_recursion(0),isPrimordial(true),state("running"),
+	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),
+	cur_recursion(0),AVM1_cur_recursion_function(0),AVM1_cur_recursion_internal(0),
+	isPrimordial(true),state("running"),
 	nativeExtensionCallCount(0)
 {
 	subtype = SUBTYPE_WORKER;
@@ -1357,7 +1362,9 @@
 	EventDispatcher(c->getSystemState()->worker,c),parser(nullptr),
 	giveAppPrivileges(false),started(false),inGarbageCollection(false),inShutdown(false),inFinalize(false),
 	stage(nullptr),
-	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),cur_recursion(0),isPrimordial(false),state("new"),
+	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),
+	cur_recursion(0),AVM1_cur_recursion_function(0),AVM1_cur_recursion_internal(0),
+	isPrimordial(false),state("new"),
 	nativeExtensionCallCount(0)
 {
 	subtype = SUBTYPE_WORKER;
@@ -1376,7 +1383,9 @@
 	EventDispatcher(wrk,c),parser(nullptr),
 	giveAppPrivileges(false),started(false),inGarbageCollection(false),inShutdown(false),inFinalize(false),
 	stage(nullptr),
-	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),cur_recursion(0),isPrimordial(false),state("new"),
+	freelist(new asfreelist[asClassCount]),currentCallContext(nullptr),
+	cur_recursion(0),AVM1_cur_recursion_function(0),AVM1_cur_recursion_internal(0),
+	isPrimordial(false),state("new"),
 	nativeExtensionCallCount(0)
 {
 	subtype = SUBTYPE_WORKER;
@@ -1468,7 +1477,7 @@
 	{
 		ASObject* o = (*it);
 		if (o->is<ASWorker>()
-				|| o == getSystemState()->stage 
+				|| o == getSystemState()->stage
 				|| o == getSystemState()->workerDomain
 				|| o == getSystemState()->mainClip
 				|| o == getSystemState()->systemDomain
@@ -1540,6 +1549,89 @@
 	c->setDeclaredMethodByQName("terminate","",c->getSystemState()->getBuiltinFunction(terminate,0,Class<Boolean>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 }
 
+void ASWorker::fillStackTrace(StackTraceList& strace)
+{
+	for (uint32_t i = cur_recursion; i > 0; i--)
+	{
+		Class_base* c = asAtomHandler::getClass(stacktrace[i-1].object,getSystemState());
+		SyntheticFunction* f = stacktrace[i-1].function;
+		stacktrace_string_entry e;
+		e.clsname = c ? c->getQualifiedClassNameID() : (uint32_t)BUILTIN_STRINGS::EMPTY;
+		e.function = f->functionname;
+		e.init = (uint32_t)BUILTIN_STRINGS::EMPTY;
+		if (f->isScriptInit() && !f->inClass)
+			e.init = BUILTIN_STRINGS::STRING_INIT;
+		else if (f->isClassInit())
+			e.init = getSystemState()->getUniqueStringId("cinit");
+		else if (f->inClass && f->isStatic && f->functionname != BUILTIN_STRINGS::EMPTY)
+			e.init = UINT32_MAX; // indicates static class method
+		else if (f->isFromNewFunction())
+			e.clsname=BUILTIN_STRINGS::EMPTY;
+		e.isGetter=f->isGetter;
+		e.isSetter=f->isSetter;
+		e.ns = f->namespaceNameID;
+		e.methodnumber = f->getMethodNumber();
+		strace.push_back(e);
+	}
+}
+
+tiny_string ASWorker::getStackTraceString(SystemState* sys,const StackTraceList& strace, ASObject* error)
+{
+	tiny_string ret;
+	if (error)
+	{
+		ret = error->toString();
+	}
+	for (auto it = strace.begin(); it != strace.end(); it++)
+	{
+		ret += "\n\tat ";
+		ret += sys->getStringFromUniqueId((*it).clsname);
+		if ((*it).init != BUILTIN_STRINGS::EMPTY)
+		{
+			ret += "$";
+			if ((*it).init != UINT32_MAX)
+				ret += sys->getStringFromUniqueId((*it).init);
+		}
+		if ((*it).function != BUILTIN_STRINGS::EMPTY)
+		{
+			if ((*it).clsname != BUILTIN_STRINGS::EMPTY)
+				ret += "/";
+			if ((it)->isGetter)
+				ret +="get ";
+			if ((it)->isSetter)
+				ret += "set ";
+			if ((it)->ns != BUILTIN_STRINGS::EMPTY)
+			{
+				ret += sys->getStringFromUniqueId((*it).ns);
+				ret +="::";
+			}
+			ret += sys->getStringFromUniqueId((*it).function);
+		}
+		else if((*it).methodnumber != UINT32_MAX)
+		{
+			char buf[100];
+			sprintf(buf,"MethodInfo-%i",(*it).methodnumber);
+			ret += buf;
+		}
+
+		ret += "()";
+		if (sys->use_testrunner_date && !sys->isShuttingDown()
+			&& (*it).clsname==BUILTIN_STRINGS::STRING_GLOBAL
+			&& (*it).init==BUILTIN_STRINGS::STRING_INIT)
+		{
+			// for some reason ruffle adds this (adobe doesn't) when we are at a scriptinit function.
+			// So we do the same if we are in the testrunner
+			ret +=" [TU=]";
+		}
+	}
+	return ret;
+}
+
+_NR<AVM1Scope> ASWorker::AVM1getScope() const
+{
+	return AVM1callStack.empty() ? NullRef : AVM1callStack.back()->scope;
+}
+
 void ASWorker::throwStackOverflow()
 {
 	createError<StackOverflowError>(this,kStackOverflowError);
@@ -1590,7 +1682,7 @@
 		_NR<EventDispatcher> dispatcher=events_queue.front().first;
 		_R<Event> e=events_queue.front().second;
 		events_queue.pop_front();
-	
+
 		event_queue_mutex.unlock();
 		try
 		{
@@ -1608,6 +1700,9 @@
 		}
 		catch(ASObject*& e)
 		{
+			StackTraceList stacktrace;
+			fillStackTrace(stacktrace);
+
 			if(e->getClass())
 				LOG(LOG_ERROR,"Unhandled ActionScript exception in worker " << e->toString());
 			else
@@ -1620,7 +1715,7 @@
 				getSystemState()->setError(e->as<ASError>()->getStackTraceString());
 			}
 			else
-				getSystemState()->setError("Unhandled ActionScript exception");
+				getSystemState()->setError(getStackTraceString(getSystemState(),stacktrace,e));
 			threadAborting = true;
 		}
 		if (threadAborting)
@@ -1688,16 +1783,11 @@
 
 void ASWorker::dumpStacktrace()
 {
-	tiny_string strace;
-	for (uint32_t i = cur_recursion; i > 0; i--)
-	{
-		strace += "    at ";
-		strace += asAtomHandler::toObject(stacktrace[i-1].object,this)->getClassName();
-		strace += "/";
-		strace += this->getSystemState()->getStringFromUniqueId(stacktrace[i-1].name);
-		strace += "()\n";
-	}
-	LOG(LOG_INFO,"current stacktrace:\n" << strace);
+	StackTraceList l;
+	fillStackTrace(l);
+
+	tiny_string strace = getStackTraceString(getSystemState(),l,nullptr);
+	LOG(LOG_INFO,"current stacktrace:" << strace);
 }
 
 void ASWorker::addObjectToGarbageCollector(ASObject* o)
@@ -1742,7 +1832,7 @@
 {
 	uint64_t currtime = compat_msectiming();
 	int64_t diff =  currtime-last_garbagecollection;
-	if (!force && diff < 10000) // ony execute garbagecollection every 10 seconds
+	if (!force && !getSystemState()->use_testrunner_date && diff < 10000) // ony execute garbagecollection every 10 seconds
 		return;
 	last_garbagecollection = currtime;
 	if (this->stage)
@@ -1750,6 +1840,7 @@
 	inGarbageCollection=true;
 	bool hasEntries=this->gcNext && this->gcNext != this;
 	// use two loops to make sure objects added during inner loop are handled _after_ the inner loop is complete
+	LOG(LOG_CALLS,"start garbage collection");
 	while (hasEntries)
 	{
 		ASObject* ogc = this->gcNext;
@@ -1788,6 +1879,7 @@
 	}
 	if (force && this->gcNext && this->gcNext != this)
 		processGarbageCollection(true);
+	LOG(LOG_CALLS,"garbage collection done");
 }
 
 void ASWorker::registerConstantRef(ASObject* obj)
@@ -1812,7 +1904,7 @@
 	tiny_string key;
 	ARG_CHECK(ARG_UNPACK(key));
 	Locker l(wrk->getSystemState()->workerDomain->workersharedobjectmutex);
-	
+
 	multiname m(nullptr);
 	m.name_type=multiname::NAME_STRING;
 	m.name_s_id=wrk->getSystemState()->getUniqueStringId(key);
@@ -2019,12 +2111,12 @@
 ASFUNCTIONBODY_ATOM(WorkerDomain,createWorkerFromPrimordial)
 {
 	ASWorker* wk = Class<ASWorker>::getInstanceS(wrk->getSystemState()->worker);
-	
-	
+
+
 	ByteArray* ba = Class<ByteArray>::getInstanceS(wk);
 	FileStreamCache* sc = (FileStreamCache*)wrk->getSystemState()->getEngineData()->createFileStreamCache(wrk->getSystemState());
 	sc->useExistingFile(wrk->getSystemState()->getDumpedSWFPath());
-	
+
 	ba->append(sc->createReader(),wrk->getSystemState()->swffilesize);
 	wk->swf = _MR(ba);
 	ret = asAtomHandler::fromObject(wk);
@@ -2039,7 +2131,7 @@
 ASFUNCTIONBODY_ATOM(WorkerDomain,listWorkers)
 {
 	WorkerDomain* th = asAtomHandler::as<WorkerDomain>(obj);
-	
+
 	th->workerlist->incRef();
 	ret = asAtomHandler::fromObject(th->workerlist.getPtr());
 }
diff -u -r -N lightspark-0.9.0/src/scripting/flash/system/flashsystem.h lightspark-master/src/scripting/flash/system/flashsystem.h
--- lightspark-0.9.0/src/scripting/flash/system/flashsystem.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/system/flashsystem.h	2025-03-05 20:13:02.180865570 +0100
@@ -93,7 +93,7 @@
 	std::unordered_map<Class_base*,Class_base*> classesSuperNotFilled;
 	// list of classes where interfaces are not yet linked
 	std::vector<Class_base*> classesToLinkInterfaces;
-	
+
 	Mutex dictSpinlock;
 	std::unordered_map < uint32_t, DictionaryTag* > dictionary;
 	std::map < QName, DictionaryTag* > classesToBeBound;
@@ -126,7 +126,7 @@
 	void prepareShutdown() override;
 	std::map<const multiname*, Class_base*> classesBeingDefined;
 	std::map<QName, Class_base*> instantiatedTemplates;
-	
+
 	void SetAllClassLinks();
 	void AddClassLinks(Class_base* target);
 	bool newClassRecursiveLink(Class_base* target, Class_base* c);
@@ -244,7 +244,7 @@
 		}
 		*reinterpret_cast<T*>(dm->getBufferNoCheck()+addr)=val;
 	}
-	
+
 	static FORCE_INLINE void loadFloat(ApplicationDomain* appDomain,call_context *th)
 	{
 		RUNTIME_STACK_POP_CREATE(th,arg1);
@@ -373,6 +373,7 @@
 class WorkerDomain;
 class ParseThread;
 class Prototype;
+
 class ASWorker: public EventDispatcher, public IThreadJob
 {
 friend class WorkerDomain;
@@ -402,7 +403,7 @@
 	asfreelist freelist_syntheticfunction;
 	asfreelist freelist_activationobject;
 	asfreelist freelist_asobject;
-	
+
 	ASWorker(SystemState* s); // constructor for primordial worker only to be used in SystemState constructor
 	ASWorker(Class_base* c);
 	ASWorker(ASWorker* wrk,Class_base* c);
@@ -420,8 +421,12 @@
 	/* The current recursion level. Each call increases this by one,
 	 * each return from a call decreases this. */
 	uint32_t cur_recursion;
+	uint32_t AVM1_cur_recursion_function; // recursion count for normal avm1 function calls
+	uint32_t AVM1_cur_recursion_internal; // recursion count for internal avm1 function calls (getters,setters...)
 	stacktrace_entry* stacktrace;
-	FORCE_INLINE call_context* incStack(asAtom o, uint32_t f)
+	void fillStackTrace(StackTraceList& strace);
+	static tiny_string getStackTraceString(SystemState* sys, const StackTraceList& strace, ASObject* error);
+	FORCE_INLINE call_context* incStack(asAtom o, SyntheticFunction* f)
 	{
 		if(USUALLY_FALSE(cur_recursion == limits.max_recursion))
 		{
@@ -443,6 +448,15 @@
 	{
 		return AVM1callStack.empty() ? nullptr : AVM1callStack.back()->callee;
 	}
+	_NR<AVM1Scope> AVM1getScope() const;
+	bool AVM1isCaseSensitive() const
+	{
+		return
+		(
+			AVM1callStack.empty() ||
+			AVM1callStack.back()->isCaseSensitive()
+		);
+	}
 	uint8_t AVM1getSwfVersion() const
 	{
 		return AVM1callStack.empty() ? UINT8_MAX : AVM1callStack.back()->swfversion;
@@ -479,7 +493,6 @@
 	FORCE_INLINE bool isInGarbageCollection() const { return inGarbageCollection; }
 	inline bool inFinalization() const { return inFinalize; }
 	void registerConstantRef(ASObject* obj);
-	
 	// these are needed keep track of native extension calls
 	std::list<asAtom> nativeExtensionAtomlist;
 	std::list<uint8_t*> nativeExtensionStringlist;
diff -u -r -N lightspark-0.9.0/src/scripting/flash/text/flashtext.cpp lightspark-master/src/scripting/flash/text/flashtext.cpp
--- lightspark-0.9.0/src/scripting/flash/text/flashtext.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/text/flashtext.cpp	2025-03-05 20:13:02.180865570 +0100
@@ -182,10 +182,10 @@
 	c->setDeclaredMethodByQName("gridFitType","",c->getSystemState()->getBuiltinFunction(TextField::_setGridFitType),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("height","",c->getSystemState()->getBuiltinFunction(TextField::_getHeight),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("height","",c->getSystemState()->getBuiltinFunction(TextField::_setHeight),SETTER_METHOD,true);
-	c->setDeclaredMethodByQName("htmlText","",c->getSystemState()->getBuiltinFunction(TextField::_getHtmlText),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("htmlText","",c->getSystemState()->getBuiltinFunction(TextField::_getHtmlText,0,Class<ASString>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("htmlText","",c->getSystemState()->getBuiltinFunction(TextField::_setHtmlText),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("length","",c->getSystemState()->getBuiltinFunction(TextField::_getLength,0,Class<Integer>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
-	c->setDeclaredMethodByQName("text","",c->getSystemState()->getBuiltinFunction(TextField::_getText),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("text","",c->getSystemState()->getBuiltinFunction(TextField::_getText,0,Class<ASString>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("text","",c->getSystemState()->getBuiltinFunction(TextField::_setText),SETTER_METHOD,true);
 	c->setDeclaredMethodByQName("textHeight","",c->getSystemState()->getBuiltinFunction(TextField::_getTextHeight),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("textWidth","",c->getSystemState()->getBuiltinFunction(TextField::_getTextWidth),GETTER_METHOD,true);
@@ -296,7 +296,7 @@
 	if ((!this->legacy || (tag==nullptr) || autoSize!=AS_NONE))
 	{
 		xmin=tag ? tag->Bounds.Xmin/20.0f : 0.0f;
-		if (wordWrap)
+		if (wordWrap || autoSize==AS_NONE)
 			xmax=max(0.0f,float(width))+ (tag ? tag->Bounds.Xmin/20.0f : 0.0f);
 		else
 			xmax=max(0.0f,float(textWidth+autosizeposition))+2*TEXTFIELD_PADDING+ (tag ? tag->Bounds.Xmin/20.0f : 0.0f);
@@ -1795,6 +1795,11 @@
 	return tag ? tag->getId() : UINT32_MAX;
 }
 
+bool TextField::isFocusable()
+{
+	return type==ET_EDITABLE && selectable;
+}
+
 void TextField::textUpdated()
 {
 	// Don't sync the bound variable if we're updating the binding.
diff -u -r -N lightspark-0.9.0/src/scripting/flash/text/flashtext.h lightspark-master/src/scripting/flash/text/flashtext.h
--- lightspark-0.9.0/src/scripting/flash/text/flashtext.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/text/flashtext.h	2025-03-05 20:13:02.180865570 +0100
@@ -170,6 +170,8 @@
 	uint32_t getTagID() const override;
 	float getScaleFactor() const override { return this->scaling; }
 	bool isInUpdateVarBinding() const { return inUpdateVarBinding; }
+	bool isFocusable() override;
+
 	
 	ASFUNCTION_ATOM(appendText);
 	ASFUNCTION_ATOM(_getAntiAliasType);
diff -u -r -N lightspark-0.9.0/src/scripting/flash/xml/flashxml.cpp lightspark-master/src/scripting/flash/xml/flashxml.cpp
--- lightspark-0.9.0/src/scripting/flash/xml/flashxml.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/flash/xml/flashxml.cpp	2025-03-05 20:13:02.183865643 +0100
@@ -828,7 +828,7 @@
 	c->setDeclaredMethodByQName("toString","",c->getSystemState()->getBuiltinFunction(_toString,0,Class<ASString>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("createElement","",c->getSystemState()->getBuiltinFunction(createElement,1,Class<XMLNode>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
 	c->setDeclaredMethodByQName("createTextNode","",c->getSystemState()->getBuiltinFunction(createTextNode,1,Class<XMLNode>::getRef(c->getSystemState()).getPtr()),NORMAL_METHOD,true);
-	c->setDeclaredMethodByQName("idmap","",c->getSystemState()->getBuiltinFunction(_idmap,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
+	c->setDeclaredMethodByQName("idMap","",c->getSystemState()->getBuiltinFunction(_idmap,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("docTypeDecl","",c->getSystemState()->getBuiltinFunction(_docTypeDecl,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	c->setDeclaredMethodByQName("xmlDecl","",c->getSystemState()->getBuiltinFunction(_xmlDecl,0,Class<ASObject>::getRef(c->getSystemState()).getPtr()),GETTER_METHOD,true);
 	REGISTER_GETTER_SETTER_RESULTTYPE(c, ignoreWhite,Boolean);
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Array.cpp lightspark-master/src/scripting/toplevel/Array.cpp
--- lightspark-0.9.0/src/scripting/toplevel/Array.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Array.cpp	2025-03-05 20:13:02.184865668 +0100
@@ -201,7 +201,7 @@
 		else if (this->isAVM1Array())
 			static_cast<AVM1Array*>(this)->setCurrentSize(asAtomHandler::toNumber(args[0]));
 		LOG_CALL("Creating array of length " << size);
-		resize(size);
+		Array::resize(size);
 		for (uint32_t i=0; i <size && i < ARRAY_SIZE_THRESHOLD; i++)
 		{
 			set(i,asAtomHandler::invalidAtom,false);
@@ -1403,6 +1403,7 @@
 			hole = true;
 			previndex++;
 			a = getMemberFromPrototypeChain(previndex,protomembers);
+			ASATOM_ADDSTOREDMEMBER(a);
 		}
 		if (asAtomHandler::isInvalid(a))
 		{
@@ -1499,6 +1500,8 @@
 		for(;ittmp != tmp.end();++ittmp)
 		{
 			arrayRet->push(asAtomHandler::fromInt(ittmp->originalindex));
+			if (ittmp->fromprototype)
+				ASATOM_REMOVESTOREDMEMBER(ittmp->dataAtom);
 			if (!isUniqueSort) // sortvalues are already decreffed if isUniqueSort is set
 			{
 				for (auto itsv = ittmp->sortvalues.begin(); itsv != ittmp->sortvalues.end(); itsv++)
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Array.h lightspark-master/src/scripting/toplevel/Array.h
--- lightspark-0.9.0/src/scripting/toplevel/Array.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Array.h	2025-03-05 20:13:02.184865668 +0100
@@ -36,6 +36,10 @@
 	bool isDescending;
 	multiname fieldname;
 	sorton_field(const multiname& sortfieldname):isNumeric(false),isCaseInsensitive(false),isDescending(false),fieldname(sortfieldname){}
+	~sorton_field()
+	{
+		fieldname.resetNameIfObject();
+	}
 };
 struct sort_value
 {
@@ -167,7 +171,7 @@
 	bool set(unsigned int index, asAtom &o, bool checkbounds = true, bool addref = true, bool addmember=true);
 	uint64_t size();
 	void push(asAtom o);// push doesn't increment the refcount, so the caller has to take care of that
-	void resize(uint64_t n, bool removemember=true);
+	virtual void resize(uint64_t n, bool removemember=true);
 	GET_VARIABLE_RESULT getVariableByMultiname(asAtom& ret, const multiname& name, GET_VARIABLE_OPTION opt, ASWorker* wrk) override;
 	GET_VARIABLE_RESULT getVariableByInteger(asAtom& ret, int index, GET_VARIABLE_OPTION opt, ASWorker* wrk) override;
 	
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/ASString.cpp lightspark-master/src/scripting/toplevel/ASString.cpp
--- lightspark-0.9.0/src/scripting/toplevel/ASString.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/ASString.cpp	2025-03-05 20:13:02.183865643 +0100
@@ -939,8 +939,9 @@
 ASFUNCTIONBODY_ATOM(ASString,toLowerCase)
 {
 	tiny_string data = asAtomHandler::toString(obj,wrk);
-	if (asAtomHandler::is<ASString>(obj) && asAtomHandler::toStringId(obj,wrk) != UINT32_MAX)
-		ret = asAtomHandler::fromStringID(wrk->getSystemState()->getUniqueStringId(data.lowercase()));
+	auto strID = wrk->getSystemState()->getUniqueStringId(data, true);
+	if (asAtomHandler::is<ASString>(obj) && strID != UINT32_MAX)
+		ret = asAtomHandler::fromStringID(wrk->getSystemState()->getUniqueStringId(data.lowercase(), true));
 	else
 		ret = asAtomHandler::fromObject(abstract_s(wrk,data.lowercase()));
 }
@@ -948,8 +949,9 @@
 ASFUNCTIONBODY_ATOM(ASString,toUpperCase)
 {
 	tiny_string data = asAtomHandler::toString(obj,wrk);
-	if (asAtomHandler::is<ASString>(obj) && asAtomHandler::toStringId(obj,wrk) != UINT32_MAX)
-		ret = asAtomHandler::fromStringID(wrk->getSystemState()->getUniqueStringId(data.uppercase()));
+	auto strID = wrk->getSystemState()->getUniqueStringId(data, true);
+	if (asAtomHandler::is<ASString>(obj) && strID != UINT32_MAX)
+		ret = asAtomHandler::fromStringID(wrk->getSystemState()->getUniqueStringId(data.uppercase(), true));
 	else
 		ret = asAtomHandler::fromObject(abstract_s(wrk,data.uppercase()));
 }
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/AVM1Function.cpp lightspark-master/src/scripting/toplevel/AVM1Function.cpp
--- lightspark-0.9.0/src/scripting/toplevel/AVM1Function.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/AVM1Function.cpp	2025-03-05 20:13:02.184865668 +0100
@@ -21,13 +21,13 @@
 #include "scripting/toplevel/toplevel.h"
 #include "scripting/toplevel/AVM1Function.h"
 #include "scripting/flash/display/DisplayObject.h"
-
+#include "scripting/avm1/scope.h"
 
 using namespace std;
 using namespace lightspark;
 
-AVM1Function::AVM1Function(ASWorker* wrk, Class_base* c, DisplayObject* cl, Activation_object* act, AVM1context* ctx, std::vector<uint32_t>& p, std::vector<uint8_t>& a, std::vector<uint8_t> _registernumbers, bool _preloadParent, bool _preloadRoot, bool _suppressSuper, bool _preloadSuper, bool _suppressArguments, bool _preloadArguments, bool _suppressThis, bool _preloadThis, bool _preloadGlobal)
-	:IFunction(wrk,c,SUBTYPE_AVM1FUNCTION),clip(cl),activationobject(act),actionlist(a),paramnames(p), paramregisternumbers(_registernumbers),
+AVM1Function::AVM1Function(ASWorker* wrk, Class_base* c, DisplayObject* cl, Activation_object* act, AVM1context* ctx, std::vector<uint32_t>& p, std::vector<uint8_t>& a, const _R<AVM1Scope>& _scope, std::vector<uint8_t> _registernumbers, bool _preloadParent, bool _preloadRoot, bool _suppressSuper, bool _preloadSuper, bool _suppressArguments, bool _preloadArguments, bool _suppressThis, bool _preloadThis, bool _preloadGlobal)
+	:IFunction(wrk,c,SUBTYPE_AVM1FUNCTION),clip(cl),activationobject(act),actionlist(a),paramnames(p), paramregisternumbers(_registernumbers), scope(_scope),
 	  preloadParent(_preloadParent),preloadRoot(_preloadRoot),suppressSuper(_suppressSuper),preloadSuper(_preloadSuper),suppressArguments(_suppressArguments),preloadArguments(_preloadArguments),suppressThis(_suppressThis), preloadThis(_preloadThis), preloadGlobal(_preloadGlobal)
 {
 	if (ctx)
@@ -46,11 +46,6 @@
 		activationobject->removeStoredMember();
 	if (clip)
 		clip->removeStoredMember();
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASATOM_REMOVESTOREDMEMBER(it->second);
-	}
-	scopevariables.clear();
 }
 
 asAtom AVM1Function::computeSuper()
@@ -75,6 +70,12 @@
 	return newsuper;
 }
 
+void AVM1Function::checkInternalException()
+{
+	if (getInstanceWorker()->AVM1callStack.back()->exceptionthrown)
+		getInstanceWorker()->AVM1_cur_recursion_internal=AVM1_RECURSION_LIMIT_INTERN+1; // indicate stackoverflow on internal call
+}
+
 void AVM1Function::finalize()
 {
 	if (activationobject)
@@ -83,11 +84,7 @@
 	if (clip)
 		clip->removeStoredMember();
 	clip=nullptr;
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASATOM_REMOVESTOREDMEMBER(it->second);
-	}
-	scopevariables.clear();
+	scope.reset();
 	ASATOM_REMOVESTOREDMEMBER(superobj);
 	IFunction::finalize();
 }
@@ -100,11 +97,7 @@
 	if (clip)
 		clip->removeStoredMember();
 	clip=nullptr;
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASATOM_REMOVESTOREDMEMBER(it->second);
-	}
-	scopevariables.clear();
+	scope.reset();
 	ASATOM_REMOVESTOREDMEMBER(superobj);
 	superobj=asAtomHandler::invalidAtom;
 	return IFunction::destruct();
@@ -119,12 +112,8 @@
 		activationobject->prepareShutdown();
 	if (clip)
 		clip->prepareShutdown();
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASObject* o = asAtomHandler::getObject(it->second);
-		if (o)
-			o->prepareShutdown();
-	}
+	if (scope)
+		scope->prepareShutdown();
 	ASObject* su = asAtomHandler::getObject(superobj);
 	if (su)
 		su->prepareShutdown();
@@ -137,33 +126,10 @@
 		ret = activationobject->countAllCylicMemberReferences(gcstate) || ret;
 	if (clip)
 		ret = clip->countAllCylicMemberReferences(gcstate) || ret;
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASObject* o = asAtomHandler::getObject(it->second);
-		if (o)
-			ret = o->countAllCylicMemberReferences(gcstate) || ret;
-	}
+	if (scope)
+		ret |= scope->countAllCyclicMemberReferences(gcstate);
 	ASObject* su = asAtomHandler::getObject(superobj);
 	if (su)
 		ret = su->countAllCylicMemberReferences(gcstate) || ret;
 	return ret;
 }
-
-void AVM1Function::filllocals(std::map<uint32_t, asAtom>& locals)
-{
-	for (auto it = scopevariables.begin(); it != scopevariables.end(); it++)
-	{
-		ASATOM_INCREF(it->second);
-		locals[it->first]=it->second;
-	}
-}
-
-void AVM1Function::setscopevariables(std::map<uint32_t, asAtom>& locals)
-{
-	for (auto it = locals.begin(); it != locals.end(); it++)
-	{
-		ASATOM_REMOVESTOREDMEMBER(scopevariables [it->first]);
-		ASATOM_ADDSTOREDMEMBER(it->second);
-		scopevariables [it->first]=it->second;
-	}
-}
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/AVM1Function.h lightspark-master/src/scripting/toplevel/AVM1Function.h
--- lightspark-0.9.0/src/scripting/toplevel/AVM1Function.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/AVM1Function.h	2025-03-05 20:13:02.184865668 +0100
@@ -22,9 +22,11 @@
 
 #include "scripting/toplevel/IFunction.h"
 
+#define AVM1_RECURSION_LIMIT_INTERN 65 // according to ruffle the script limit for internal (getter,setter) AVM1 calls is 65
 
 namespace lightspark
 {
+class AVM1Scope;
 
 class AVM1Function : public IFunction
 {
@@ -38,7 +40,7 @@
 	std::vector<uint8_t> actionlist;
 	std::vector<uint32_t> paramnames;
 	std::vector<uint8_t> paramregisternumbers;
-	std::map<uint32_t, asAtom> scopevariables;
+	_NR<AVM1Scope> scope;
 	bool preloadParent;
 	bool preloadRoot;
 	bool suppressSuper;
@@ -48,7 +50,7 @@
 	bool suppressThis;
 	bool preloadThis;
 	bool preloadGlobal;
-	AVM1Function(ASWorker* wrk,Class_base* c,DisplayObject* cl,Activation_object* act,AVM1context* ctx, std::vector<uint32_t>& p, std::vector<uint8_t>& a,std::vector<uint8_t> _registernumbers=std::vector<uint8_t>(), bool _preloadParent=false, bool _preloadRoot=false, bool _suppressSuper=false, bool _preloadSuper=false, bool _suppressArguments=false, bool _preloadArguments=false,bool _suppressThis=false, bool _preloadThis=false, bool _preloadGlobal=false);
+	AVM1Function(ASWorker* wrk,Class_base* c,DisplayObject* cl,Activation_object* act,AVM1context* ctx, std::vector<uint32_t>& p, std::vector<uint8_t>& a,const _R<AVM1Scope>& _scope,std::vector<uint8_t> _registernumbers=std::vector<uint8_t>(), bool _preloadParent=false, bool _preloadRoot=false, bool _suppressSuper=false, bool _preloadSuper=false, bool _suppressArguments=false, bool _preloadArguments=false,bool _suppressThis=false, bool _preloadThis=false, bool _preloadGlobal=false);
 	~AVM1Function();
 	method_info* getMethodInfo() const override { return nullptr; }
 	IFunction* clone(ASWorker* wrk) override
@@ -57,33 +59,35 @@
 		return nullptr;
 	}
 	asAtom computeSuper();
+	void checkInternalException();
 public:
 	void finalize() override;
 	bool destruct() override;
 	void prepareShutdown() override;
 	bool countCylicMemberReferences(garbagecollectorstate& gcstate) override;
-	FORCE_INLINE void call(asAtom* ret, asAtom* obj, asAtom *args, uint32_t num_args, AVM1Function* caller=nullptr, std::map<uint32_t,asAtom>* locals=nullptr)
+	FORCE_INLINE void call(asAtom* ret, asAtom* obj, asAtom *args, uint32_t num_args, AVM1Function* caller = nullptr, bool isInternalCall=false)
 	{
-		if (locals)
-			this->setscopevariables(*locals);
 		if (needsSuper())
 		{
 			asAtom newsuper = computeSuper();
-			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,this->scopevariables,false,ret,obj, args, num_args, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,caller,this,activationobject,&newsuper);
+			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,scope.getPtr(),false,ret,obj, args, num_args, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,caller,this,activationobject,&newsuper,isInternalCall);
 		}
 		else
-			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,this->scopevariables,false,ret,obj, args, num_args, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,caller,this,activationobject);
-	}
+			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,scope.getPtr(),false,ret,obj, args, num_args, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,caller,this,activationobject,nullptr,isInternalCall);
+		if (isInternalCall)
+			checkInternalException();
+ 	}
 	FORCE_INLINE multiname* callGetter(asAtom& ret, asAtom& target, ASWorker* wrk) override
 	{
 		asAtom obj = target;
 		if (needsSuper())
 		{
 			asAtom newsuper = computeSuper();
-			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,this->scopevariables,false,&ret,&obj, nullptr, 0, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,nullptr,this,activationobject,&newsuper);
+			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,scope.getPtr(),false,&ret,&obj, nullptr, 0, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,nullptr,this,activationobject,&newsuper,true);
 		}
 		else
-			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,this->scopevariables,false,&ret,&obj, nullptr, 0, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,nullptr,this,activationobject);
+			ACTIONRECORD::executeActions(clip,&context,this->actionlist,0,scope.getPtr(),false,&ret,&obj, nullptr, 0, paramnames,paramregisternumbers, preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal,nullptr,this,activationobject,nullptr,true);
+		checkInternalException();
 		return nullptr;
 	}
 	FORCE_INLINE Class_base* getReturnType(bool opportunistic=false) override
@@ -111,8 +115,6 @@
 	{
 		return superobj;
 	}
-	void filllocals(std::map<uint32_t,asAtom>& locals);
-	void setscopevariables(std::map<uint32_t,asAtom>& locals);
 };
 
 }
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Error.cpp lightspark-master/src/scripting/toplevel/Error.cpp
--- lightspark-0.9.0/src/scripting/toplevel/Error.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Error.cpp	2025-03-05 20:13:02.184865668 +0100
@@ -124,11 +124,7 @@
 ASError::ASError(ASWorker* wrk, Class_base* c, const tiny_string& error_message, int id, const tiny_string& error_name, CLASS_SUBTYPE subtype):
 	ASObject(wrk,c,T_OBJECT,subtype),errorID(id),name(error_name),message(error_message)
 {
-	for (uint32_t i = wrk->cur_recursion; i > 0; i--)
-	{
-		ASObject* o = asAtomHandler::toObject(wrk->stacktrace[i-1].object,wrk);
-		stacktrace.push_back(make_pair(o->getClass() ? o->getClass()->getQualifiedClassNameID() : (uint32_t)BUILTIN_STRINGS::EMPTY,wrk->stacktrace[i-1].name));
-	}
+	wrk->fillStackTrace(stacktrace);
 }
 
 ASFUNCTIONBODY_ATOM(ASError,_getStackTrace)
@@ -138,25 +134,13 @@
 }
 tiny_string ASError::getStackTraceString()
 {
-	tiny_string ret = toString();
-	ret += "\n";
-	for (auto it = stacktrace.begin(); it != stacktrace.end(); it++)
-	{
-		ret += "    at ";
-		ret += getSystemState()->getStringFromUniqueId((*it).first);
-		ret += "/";
-		ret += getSystemState()->getStringFromUniqueId((*it).second);
-		ret += "()\n";
-	}
-	return ret;
+	return ASWorker::getStackTraceString(getSystemState(),stacktrace,this);
 }
 
 tiny_string ASError::toString()
 {
 	tiny_string ret;
 	ret = name;
-	if(errorID != 0 && !message.startsWith("Error #"))
-		ret += tiny_string(": Error #") + Integer::toString(errorID);
 	if (!message.empty())
 		ret += tiny_string(": ") + message;
 	return ret;
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Error.h lightspark-master/src/scripting/toplevel/Error.h
--- lightspark-0.9.0/src/scripting/toplevel/Error.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Error.h	2025-03-05 20:13:02.184865668 +0100
@@ -56,7 +56,7 @@
 class ASError: public ASObject
 {
 private:
-	std::vector<std::pair<uint32_t,uint32_t>> stacktrace;
+	StackTraceList stacktrace;
 	ASPROPERTY_GETTER(int32_t, errorID);
 	ASPROPERTY_GETTER_SETTER(tiny_string, name);
 protected:
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/IFunction.cpp lightspark-master/src/scripting/toplevel/IFunction.cpp
--- lightspark-0.9.0/src/scripting/toplevel/IFunction.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/IFunction.cpp	2025-03-05 20:13:02.185865693 +0100
@@ -30,7 +30,10 @@
 using namespace std;
 using namespace lightspark;
 
-IFunction::IFunction(ASWorker* wrk,Class_base* c,CLASS_SUBTYPE st):ASObject(wrk,c,T_FUNCTION,st),length(0),closure_this(asAtomHandler::invalidAtom),inClass(nullptr),isStatic(false),clonedFrom(nullptr),functionname(0)
+IFunction::IFunction(ASWorker* wrk,Class_base* c,CLASS_SUBTYPE st):ASObject(wrk,c,T_FUNCTION,st),length(0),
+	closure_this(asAtomHandler::invalidAtom),
+	inClass(nullptr),isStatic(false),isGetter(false),isSetter(false),namespaceNameID(BUILTIN_STRINGS::EMPTY),
+	clonedFrom(nullptr),functionname(0)
 {
 }
 
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/IFunction.h lightspark-master/src/scripting/toplevel/IFunction.h
--- lightspark-0.9.0/src/scripting/toplevel/IFunction.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/IFunction.h	2025-03-05 20:13:02.185865693 +0100
@@ -48,7 +48,12 @@
 	 */
 	Class_base* inClass;
 	// if this is a class method, this indicates if it is a static or instance method
-	bool isStatic;
+	bool isStatic:1;
+	bool isGetter:1;
+	bool isSetter:1;
+	uint32_t namespaceNameID;
+
+
 	IFunction* clonedFrom;
 	/* returns whether this is this a method of a function */
 	bool isMethod() const { return inClass != nullptr; }
@@ -57,6 +62,10 @@
 	{
 		inClass=nullptr;
 		isStatic=false;
+		isGetter=false;
+		isSetter=false;
+		namespaceNameID = BUILTIN_STRINGS::EMPTY;
+
 		clonedFrom=nullptr;
 		functionname=0;
 		length=0;
@@ -89,6 +98,9 @@
 		ASATOM_ADDSTOREDMEMBER(ret->closure_this);
 		ret->clonedFrom=this;
 		ret->isStatic=isStatic;
+		ret->isGetter=isGetter;
+		ret->isSetter=isSetter;
+		ret->namespaceNameID=namespaceNameID;
 		ret->constructIndicator = true;
 		ret->constructorCallComplete = true;
 		ret->prototype=this->prototype;
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Math.cpp lightspark-master/src/scripting/toplevel/Math.cpp
--- lightspark-0.9.0/src/scripting/toplevel/Math.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Math.cpp	2025-03-05 20:13:02.185865693 +0100
@@ -319,8 +319,32 @@
 	ARG_CHECK(ARG_UNPACK (x) (y));
 	if (::fabs(x) == 1 && (std::isnan(y) || std::isinf(y)) )
 		asAtomHandler::setNumber(ret,wrk,Number::NaN);
+	else if (std::isinf(x) && x<0 && y<0 && Number::isInteger(y))
+	{
+		// special case, see ruffle test from_avmplus/as3/Types/Number/pow
+		asAtomHandler::setNumber(ret,wrk,-0.0);
+	}
+	else if (x==0 && std::signbit(x) && y>0 && Number::isInteger(y))
+	{
+		// special case, see ruffle test from_avmplus/as3/Types/Number/pow
+		asAtomHandler::setNumber(ret,wrk,uint64_t(y)%2 ? -0.0 : 0.0);
+	}
 	else
-		asAtomHandler::setNumber(ret,wrk,::pow(x,y));
+	{
+		number_t val = ::pow(x,y);
+		if (Number::isInteger(val))
+		{
+			// turn result into (u)int if possible
+			if (::abs(val) < INT32_MAX)
+				asAtomHandler::setInt(ret,wrk,val);
+			else if (val > 0 && val < UINT32_MAX)
+				asAtomHandler::setUInt(ret,wrk,val);
+			else
+				asAtomHandler::setNumber(ret,wrk,val);
+		}
+		else
+			asAtomHandler::setNumber(ret,wrk,val);
+	}
 }
 
 ASFUNCTIONBODY_ATOM(Math,random)
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/toplevel.cpp lightspark-master/src/scripting/toplevel/toplevel.cpp
--- lightspark-0.9.0/src/scripting/toplevel/toplevel.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/toplevel.cpp	2025-03-05 20:13:02.186865717 +0100
@@ -51,6 +51,7 @@
 #include "scripting/toplevel/UInteger.h"
 #include "scripting/toplevel/Vector.h"
 #include "scripting/toplevel/XML.h"
+#include "scripting/toplevel/Global.h"
 
 using namespace std;
 using namespace lightspark;
@@ -62,7 +63,11 @@
 	ret = asAtomHandler::fromObject(getNopFunction());
 }
 
-SyntheticFunction::SyntheticFunction(ASWorker* wrk, Class_base* c, method_info* m):IFunction(wrk,c,SUBTYPE_SYNTHETICFUNCTION),mi(m),val(nullptr),simpleGetterOrSetterName(nullptr),fromNewFunction(false),func_scope(NullRef)
+SyntheticFunction::SyntheticFunction(ASWorker* wrk, Class_base* c, method_info* m):IFunction(wrk,c,SUBTYPE_SYNTHETICFUNCTION),
+	mi(m),val(nullptr),simpleGetterOrSetterName(nullptr),
+	methodnumber(UINT32_MAX),
+	fromNewFunction(false),classInit(false),scriptInit(false),
+	func_scope(NullRef)
 {
 	if(mi)
 		length = mi->numArgs();
@@ -86,7 +91,10 @@
 	ret->inClass = inClass;
 	ret->func_scope = func_scope;
 	ret->functionname = functionname;
+	ret->methodnumber = methodnumber;
 	ret->fromNewFunction = fromNewFunction;
+	ret->classInit = classInit;
+	ret->scriptInit = scriptInit;
 	ret->setWorker(wrk);
 	ret->objfreelist = &wrk->freelist_syntheticfunction;
 	ret->subtype = this->subtype;
@@ -149,7 +157,7 @@
 	}
 	assert(wrk == getWorker());
 	auto prev_cur_recursion = wrk->cur_recursion;
-	call_context* saved_cc = wrk->incStack(obj,this->functionname);
+	call_context* saved_cc = wrk->incStack(obj,this);
 	if (codeStatus != method_body_info::PRELOADED && codeStatus != method_body_info::USED)
 	{
 		mi->body->codeStatus = method_body_info::PRELOADING;
@@ -478,7 +486,27 @@
 				if (saved_cc)
 					saved_cc->exceptionthrown=excobj;
 				else
+				{
+					if (!isMethod() && this->fromNewFunction)
+					{
+						//free local ref
+						if (hasstoredmember)
+							this->removeStoredMember();
+						else
+							this->decRef();
+					}
+					for(asAtom* i=cc->locals+1;i< cc->lastlocal;++i)
+					{
+						LOG_CALL("locals:"<<asAtomHandler::toDebugString(*i));
+						ASATOM_DECREF_POINTER(i);
+					}
+					if (cc->locals[0].uintval != obj.uintval)
+					{
+						LOG_CALL("locals0:"<<asAtomHandler::toDebugString(cc->locals[0]));
+						ASATOM_DECREF_POINTER(cc->locals);
+					}
 					throw excobj;
+				}
 				break;
 			}
 			continue;
@@ -505,7 +533,7 @@
 	//The stack may be not clean, is this a programmer/compiler error?
 	if(cc->stackp != cc->stack)
 	{
-		LOG(LOG_ERROR,"Stack not clean at the end of function:"<<getSystemState()->getStringFromUniqueId(this->functionname));
+		LOG(LOG_INFO,"Stack not clean at the end of function:"<<getSystemState()->getStringFromUniqueId(this->functionname));
 		while(cc->stackp != cc->stack)
 		{
 			--cc->stackp;
@@ -575,7 +603,10 @@
 	func_scope.reset();
 	val = nullptr;
 	mi = nullptr;
+	methodnumber = UINT32_MAX;
 	fromNewFunction = false;
+	classInit = false;
+	scriptInit = false;
 	return IFunction::destruct();
 }
 
@@ -749,6 +780,7 @@
 	ret->prototype->addStoredMember();
 	ret->incRef();
 	ret->prototype->setVariableByQName("constructor","",ret,DECLARED_TRAIT);
+	this->global->addOwnedObject(ret);
 	return ret;
 }
 
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/toplevel.h lightspark-master/src/scripting/toplevel/toplevel.h
--- lightspark-0.9.0/src/scripting/toplevel/toplevel.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/toplevel.h	2025-03-05 20:13:02.187865742 +0100
@@ -262,7 +262,10 @@
 	synt_function val;
 	/* Pointer to multiname, if this function is a simple getter or setter */
 	multiname* simpleGetterOrSetterName;
-	bool fromNewFunction;
+	uint32_t methodnumber; // position in the method_info list of the ABCContext, currently only valid in methods created from newfunction tag
+	bool fromNewFunction:1;
+	bool classInit:1;
+	bool scriptInit:1;
 	SyntheticFunction(ASWorker* wrk,Class_base* c,method_info* m);
 protected:
 	IFunction* clone(ASWorker* wrk) override;
@@ -308,6 +311,9 @@
 	void checkParamTypes(bool opportunistic=false);
 	bool canSkipCoercion(int param, Class_base* cls);
 	inline bool isFromNewFunction() { return fromNewFunction; }
+	inline bool isClassInit() { return classInit; }
+	inline bool isScriptInit() { return scriptInit; }
+	inline uint32_t getMethodNumber() { return methodnumber; }
 };
 
 /*
@@ -367,10 +373,10 @@
 		c->handleConstruction(obj,nullptr,0,true);
 		return ret;
 	}
-	static AVM1Function* getAVM1Function(ASWorker* wrk,DisplayObject* clip,Activation_object* act, AVM1context* ctx,std::vector<uint32_t>& params, std::vector<uint8_t>& actions, std::vector<uint8_t> paramregisternumbers=std::vector<uint8_t>(), bool preloadParent=false, bool preloadRoot=false, bool suppressSuper=true, bool preloadSuper=false, bool suppressArguments=false, bool preloadArguments=false, bool suppressThis=true, bool preloadThis=false, bool preloadGlobal=false)
+	static AVM1Function* getAVM1Function(ASWorker* wrk,DisplayObject* clip,Activation_object* act, AVM1context* ctx,std::vector<uint32_t>& params, std::vector<uint8_t>& actions, const _R<AVM1Scope>& scope, std::vector<uint8_t> paramregisternumbers=std::vector<uint8_t>(), bool preloadParent=false, bool preloadRoot=false, bool suppressSuper=true, bool preloadSuper=false, bool suppressArguments=false, bool preloadArguments=false, bool suppressThis=true, bool preloadThis=false, bool preloadGlobal=false)
 	{
 		Class<IFunction>* c=Class<IFunction>::getClass(wrk->getSystemState());
-		AVM1Function*  ret =new (c->memoryAccount) AVM1Function(wrk,c, clip, act,ctx, params,actions,paramregisternumbers,preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal);
+		AVM1Function*  ret =new (c->memoryAccount) AVM1Function(wrk,c, clip, act,ctx, params,actions,scope,paramregisternumbers,preloadParent,preloadRoot,suppressSuper,preloadSuper,suppressArguments,preloadArguments,suppressThis,preloadThis,preloadGlobal);
 		ret->objfreelist = nullptr;
 		ret->constructIndicator = true;
 		ret->constructorCallComplete = true;
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Vector.cpp lightspark-master/src/scripting/toplevel/Vector.cpp
--- lightspark-0.9.0/src/scripting/toplevel/Vector.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Vector.cpp	2025-03-05 20:13:02.186865717 +0100
@@ -200,8 +200,15 @@
 		for(unsigned int i=0;i<a->size();++i)
 		{
 			asAtom o = a->at(i);
-			res->checkValue(o,false);
-			ASATOM_ADDSTOREDMEMBER(o);
+			bool isNewObject=false;
+			res->checkValue(o,false,&isNewObject);
+			ASObject* obj = asAtomHandler::getObject(o);
+			if (obj)
+			{
+				if (!isNewObject)
+					obj->incRef();
+				obj->addStoredMember();
+			}
 			res->vec.push_back(o);
 		}
 		res->setIsInitialized(true);
@@ -216,8 +223,15 @@
 		for(unsigned int i=0;i<ba->getLength();++i)
 		{
 			asAtom o = asAtomHandler::fromInt(ba->getBufferNoCheck()[i]);
-			res->checkValue(o,false);
-			ASATOM_ADDSTOREDMEMBER(o);
+			bool isNewObject=false;
+			res->checkValue(o,false,&isNewObject);
+			ASObject* obj = asAtomHandler::getObject(o);
+			if (obj)
+			{
+				if (!isNewObject)
+					obj->incRef();
+				obj->addStoredMember();
+			}
 			res->vec.push_back(o);
 		}
 	}
@@ -303,11 +317,13 @@
 				if (asAtomHandler::isValid(*it))
 				{
 					res->vec[index]= *it;
-					res->checkValue(res->vec[index],false);
+					bool isNewObject=false;
+					res->checkValue(res->vec[index],false,&isNewObject);
 					ASObject* obj = asAtomHandler::getObject(res->vec[index]);
 					if (obj)
 					{
-						obj->incRef();
+						if (!isNewObject)
+							obj->incRef();
 						obj->addStoredMember();
 					}
 				}
@@ -553,8 +569,15 @@
 		//The proprietary player violates the specification and allows elements of any type to be pushed;
 		//they are converted to the vec_type
 		asAtom v = args[i];
-		th->checkValue(v,true);
-		ASATOM_ADDSTOREDMEMBER(v);
+		bool isNewObject= false;
+		th->checkValue(v,true,&isNewObject);
+		ASObject* ob = asAtomHandler::getObject(v);
+		if (ob)
+		{
+			if (!isNewObject)
+				ob->incRef();
+			ob->addStoredMember();
+		}
 		th->vec.push_back(v);
 	}
 	asAtomHandler::setUInt(ret,wrk,(uint32_t)th->vec.size());
@@ -808,15 +831,20 @@
 		return asAtomHandler::nullAtom;
 }
 
-bool Vector::checkValue(asAtom& o, bool allowconversion)
+bool Vector::checkValue(asAtom& o, bool allowconversion,bool* isNewObject)
 {
+	asAtom oldValue = o;
 	if (!vec_type->coerceForTemplate(getInstanceWorker(),o,allowconversion))
 	{
 		Class_base* cls = dynamic_cast<Class_base*>(vec_type);
 		if(cls && cls != Class<ASObject>::getRef(getSystemState()).getPtr() && (!asAtomHandler::getObject(o) || !asAtomHandler::getObject(o)->getClass() || !asAtomHandler::getObject(o)->getClass()->isSubClass(cls)))
 			createError<TypeError>(getInstanceWorker(),kCheckTypeFailedError, asAtomHandler::toObject(o,getInstanceWorker())->getClassName(), cls->getQualifiedClassName());
+		if (isNewObject)
+			*isNewObject=false;
 		return false;
 	}
+	if (isNewObject && oldValue.uintval != o.uintval)
+		*isNewObject=true; // value was coerced to a new object
 	return true;
 }
 
@@ -839,8 +867,15 @@
 		if (asAtomHandler::isValid(th->vec[i]))
 		{
 			res->vec[j] =th->vec[i];
-			th->vec_type->coerceForTemplate(wrk,res->vec[j],false);
-			ASATOM_ADDSTOREDMEMBER(res->vec[j]);
+			bool isNewObject = false;
+			res->checkValue(res->vec[j],true,&isNewObject);
+			ASObject* ob = asAtomHandler::getObject(res->vec[j]);
+			if (ob)
+			{
+				if (!isNewObject)
+					ob->incRef();
+				ob->addStoredMember();
+			}
 		}
 		j++;
 	}
@@ -897,12 +932,14 @@
 	for(unsigned int i=2;i<argslen;i++)
 	{
 		asAtom o = args[i];
-		th->checkValue(o,true);
-		ASObject* obj = asAtomHandler::getObject(o);
-		if (obj)
-		{
-			obj->incRef();
-			obj->addStoredMember();
+		bool isNewObject=false;
+		th->checkValue(o,true,&isNewObject);
+		ASObject* ob = asAtomHandler::getObject(o);
+		if (ob)
+		{
+			if (!isNewObject)
+				ob->incRef();
+			ob->addStoredMember();
 		}
 		th->vec.push_back(o);
 	}
@@ -1274,12 +1311,13 @@
 		for(uint32_t i=0;i<argslen;i++)
 		{
 			th->vec[i] = args[i];
-			if (!th->vec_type->coerce(th->getInstanceWorker(),th->vec[i]))
-				ASATOM_INCREF(th->vec[i]);
+			bool isNewObject=false;
+			th->checkValue(th->vec[i],true,&isNewObject);
 			ASObject* obj = asAtomHandler::getObject(th->vec[i]);
 			if (obj)
 			{
-				obj->incRef();
+				if (!isNewObject)
+					obj->incRef();
 				obj->addStoredMember();
 			}
 		}
@@ -1316,8 +1354,10 @@
 			res->decRef();
 			return;
 		}
-		res->vec_type->coerce(wrk,funcRet);
-		ASATOM_ADDSTOREDMEMBER(funcRet);
+		res->checkValue(funcRet,true);
+		ASObject* ob = asAtomHandler::getObject(funcRet);
+		if(ob)
+			ob->addStoredMember();
 		res->vec.push_back(funcRet);
 	}
 
@@ -1381,7 +1421,8 @@
 	int32_t index;
 	asAtom o=asAtomHandler::invalidAtom;
 	ARG_CHECK(ARG_UNPACK(index)(o));
-	th->checkValue(o,true);
+	bool isNewObject=false;
+	th->checkValue(o,true,&isNewObject);
 	if (index < 0 && th->vec.size() >= (uint32_t)(-index))
 		index = th->vec.size()+(index);
 	if (index < 0)
@@ -1389,7 +1430,8 @@
 	ASObject* ob = asAtomHandler::getObject(o);
 	if (ob)
 	{
-		ob->incRef();
+		if (!isNewObject)
+			ob->incRef();
 		ob->addStoredMember();
 	}
 	if ((uint32_t)index >= th->vec.size())
diff -u -r -N lightspark-0.9.0/src/scripting/toplevel/Vector.h lightspark-master/src/scripting/toplevel/Vector.h
--- lightspark-0.9.0/src/scripting/toplevel/Vector.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/scripting/toplevel/Vector.h	2025-03-05 20:13:02.186865717 +0100
@@ -270,7 +270,7 @@
 	};
 	asAtom getDefaultValue();
 public:
-	bool checkValue(asAtom& o, bool allowconversion);
+	bool checkValue(asAtom& o, bool allowconversion, bool *isNewObject=nullptr);
 	class sortComparatorWrapper
 	{
 	private:
diff -u -r -N lightspark-0.9.0/src/swf.cpp lightspark-master/src/swf.cpp
--- lightspark-0.9.0/src/swf.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/swf.cpp	2025-03-05 20:13:02.187865742 +0100
@@ -210,7 +210,7 @@
 									   "__proto__","target","flash.events:IEventDispatcher","addEventListener","removeEventListener","dispatchEvent","hasEventListener",
 									   "onConnect","onData","onClose","onSelect",
 									   "add","alpha","darken","difference","erase","hardlight","invert","layer","lighten","multiply","overlay","screen","subtract",
-									   "text","null","true","false"
+									   "text","null","true","false","global","init","onSetFocus","onResize"
 									  };
 
 extern uint32_t asClassCount;
@@ -238,7 +238,7 @@
 	renderThread(nullptr),inputThread(nullptr),engineData(nullptr),dumpedSWFPathAvailable(0),
 	vmVersion(VMNONE),childPid(0),
 	parameters(NullRef),
-	invalidateQueueHead(NullRef),invalidateQueueTail(NullRef),lastUsedStringId(0),lastUsedNamespaceId(0x7fffffff),framePhase(FramePhase::IDLE),
+	invalidateQueueHead(NullRef),invalidateQueueTail(NullRef),lastUsedNamespaceId(0x7fffffff),framePhase(FramePhase::IDLE),
 	showProfilingData(false),allowFullscreen(false),flashMode(mode),swffilesize(fileSize),instanceCounter(0),avm1global(nullptr),
 	currentVm(nullptr),builtinClasses(nullptr),useInterpreter(true),useFastInterpreter(false),useJit(false),ignoreUnhandledExceptions(false),runSingleThreaded(_runSingleThreaded),exitOnError(ERROR_NONE),
 	systemDomain(nullptr),worker(nullptr),workerDomain(nullptr),singleworker(true),
@@ -255,25 +255,18 @@
 	use_testrunner_date(false)
 {
 	//Forge the builtin strings
-	uniqueStringIDMap.reserve(LAST_BUILTIN_STRING);
 	tiny_string sempty;
-	uniqueStringMap.emplace(make_pair(sempty,lastUsedStringId));
-	uniqueStringIDMap.push_back(sempty);
-	lastUsedStringId++;
-	for(uint32_t i=1;i<BUILTIN_STRINGS_CHAR_MAX;i++)
-	{
-		tiny_string s = tiny_string::fromChar(i);
-		uniqueStringMap.emplace(make_pair(s,lastUsedStringId));
-		uniqueStringIDMap.push_back(s);
-		lastUsedStringId++;
-	}
-	for(uint32_t i=BUILTIN_STRINGS_CHAR_MAX;i<LAST_BUILTIN_STRING;i++)
-	{
-		tiny_string s(builtinStrings[i-BUILTIN_STRINGS_CHAR_MAX]);
-		uniqueStringMap.emplace(make_pair(s,lastUsedStringId));
-		uniqueStringIDMap.push_back(s);
-		lastUsedStringId++;
-	}
+	uniqueStringMap.emplace(sempty);
+	for(size_t i = 1; i < BUILTIN_STRINGS_CHAR_MAX; i++)
+		uniqueStringMap.emplace(tiny_string::fromChar(i));
+
+	constexpr size_t builtinSize =
+	(
+		LAST_BUILTIN_STRING -
+		BUILTIN_STRINGS_CHAR_MAX
+	);
+	for (size_t i = 0; i < builtinSize; i++)
+		uniqueStringMap.emplace(builtinStrings[i]);
 	//Forge the empty namespace and make sure it gets id 0
 	nsNameAndKindImpl emptyNs(BUILTIN_STRINGS::EMPTY, NAMESPACE);
 	uint32_t nsId;
@@ -309,6 +302,7 @@
 
 	worker = new (unaccountedMemory) ASWorker(this);
 	worker->setRefConstant();
+	setTLSWorker(worker); // needed for 32bit class initialization
 	Class<ASWorker>::getClass(this)->setupDeclaredTraits(worker);
 	worker->setClass(Class<ASWorker>::getClass(this));
 	worker->constructionComplete();
@@ -711,12 +705,14 @@
 		delete mainClip;
 	delete[] builtinClasses;
 	builtinClasses=nullptr;
+	setTLSSys(nullptr);
 #ifndef NDEBUG
 	for (auto it = memcheckset.begin(); it != memcheckset.end(); it++)
 	{
-		LOG(LOG_ERROR,"memcheck leak found:"<<(*it)<<" "<<(*it)->getObjectType()<<" "<<(*it)->getSubtype());
+		LOG(LOG_INFO,"memcheck leak found:"<<(*it)<<" "<<(*it)->getObjectType()<<" "<<(*it)->getSubtype()<<" "<<(*it)->getRefCount());
 	}
-	LOG(LOG_ERROR,"memleaks found:"<<memcheckset.size());
+	if (memcheckset.size())
+		LOG(LOG_ERROR,"memleaks found:"<<memcheckset.size());
 #endif
 }
 
@@ -1465,7 +1461,7 @@
 					addJob(j);
 					drawjobLock.unlock();
 				}
-				else if (renderThread != nullptr)
+				else if (EngineData::enablerendering && renderThread != nullptr)
 					renderThread->addRefreshableSurface(d,drawobj);
 				if (renderThread != nullptr && renderThread->isStarted())
 					drawobj->resetNeedsTextureRecalculation();
@@ -1477,7 +1473,7 @@
 		cur=next;
 	}
 	influshing=false;
-	if (renderThread != nullptr)
+	if (EngineData::enablerendering && renderThread != nullptr)
 		renderThread->signalSurfaceRefresh();
 	invalidateQueueHead=NullRef;
 	invalidateQueueTail=NullRef;
@@ -2266,6 +2262,7 @@
 
 void SystemState::trace(const tiny_string& str)
 {
+	//LOG(LOG_ERROR,"trace:"<<str);
 	Logger genericLogger;
 	logger.valueOr(genericLogger).trace(str);
 }
@@ -2324,7 +2321,7 @@
 
 	// Only run the renderer once, if we ran `SystemState::tick()`
 	// multiple times.
-	if (numFrames > 0)
+	if (numFrames > 0 && EngineData::enablerendering)
 		renderThread->runTick();
 
 	// In order to prevent running at max speed, reset the accumulator
@@ -2477,25 +2474,41 @@
 const tiny_string& SystemState::getStringFromUniqueId(uint32_t id) const
 {
 	Locker l(poolMutex);
-	assert(uniqueStringIDMap.size() > id);
-	return uniqueStringIDMap[id];
+	assert(uniqueStringMap.size() > id);
+	return *uniqueStringMap.nth(id);
 }
 
 uint32_t SystemState::getUniqueStringId(const tiny_string& s)
 {
+	// NOTE: In SWF 6, and earlier (when used as property keys), string
+	// IDs are case insensitive.
+	bool caseSensitive =
+	(
+		worker->needsActionScript3() ||
+		worker->AVM1getSwfVersion() > 6
+	);
+	return getUniqueStringId(s, caseSensitive);
+}
+
+uint32_t SystemState::getUniqueStringId(const tiny_string& s, bool caseSensitive)
+{
 	Locker l(poolMutex);
-	auto it=uniqueStringMap.find(s);
-	if(it==uniqueStringMap.end())
+
+	auto it = !caseSensitive ? uniqueStringMap.find
+	(
+		CaselessString(s)
+	) : uniqueStringMap.find(s);
+
+	if (it == uniqueStringMap.end())
 	{
 		tiny_string s2;
 		s2 += s; // ensure that a deep copy of the string is stored in the map, as s might be type READONLY/DYNAMIC and be deleted later
-		auto ret=uniqueStringMap.insert(make_pair(s2,lastUsedStringId));
-		uniqueStringIDMap.push_back(s2);
+		auto ret=uniqueStringMap.insert(s2);
 		assert(ret.second);
-		it=ret.first;
-		lastUsedStringId++;
+		it = ret.first;
 	}
-	return it->second;
+
+	return std::distance(uniqueStringMap.begin(), it);
 }
 
 const nsNameAndKindImpl& SystemState::getNamespaceFromUniqueId(uint32_t id) const
diff -u -r -N lightspark-0.9.0/src/swf.h lightspark-master/src/swf.h
--- lightspark-0.9.0/src/swf.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/swf.h	2025-03-05 20:13:02.187865742 +0100
@@ -21,6 +21,7 @@
 #define SWF_H 1
 
 #include "asobject.h"
+#include "caseless_string.h"
 #include "forwards/events.h"
 #include "forwards/scripting/flash/text/flashtext.h"
 #include "interfaces/logger.h"
@@ -40,6 +41,7 @@
 #include <unordered_set>
 #include <unordered_map>
 #include <string>
+#include <tsl/ordered_set.h>
 #include "swftypes.h"
 #include "memory_support.h"
 #include "scripting/abcutils.h"
@@ -243,9 +245,7 @@
 	 * Pooling support
 	 */
 	mutable Mutex poolMutex;
-	unordered_map<tiny_string, uint32_t> uniqueStringMap;
-	vector<tiny_string> uniqueStringIDMap;
-	uint32_t lastUsedStringId;
+	tsl::ordered_set<tiny_string, CaselessHash, std::equal_to<>> uniqueStringMap;
 	map<nsNameAndKindImpl, uint32_t> uniqueNamespaceImplMap;
 	unordered_map<uint32_t,nsNameAndKindImpl> uniqueNamespaceIDMap;
 	//This needs to be atomic because it's decremented without the mutex held
@@ -524,6 +524,7 @@
 	 * Pooling support
 	 */
 	uint32_t getUniqueStringId(const tiny_string& s);
+	uint32_t getUniqueStringId(const tiny_string& s, bool caseSensitive);
 	const tiny_string& getStringFromUniqueId(uint32_t id) const;
 	/*
 	 * Looks for the given nsNameAndKindImpl in the map.
diff -u -r -N lightspark-0.9.0/src/swftypes.h lightspark-master/src/swftypes.h
--- lightspark-0.9.0/src/swftypes.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/swftypes.h	2025-03-05 20:13:02.187865742 +0100
@@ -53,7 +53,8 @@
 					   ,STRING_PROTO,STRING_TARGET,STRING_FLASH_EVENTS_IEVENTDISPATCHER,STRING_ADDEVENTLISTENER,STRING_REMOVEEVENTLISTENER,STRING_DISPATCHEVENT,STRING_HASEVENTLISTENER
 					   ,STRING_ONCONNECT,STRING_ONDATA,STRING_ONCLOSE,STRING_ONSELECT
 					   ,STRING_ADD,STRING_ALPHA,STRING_DARKEN,STRING_DIFFERENCE,STRING_ERASE,STRING_HARDLIGHT,STRING_INVERT,STRING_LAYER,STRING_LIGHTEN,STRING_MULTIPLY,STRING_OVERLAY,STRING_SCREEN,STRING_SUBTRACT
-					   ,STRING_TEXT,STRING_NULL,STRING_TRUE,STRING_FALSE
+					   ,STRING_TEXT,STRING_NULL,STRING_TRUE,STRING_FALSE,STRING_GLOBAL,STRING_INIT
+					   ,STRING_ONSETFOCUS,STRING_ONRESIZE
 					   ,LAST_BUILTIN_STRING };
 enum BUILTIN_NAMESPACES { EMPTY_NS=0, AS3_NS };
 
@@ -61,24 +62,42 @@
 enum SWFOBJECT_TYPE { T_OBJECT=0, T_INTEGER=1, T_NUMBER=2, T_FUNCTION=3, T_UNDEFINED=4, T_NULL=5, T_STRING=6, 
 	T_INVALID=7, T_BOOLEAN=8, T_ARRAY=9, T_CLASS=10, T_QNAME=11, T_NAMESPACE=12, T_UINTEGER=13, T_PROXY=14, T_TEMPLATE=15};
 // this is used to avoid calls to dynamic_cast when testing for some classes
-enum CLASS_SUBTYPE { SUBTYPE_NOT_SET, SUBTYPE_PROXY, SUBTYPE_REGEXP, SUBTYPE_XML, SUBTYPE_XMLLIST,SUBTYPE_DATE, SUBTYPE_INHERIT, SUBTYPE_OBJECTCONSTRUCTOR,SUBTYPE_FUNCTIONOBJECT
-					 ,SUBTYPE_GLOBAL,SUBTYPE_FUNCTION,SUBTYPE_SYNTHETICFUNCTION,SUBTYPE_EVENT,SUBTYPE_WAITABLE_EVENT, SUBTYPE_INTERACTIVE_OBJECT, SUBTYPE_STAGE
-					 ,SUBTYPE_LOADERINFO,SUBTYPE_CONTEXTMENU,SUBTYPE_BITMAP,SUBTYPE_BITMAPDATA,SUBTYPE_SOUND,SUBTYPE_SOUNDTRANSFORM,SUBTYPE_SOUNDCHANNEL,SUBTYPE_PROGRESSEVENT
-					 ,SUBTYPE_VECTOR,SUBTYPE_DISPLAYOBJECT,SUBTYPE_DISPLAYOBJECTCONTAINER,SUBTYPE_CONTEXTMENUBUILTINITEMS, SUBTYPE_SHAREDOBJECT,SUBTYPE_TEXTFIELD,SUBTYPE_TEXTFORMAT
-					 ,SUBTYPE_KEYBOARD_EVENT,SUBTYPE_MOUSE_EVENT,SUBTYPE_ROOTMOVIECLIP,SUBTYPE_MATRIX,SUBTYPE_POINT,SUBTYPE_RECTANGLE,SUBTYPE_COLORTRANSFORM,SUBTYPE_BYTEARRAY
-					 ,SUBTYPE_APPLICATIONDOMAIN,SUBTYPE_LOADERCONTEXT,SUBTYPE_SPRITE,SUBTYPE_MOVIECLIP,SUBTYPE_TEXTBLOCK,SUBTYPE_FONTDESCRIPTION,SUBTYPE_CONTENTELEMENT,SUBTYPE_ELEMENTFORMAT
-					 ,SUBTYPE_TEXTELEMENT, SUBTYPE_ACTIVATIONOBJECT,SUBTYPE_TEXTLINE,SUBTYPE_STAGE3D,SUBTYPE_MATRIX3D,SUBTYPE_INDEXBUFFER3D,SUBTYPE_PROGRAM3D,SUBTYPE_VERTEXBUFFER3D
-					 ,SUBTYPE_CONTEXT3D,SUBTYPE_TEXTUREBASE,SUBTYPE_TEXTURE,SUBTYPE_CUBETEXTURE,SUBTYPE_RECTANGLETEXTURE,SUBTYPE_VIDEOTEXTURE,SUBTYPE_VECTOR3D,SUBTYPE_NETSTREAM
+enum CLASS_SUBTYPE { SUBTYPE_NOT_SET, SUBTYPE_PROXY, SUBTYPE_REGEXP, SUBTYPE_XML, SUBTYPE_XMLLIST,SUBTYPE_DATE
+					 ,SUBTYPE_INHERIT, SUBTYPE_OBJECTCONSTRUCTOR,SUBTYPE_FUNCTIONOBJECT
+					 ,SUBTYPE_GLOBAL,SUBTYPE_FUNCTION,SUBTYPE_SYNTHETICFUNCTION,SUBTYPE_EVENT,SUBTYPE_WAITABLE_EVENT
+					 ,SUBTYPE_INTERACTIVE_OBJECT, SUBTYPE_STAGE
+					 ,SUBTYPE_LOADERINFO,SUBTYPE_CONTEXTMENU,SUBTYPE_BITMAP,SUBTYPE_BITMAPDATA,SUBTYPE_SOUND
+					 ,SUBTYPE_SOUNDTRANSFORM,SUBTYPE_SOUNDCHANNEL,SUBTYPE_PROGRESSEVENT
+					 ,SUBTYPE_VECTOR,SUBTYPE_DISPLAYOBJECT,SUBTYPE_DISPLAYOBJECTCONTAINER,SUBTYPE_CONTEXTMENUBUILTINITEMS
+					 ,SUBTYPE_SHAREDOBJECT,SUBTYPE_TEXTFIELD,SUBTYPE_TEXTFORMAT
+					 ,SUBTYPE_KEYBOARD_EVENT,SUBTYPE_MOUSE_EVENT,SUBTYPE_ROOTMOVIECLIP,SUBTYPE_MATRIX,SUBTYPE_POINT
+					 ,SUBTYPE_RECTANGLE,SUBTYPE_COLORTRANSFORM,SUBTYPE_BYTEARRAY
+					 ,SUBTYPE_APPLICATIONDOMAIN,SUBTYPE_LOADERCONTEXT,SUBTYPE_SPRITE,SUBTYPE_MOVIECLIP,SUBTYPE_TEXTBLOCK
+					 ,SUBTYPE_FONTDESCRIPTION,SUBTYPE_CONTENTELEMENT,SUBTYPE_ELEMENTFORMAT
+					 ,SUBTYPE_TEXTELEMENT, SUBTYPE_ACTIVATIONOBJECT,SUBTYPE_TEXTLINE,SUBTYPE_STAGE3D,SUBTYPE_MATRIX3D
+					 ,SUBTYPE_INDEXBUFFER3D,SUBTYPE_PROGRAM3D,SUBTYPE_VERTEXBUFFER3D
+					 ,SUBTYPE_CONTEXT3D,SUBTYPE_TEXTUREBASE,SUBTYPE_TEXTURE,SUBTYPE_CUBETEXTURE,SUBTYPE_RECTANGLETEXTURE
+					 ,SUBTYPE_VIDEOTEXTURE,SUBTYPE_VECTOR3D,SUBTYPE_NETSTREAM
 					 ,SUBTYPE_WORKER,SUBTYPE_WORKERDOMAIN,SUBTYPE_MUTEX,SUBTYPE_AVM1FUNCTION,SUBTYPE_SAMPLEDATA_EVENT
-					 ,SUBTYPE_BITMAPFILTER,SUBTYPE_GLOWFILTER,SUBTYPE_DROPSHADOWFILTER,SUBTYPE_GRADIENTGLOWFILTER,SUBTYPE_BEVELFILTER,SUBTYPE_COLORMATRIXFILTER,SUBTYPE_BLURFILTER,SUBTYPE_CONVOLUTIONFILTER,SUBTYPE_DISPLACEMENTFILTER,SUBTYPE_GRADIENTBEVELFILTER,SUBTYPE_SHADERFILTER
-					 ,SUBTYPE_THROTTLE_EVENT,SUBTYPE_CONTEXTMENUEVENT,SUBTYPE_GAMEINPUTEVENT, SUBTYPE_GAMEINPUTDEVICE, SUBTYPE_VIDEO, SUBTYPE_MESSAGECHANNEL, SUBTYPE_CONDITION
-					 ,SUBTYPE_FILE, SUBTYPE_FILEMODE, SUBTYPE_FILESTREAM, SUBTYPE_FILEREFERENCE, SUBTYPE_DATAGRAMSOCKET, SUBTYPE_NATIVEWINDOW,SUBTYPE_EXTENSIONCONTEXT,SUBTYPE_SIMPLEBUTTON,SUBTYPE_SHAPE,SUBTYPE_MORPHSHAPE
-					 ,SUBTYPE_URLLOADER,SUBTYPE_URLREQUEST,SUBTYPE_DICTIONARY,SUBTYPE_TEXTLINEMETRICS,SUBTYPE_XMLNODE,SUBTYPE_XMLDOCUMENT,SUBTYPE_LOADER
+					 ,SUBTYPE_BITMAPFILTER,SUBTYPE_GLOWFILTER,SUBTYPE_DROPSHADOWFILTER,SUBTYPE_GRADIENTGLOWFILTER
+					 ,SUBTYPE_BEVELFILTER,SUBTYPE_COLORMATRIXFILTER,SUBTYPE_BLURFILTER,SUBTYPE_CONVOLUTIONFILTER
+					 ,SUBTYPE_DISPLACEMENTFILTER,SUBTYPE_GRADIENTBEVELFILTER,SUBTYPE_SHADERFILTER
+					 ,SUBTYPE_THROTTLE_EVENT,SUBTYPE_CONTEXTMENUEVENT,SUBTYPE_GAMEINPUTEVENT, SUBTYPE_GAMEINPUTDEVICE
+					 ,SUBTYPE_VIDEO, SUBTYPE_MESSAGECHANNEL, SUBTYPE_CONDITION
+					 ,SUBTYPE_FILE, SUBTYPE_FILEMODE, SUBTYPE_FILESTREAM, SUBTYPE_FILEREFERENCE, SUBTYPE_DATAGRAMSOCKET
+					 ,SUBTYPE_NATIVEWINDOW,SUBTYPE_EXTENSIONCONTEXT,SUBTYPE_SIMPLEBUTTON,SUBTYPE_SHAPE,SUBTYPE_MORPHSHAPE
+					 ,SUBTYPE_URLLOADER,SUBTYPE_URLREQUEST,SUBTYPE_DICTIONARY,SUBTYPE_TEXTLINEMETRICS,SUBTYPE_XMLNODE
+					 ,SUBTYPE_XMLDOCUMENT,SUBTYPE_LOADER
 					 ,SUBTYPE_TEXTJUSTIFIER,SUBTYPE_SPACEJUSTIFIER,SUBTYPE_EASTASIANJUSTIFIER
-					 ,SUBTYPE_ERROR,SUBTYPE_SECURITYERROR,SUBTYPE_ARGUMENTERROR,SUBTYPE_DEFINITIONERROR,SUBTYPE_EVALERROR,SUBTYPE_RANGEERROR,SUBTYPE_REFERENCEERROR,SUBTYPE_SYNTAXERROR,SUBTYPE_TYPEERROR,SUBTYPE_URIERROR,SUBTYPE_VERIFYERROR,SUBTYPE_UNINITIALIZEDERROR
-					 ,SUBTYPE_AVM1SOUND,SUBTYPE_LOCALCONNECTION,SUBTYPE_NATIVEWINDOWBOUNDSEVENT,SUBTYPE_AVM1MOVIECLIP,SUBTYPE_AVM1MOVIECLIPLOADER
-					 ,SUBTYPE_GRAPHICSENDFILL,SUBTYPE_GRAPHICSSOLIDFILL,SUBTYPE_GRAPHICSPATH,SUBTYPE_AVM1MOVIE,SUBTYPE_URLVARIABLES
+					 ,SUBTYPE_ERROR,SUBTYPE_SECURITYERROR,SUBTYPE_ARGUMENTERROR,SUBTYPE_DEFINITIONERROR,SUBTYPE_EVALERROR
+					 ,SUBTYPE_RANGEERROR,SUBTYPE_REFERENCEERROR,SUBTYPE_SYNTAXERROR,SUBTYPE_TYPEERROR,SUBTYPE_URIERROR
+					 ,SUBTYPE_VERIFYERROR,SUBTYPE_UNINITIALIZEDERROR
+					 ,SUBTYPE_AVM1SOUND,SUBTYPE_LOCALCONNECTION,SUBTYPE_NATIVEWINDOWBOUNDSEVENT,SUBTYPE_AVM1MOVIECLIP
+					 ,SUBTYPE_AVM1MOVIECLIPLOADER,SUBTYPE_GRAPHICSENDFILL,SUBTYPE_GRAPHICSSOLIDFILL,SUBTYPE_GRAPHICSPATH
+					 ,SUBTYPE_AVM1MOVIE,SUBTYPE_URLVARIABLES
 					 ,SUBTYPE_AVM1XMLDOCUMENT,SUBTYPE_AVM1XMLNODE
+					 ,SUBTYPE_FOCUSEVENT
+					 ,SUBTYPE_STACKOVERFLOWERROR
 				   };
  
 enum STACK_TYPE{STACK_NONE=0,STACK_OBJECT,STACK_INT,STACK_UINT,STACK_NUMBER,STACK_BOOLEAN};
@@ -154,6 +173,7 @@
 class URLInfo;
 class AVM1Function;
 class AVM1context;
+class AVM1Scope;
 struct namespace_info;
 
 struct multiname;
@@ -1234,11 +1254,11 @@
 	};
 	union
 	{
-		int32_t AnchorDeltaY:18;
+		int32_t AnchorDeltaY;
 		uint16_t LineStyle;
 	};
-	int32_t DeltaX:18;
-	int32_t DeltaY:18;
+	int32_t DeltaX;
+	int32_t DeltaY;
 	bool TypeFlag:1;
 	bool StateNewStyles:1;
 	bool StateLineStyle:1;
@@ -1645,14 +1665,24 @@
 	}
 };
 class Activation_object;
+class AVM1Scope;
 class ACTIONRECORD
 {
 public:
 	static void PushStack(std::stack<asAtom>& stack,const asAtom& a);
 	static asAtom PopStack(std::stack<asAtom>& stack);
 	static asAtom PeekStack(std::stack<asAtom>& stack);
-	static void executeActions(DisplayObject* clip, AVM1context* context, const std::vector<uint8_t> &actionlist, uint32_t startactionpos, std::map<uint32_t, asAtom> &scopevariables, bool fromInitAction = false, asAtom *result = nullptr, asAtom* obj = nullptr, asAtom *args = nullptr, uint32_t num_args=0, const std::vector<uint32_t>& paramnames=std::vector<uint32_t>(), const std::vector<uint8_t>& paramregisternumbers=std::vector<uint8_t>(),
-			bool preloadParent=false, bool preloadRoot=false, bool suppressSuper=true, bool preloadSuper=false, bool suppressArguments=false, bool preloadArguments=false, bool suppressThis=true, bool preloadThis=false, bool preloadGlobal=false, AVM1Function *caller = nullptr, AVM1Function *callee = nullptr, Activation_object *actobj=nullptr, asAtom* superobj=nullptr);
+	static void executeActions(
+		DisplayObject* clip, AVM1context* context, const std::vector<uint8_t> &actionlist, uint32_t startactionpos,
+		AVM1Scope* scope = nullptr, bool fromInitAction = false, asAtom *result = nullptr,
+		asAtom* obj = nullptr, asAtom *args = nullptr, uint32_t num_args=0,
+		const std::vector<uint32_t>& paramnames=std::vector<uint32_t>(),
+		const std::vector<uint8_t>& paramregisternumbers=std::vector<uint8_t>(),
+		bool preloadParent=false, bool preloadRoot=false, bool suppressSuper=true,
+		bool preloadSuper=false, bool suppressArguments=false, bool preloadArguments=false,
+		bool suppressThis=true, bool preloadThis=false, bool preloadGlobal=false,
+		AVM1Function *caller = nullptr, AVM1Function *callee = nullptr,
+		Activation_object *actobj=nullptr, asAtom* superobj=nullptr, bool isInternalCall=false);
 };
 class BUTTONCONDACTION
 {
diff -u -r -N lightspark-0.9.0/src/tiny_string.cpp lightspark-master/src/tiny_string.cpp
--- lightspark-0.9.0/src/tiny_string.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/tiny_string.cpp	2025-03-05 20:13:02.188865766 +0100
@@ -277,6 +277,21 @@
 	return std::string(buf,stringSize-1);
 }
 
+bool tiny_string::contains(const tiny_string& str) const
+{
+	return find(str) != npos;
+}
+
+bool tiny_string::contains(uint32_t ch) const
+{
+	for (size_t i = 0; i < numChars(); ++i)
+	{
+		if (charAt(i) == ch)
+			return true;
+	}
+	return false;
+}
+
 bool tiny_string::startsWith(const tiny_string& str) const
 {
 	auto strSize = str.numBytes();
@@ -439,6 +454,66 @@
 		return g_utf8_pointer_to_offset(buf,buf+bytepos);
 }
 
+uint32_t tiny_string::findFirst(const tiny_string& str, uint32_t start) const
+{
+	for (auto i = start; i < numChars(); ++i)
+	{
+		auto ch = charAt(i);
+		for (auto ch2 : str)
+		{
+			if (ch == ch2)
+				return i;
+		}
+	}
+
+	return npos;
+}
+
+uint32_t tiny_string::findFirstInv(const tiny_string& str, uint32_t start) const
+{
+	for (auto i = start; i < numChars(); ++i)
+	{
+		auto ch = charAt(i);
+		for (auto ch2 : str)
+		{
+			if (ch != ch2)
+				break;
+		}
+	}
+
+	return npos;
+}
+
+uint32_t tiny_string::findLast(const tiny_string& str, uint32_t start) const
+{
+	for (auto i = std::min(start, numChars() - 1); i != npos; --i)
+	{
+		auto ch = charAt(i);
+		for (auto ch2 : str)
+		{
+			if (ch == ch2)
+				return i;
+		}
+	}
+
+	return npos;
+}
+
+uint32_t tiny_string::findLastInv(const tiny_string& str, uint32_t start) const
+{
+	for (auto i = std::min(start, numChars() - 1); i != npos; --i)
+	{
+		auto ch = charAt(i);
+		for (auto ch2 : str)
+		{
+			if (ch != ch2)
+				return i;
+		}
+	}
+
+	return npos;
+}
+
 void tiny_string::makePrivateCopy(const char* s)
 {
 	resetToStatic();
@@ -1314,6 +1389,26 @@
 	return ret;
 }
 
+bool tiny_string::caselessEquals(const tiny_string& str) const
+{
+	if (numChars() != str.numChars())
+		return false;
+
+	for (size_t i = 0; i < numChars(); ++i)
+	{
+		if (unicharToLower(charAt(i)) != unicharToLower(str[i]))
+			return false;
+	}
+	return true;
+}
+
+bool tiny_string::equalsWithCase(const tiny_string& str, bool caseSensitive) const
+{
+	if (caseSensitive)
+		return *this == str;
+	return caselessEquals(str);
+}
+
 uint32_t tiny_string::bytePosToIndex(uint32_t bytepos) const
 {
 	if (bytepos >= numBytes())
@@ -1457,12 +1552,30 @@
 	getTrimPositions(start,end);
 	return substr_bytes(start,end-start);
 }
+
+tiny_string tiny_string::trimStartMatches(uint32_t ch) const
+{
+	size_t i;
+	for (i = 0; i < numChars() && charAt(i) == ch; ++i);
+
+	return substr(i, UINT32_MAX);
+}
+
+tiny_string tiny_string::trimStartMatches(const tiny_string& str) const
+{
+	size_t i;
+	for (i = 0; i < numChars() && find(str, i) == i; i += str.numChars());
+
+	return substr(i, UINT32_MAX);
+}
+
 tiny_string tiny_string::trimLeft() const
 {
 	uint32_t start,end;
 	getTrimPositions(start,end);
 	return substr_bytes(start,UINT32_MAX);
 }
+
 bool tiny_string::isWhiteSpaceOnly() const
 {
 	uint32_t start,end;
diff -u -r -N lightspark-0.9.0/src/tiny_string.h lightspark-master/src/tiny_string.h
--- lightspark-0.9.0/src/tiny_string.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/src/tiny_string.h	2025-03-05 20:13:02.188865766 +0100
@@ -279,6 +279,8 @@
 		numchars = 1;
 	}
 	
+	bool contains(const tiny_string& str) const;
+	bool contains(uint32_t ch) const;
 	bool startsWith(const tiny_string& str) const;
 	bool endsWith(const tiny_string& str) const;
 	bool startsWith(const char* o) const;
@@ -294,6 +296,10 @@
 	 * returns index of character */
 	uint32_t find(const tiny_string& needle, uint32_t start = 0) const;
 	uint32_t rfind(const tiny_string& needle, uint32_t start = npos) const;
+	uint32_t findFirst(const tiny_string& str, uint32_t start = 0) const;
+	uint32_t findFirstInv(const tiny_string& str, uint32_t start = 0) const;
+	uint32_t findLast(const tiny_string& str, uint32_t start = npos) const;
+	uint32_t findLastInv(const tiny_string& str, uint32_t start = npos) const;
 	// fills line with the text from byteindex up to the next line terminator
 	// upon return byteindex will be set to the index after the next line terminator
 	// returns true if a line terminator was found
@@ -304,6 +310,12 @@
 	tiny_string uppercase() const;
 	/* like strcasecmp(s1.raw_buf(),s2.raw_buf()) but for unicode */
 	int strcasecmp(tiny_string& s2) const;
+	// Compares two strings for equality, ignoring case, done in a way
+	// that matches Flash Player's behaviour.
+	bool caselessEquals(const tiny_string& str) const;
+	// Compares two strings for equality, with the specified case
+	// sensitivity.
+	bool equalsWithCase(const tiny_string& str, bool caseSensitive) const;
 	/* split string at each occurrence of delimiter character */
 	std::list<tiny_string> split(uint32_t delimiter) const;
 	/* Convert from byte offset to UTF-8 character index */
@@ -342,6 +354,12 @@
 	tiny_string toQuotedString() const;
 	// returns string that has whitespace characters removed at begin and end
 	tiny_string removeWhitespace() const;
+	// Returns a string with all repeated instances of `ch` removed from
+	// the beginning of the string.
+	tiny_string trimStartMatches(uint32_t ch) const;
+	// Returns a string with all repeated instances of `str` removed from
+	// the beginning of the string.
+	tiny_string trimStartMatches(const tiny_string& str) const;
 	// returns string that has whitespace characters removed at begin
 	tiny_string trimLeft() const;
 	// returns true if the string is empty or only contains whitespace characters
diff -u -r -N lightspark-0.9.0/tests/test-runner/src/framework/runner.cpp lightspark-master/tests/test-runner/src/framework/runner.cpp
--- lightspark-0.9.0/tests/test-runner/src/framework/runner.cpp	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/tests/test-runner/src/framework/runner.cpp	2025-03-05 20:13:02.217866477 +0100
@@ -91,6 +91,7 @@
 		log,
 		true
 	);
+	sys->exitOnError=SystemState::ERROR_NONE;
 	sys->use_testrunner_date=true;
 	pt = new ParseThread(swfFile, sys->mainClip);
 
@@ -128,12 +129,20 @@
 
 void TestRunner::tick()
 {
+	// ensure that the scripts on the first frame are executed before any events are injected
+	// TODO maybe there is a better way to do that
+	if (!isDone && injector.hasEvents())
+		sys->runTick(frameTime);
+
 	isDone = runEventLoop(eventLoop, sys);
 	isDone |= injector.hasEvents() && injector.endOfInput();
 
 	sys->runTick(frameTime);
 	if (sys->hasError())
-		throw TestRunnerException(sys->getErrorCause());
+	{
+		sys->trace(sys->getErrorCause());
+		//throw TestRunnerException(sys->getErrorCause());
+	}
 
 	if (remainingTicks > 0)
 		remainingTicks--;
diff -u -r -N lightspark-0.9.0/tests/test-runner/src/utils/cereal_overloads.h lightspark-master/tests/test-runner/src/utils/cereal_overloads.h
--- lightspark-0.9.0/tests/test-runner/src/utils/cereal_overloads.h	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/tests/test-runner/src/utils/cereal_overloads.h	2025-03-05 20:13:02.218866502 +0100
@@ -147,7 +147,14 @@
 	{
 		TypeName type;
 		archive(CEREAL_NVP(type));
+#ifdef NDEBUG
 		loadVariant(archive, variant, fromVariantName(variant, type));
+#else
+		// HACK for some reason the string_view "type" is made invalid during fromVariantName() when in debug mode,
+		// so we work on a string copy instead.
+		std::string s(type);
+		loadVariant(archive, variant, fromVariantName(variant, s));
+#endif
 	}
 
 	template<class Archive, typename T>
diff -u -r -N lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_avmplus/as3/Types/Number/pow/test.toml lightspark-master/tests/test-runner/swfs/ruffle/from_avmplus/as3/Types/Number/pow/test.toml
--- lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_avmplus/as3/Types/Number/pow/test.toml	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/tests/test-runner/swfs/ruffle/from_avmplus/as3/Types/Number/pow/test.toml	2025-03-05 20:13:02.557874815 +0100
@@ -1,2 +1 @@
 num_ticks = 1
-known_failure = true
diff -u -r -N lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_avmplus/ecma3/Exceptions/exception_011_rt/test.toml lightspark-master/tests/test-runner/swfs/ruffle/from_avmplus/ecma3/Exceptions/exception_011_rt/test.toml
--- lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_avmplus/ecma3/Exceptions/exception_011_rt/test.toml	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/tests/test-runner/swfs/ruffle/from_avmplus/ecma3/Exceptions/exception_011_rt/test.toml	2025-03-05 20:13:02.614876212 +0100
@@ -1,2 +1 @@
 num_ticks = 1
-known_failure = true
diff -u -r -N lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_shumway/avm2/flash/geom/transform/test.toml lightspark-master/tests/test-runner/swfs/ruffle/from_shumway/avm2/flash/geom/transform/test.toml
--- lightspark-0.9.0/tests/test-runner/swfs/ruffle/from_shumway/avm2/flash/geom/transform/test.toml	2025-02-16 16:25:06.000000000 +0100
+++ lightspark-master/tests/test-runner/swfs/ruffle/from_shumway/avm2/flash/geom/transform/test.toml	2025-03-05 20:13:02.702878370 +0100
@@ -1,2 +1 @@
 num_ticks = 1
-known_failure = true
\ Pas de fin de ligne à la fin du fichier
