From f276d239403d3c097cebf66ae72c0301f703746a Mon Sep 17 00:00:00 2001
From: David Li <davidli.li@linux.alibaba.com>
Date: Sat, 31 Aug 2024 23:49:30 +0800
Subject: [PATCH 177/400] audio: th1520: add spdif driver for XuanTie TH1520
 SoC

1. add 'xuantie,th1520-spdif' dt-bindings
2. add spdif driver code
3. add spdif node in dts
4. enable spdif config

Signed-off-by: David Li <davidli.li@linux.alibaba.com>
Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
---
 .../bindings/sound/xuantie,th1520-i2s.yaml    |   9 +-
 .../bindings/sound/xuantie,th1520-spdif.yaml  |  77 +++
 arch/riscv/boot/dts/thead/th1520.dtsi         |  32 ++
 arch/riscv/configs/th1520_defconfig           |   3 +
 sound/soc/xuantie/Kconfig                     |   9 +
 sound/soc/xuantie/Makefile                    |   2 +
 sound/soc/xuantie/th1520-spdif.c              | 502 ++++++++++++++++++
 sound/soc/xuantie/th1520-spdif.h              | 233 ++++++++
 8 files changed, 862 insertions(+), 5 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/sound/xuantie,th1520-spdif.yaml
 create mode 100644 sound/soc/xuantie/th1520-spdif.c
 create mode 100644 sound/soc/xuantie/th1520-spdif.h

diff --git a/Documentation/devicetree/bindings/sound/xuantie,th1520-i2s.yaml b/Documentation/devicetree/bindings/sound/xuantie,th1520-i2s.yaml
index a9f473e43ddb..b051fef08431 100644
--- a/Documentation/devicetree/bindings/sound/xuantie,th1520-i2s.yaml
+++ b/Documentation/devicetree/bindings/sound/xuantie,th1520-i2s.yaml
@@ -75,18 +75,17 @@ required:
 
 examples:
   - |
-    i2s1: audio_i2s1@0xffcb015000 {
+    i2s1: audio_i2s1@ffcb015000 {
         compatible = "xuantie,th1520-i2s";
         reg = <0xff 0xcb015000 0x0 0x1000>;
         pinctrl-names = "default";
-        interrupts = <175>;
+        interrupts = <175, IRQ_TYPE_LEVEL_HIGH>;
         dmas = <&dmac2 11>, <&dmac2 10>;
         dma-names = "tx", "rx";
         #dma-cells = <1>;
-        clocks = <&audiosys_clk_gate LIGHT_CLKGEN_AUDIO_I2S1>;
+        clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_I2S1>;
         clock-names = "pclk";
-        resets = <&audiosys_rst LIGHT_RESET_AUD_I2S1>;
+        resets = <&audiosys_rst TH1520_RESET_AUD_I2S1>;
         xuantie,audio-cpr-regmap = <&audio_cpr>;
         #sound-dai-cells = <1>;
-        status = "disabled";
     };
diff --git a/Documentation/devicetree/bindings/sound/xuantie,th1520-spdif.yaml b/Documentation/devicetree/bindings/sound/xuantie,th1520-spdif.yaml
new file mode 100644
index 000000000000..00934c46e1cf
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xuantie,th1520-spdif.yaml
@@ -0,0 +1,77 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xuantie,th1520-spdif.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: TH1520 SPDIF transceiver
+
+description:
+  The S/PDIF audio block is a stereo transceiver that allows the
+  processor to receive and transmit digital audio via a coaxial or
+  fibre cable.
+
+maintainers:
+  - nanli.yd <nanli.yd@alibaba-inc.com>
+
+properties:
+  compatible:
+    oneOf:
+      - const: xuantie,th1520-spdif
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    items:
+      - description: clock for SPDIF controller
+
+  clock-names:
+    items:
+      - const: pclk
+
+  dmas:
+    minItems: 1
+    maxItems: 2
+
+  dma-names:
+    oneOf:
+      - const: tx
+      - items:
+          - const: tx
+          - const: rx
+
+  audio-cpr-regmap:
+    description:
+      The phandle of the syscon node for the CPR register.
+
+  "#sound-dai-cells":
+    const: 0
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+  - clock-names
+  - dmas
+  - dma-names
+  - "#sound-dai-cells"
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    spdif: spdif@ffcb018000 {
+      compatible = "xuantie,th1520-spdif";
+      reg = <0xff 0xcb018000 0x0 0x1000>;
+      interrupts = <179 IRQ_TYPE_LEVEL_HIGH>;
+      clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_SPDIF0>;
+      clock-names = "pclk";
+      dmas = <&dmac2 25>, <&dmac2 24>;;
+      dma-names = "tx", "rx";
+      #sound-dai-cells = <0>;
+    };
diff --git a/arch/riscv/boot/dts/thead/th1520.dtsi b/arch/riscv/boot/dts/thead/th1520.dtsi
index 70aa20121206..9e36c3b535c6 100644
--- a/arch/riscv/boot/dts/thead/th1520.dtsi
+++ b/arch/riscv/boot/dts/thead/th1520.dtsi
@@ -768,6 +768,38 @@ tdm_slot8: tdm8@ffcb012000 {
 			status = "disabled";
 		};
 
+		spdif0: spdif@ffcb018000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-spdif";
+			reg = <0xff 0xcb018000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			interrupts = <179 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 25>, <&dmac2 24>;
+			dma-names = "tx", "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_SPDIF0>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_SPDIF0>;
+			status = "disabled";
+		};
+
+		spdif1: spdif@ffcb019000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-spdif";
+			reg = <0xff 0xcb019000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			interrupts = <180 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 27>, <&dmac2 26>;
+			dma-names = "tx", "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_SPDIF1>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_SPDIF1>;
+			status = "disabled";
+		};
+
 		plic: interrupt-controller@ffd8000000 {
 			compatible = "thead,th1520-plic", "thead,c900-plic";
 			reg = <0xff 0xd8000000 0x0 0x01000000>;
diff --git a/arch/riscv/configs/th1520_defconfig b/arch/riscv/configs/th1520_defconfig
index 6c4517f182e6..83cb2f28deb2 100644
--- a/arch/riscv/configs/th1520_defconfig
+++ b/arch/riscv/configs/th1520_defconfig
@@ -157,6 +157,7 @@ CONFIG_SND_USB_AUDIO=m
 CONFIG_SND_SOC=y
 CONFIG_SND_SOC_XUANTIE=y
 CONFIG_SND_SOC_XUANTIE_TH1520_I2S=y
+CONFIG_SND_SOC_XUANTIE_TH1520_I2S_CH8=y
 CONFIG_SND_SOC_XUANTIE_TH1520_HDMI_PCM=y
 CONFIG_SND_SOC_ES7210=y
 CONFIG_SND_SOC_ES8156=y
@@ -269,3 +270,5 @@ CONFIG_RCU_TORTURE_TEST=m
 CONFIG_TEST_BPF=m
 # TH1520 tdm
 CONFIG_SND_SOC_XUANTIE_TH1520_TDM=y
+# TH1520 spdif
+CONFIG_SND_SOC_XUANTIE_TH1520_SPDIF=y
diff --git a/sound/soc/xuantie/Kconfig b/sound/soc/xuantie/Kconfig
index 12b5cbd828cd..ac57efdcbce0 100644
--- a/sound/soc/xuantie/Kconfig
+++ b/sound/soc/xuantie/Kconfig
@@ -42,3 +42,12 @@ config SND_SOC_XUANTIE_TH1520_TDM
         help
           Say Y or M if you want to add support for codecs attached to the
           XuanTie TH1520 interface
+
+config SND_SOC_XUANTIE_TH1520_SPDIF
+        tristate "XuanTie TH1520 audio spdif feature Support"
+	depends on SND_SOC_XUANTIE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default n
+        help
+          Say Y or M if you want to add support for codecs attached to the
+          XuanTie TH1520 interface
diff --git a/sound/soc/xuantie/Makefile b/sound/soc/xuantie/Makefile
index d874185081a0..adadbfec7709 100644
--- a/sound/soc/xuantie/Makefile
+++ b/sound/soc/xuantie/Makefile
@@ -13,3 +13,5 @@ obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_I2S_CH8) += snd-soc-xuantie-th1520-i2s-ch8.o
 obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_HDMI_PCM) += th1520-hdmi-pcm.o
 
 obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_TDM) += th1520-tdm.o
+
+obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_SPDIF) += th1520-spdif.o
diff --git a/sound/soc/xuantie/th1520-spdif.c b/sound/soc/xuantie/th1520-spdif.c
new file mode 100644
index 000000000000..a18a7c52a91a
--- /dev/null
+++ b/sound/soc/xuantie/th1520-spdif.c
@@ -0,0 +1,502 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+ #include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/scatterlist.h>
+#include <linux/sh_dma.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/sh_fsi.h>
+#include "th1520-pcm.h"
+#include "th1520-spdif.h"
+#include <linux/dmaengine.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/mfd/syscon.h>
+
+#define TH1520_RATES SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | SNDRV_PCM_RATE_96000 | SNDRV_PCM_RATE_192000
+#define I2S_DMA_MAXBURST    (4)
+
+static int th1520_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+    struct th1520_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    if (priv) {
+        snd_soc_dai_init_dma_data(dai, &priv->dma_params_tx, &priv->dma_params_rx);
+    } else {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int th1520_spdif_dai_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+    //struct th1520_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    pm_runtime_get_sync(dai->dev);
+
+	return 0;
+}
+
+static void th1520_spdif_snd_txctrl(struct th1520_spdif_priv *priv, char on)
+{
+    regmap_update_bits(priv->regmap, SPDIF_TX_DMA_EN,
+            SPDIF_TDMA_EN_MSK, SPDIF_TDMA_EN_SEL(on));
+    regmap_update_bits(priv->regmap, SPDIF_TX_EN,
+            SPDIF_TXEN_MSK, SPDIF_TXEN_SEL(on));
+    regmap_read(priv->regmap, SPDIF_TX_FIFO_TH, &priv->suspend_tx_fifo_th);
+
+    return;
+}
+
+static void th1520_spdif_snd_rxctrl(struct th1520_spdif_priv *priv, char on)
+{
+
+    regmap_update_bits(priv->regmap, SPDIF_RX_DMA_EN,
+            SPDIF_RDMA_EN_MSK, SPDIF_RDMA_EN_SEL(on));
+    regmap_update_bits(priv->regmap, SPDIF_RX_EN,
+            SPDIF_RXEN_MSK, SPDIF_RXEN_SEL(on));
+
+    return;
+}
+
+static void th1520_spdif_dai_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct th1520_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+	    th1520_spdif_snd_rxctrl(priv, 0);
+    } else {
+        th1520_spdif_snd_txctrl(priv, 0);
+    }
+
+	pm_runtime_put(dai->dev);
+}
+
+static int th1520_spdif_dai_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
+{
+    int ret = 0;
+    struct th1520_spdif_priv *priv = snd_soc_dai_get_drvdata(dai);
+    bool tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+
+    switch(cmd) {
+        case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+            if (tx) {
+                th1520_spdif_snd_txctrl(priv, 1);
+                priv->state |= SPDIF_STATE_TX_RUNNING;
+            }
+            else {
+                th1520_spdif_snd_rxctrl(priv, 1);
+                priv->state |= SPDIF_STATE_RX_RUNNING;
+            }
+            break;
+        case SNDRV_PCM_TRIGGER_STOP:
+        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            if (tx) {
+                dmaengine_terminate_async(snd_dmaengine_pcm_get_chan(substream));  // work around for DMAC stop issue
+                th1520_spdif_snd_txctrl(priv, 0);
+                priv->state &= ~SPDIF_STATE_TX_RUNNING;
+            }
+            else {
+                th1520_spdif_snd_rxctrl(priv, 0);
+                priv->state &= ~SPDIF_STATE_RX_RUNNING;
+            }
+            break;
+        case SNDRV_PCM_TRIGGER_SUSPEND:
+            if (tx) {
+                dmaengine_pause(snd_dmaengine_pcm_get_chan(substream));  // work around for DMAC stop issue
+                th1520_spdif_snd_txctrl(priv, 0);
+            }
+            else
+                th1520_spdif_snd_rxctrl(priv, 0);
+            break;
+        default:
+            return -EINVAL;
+    }
+
+    return ret;
+}
+
+static u32 th1520_special_sample_rates[] = { 44100, 88200 };
+#define AUDIO_DIVCLK0  98304000 //  49152000
+#define AUDIO_DIVCLK1 135475200
+
+static int th1520_spdif_dai_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+    struct th1520_spdif_priv *priv =  snd_soc_dai_get_drvdata(dai);
+    u32 datawidth, chn_num, i;
+    u32 sample_rate = params_rate(params);
+    bool is_divclk1 = false; //audio_divclk1 for 44.1k...etc. audio_divclk0 for 48k....etc
+    u32 src_clk, tx_div;
+
+    switch (params_channels(params)) {
+        case 1:
+            chn_num = SPDIF_TX_DATAMODE_1CH;
+            break;
+        case 2:
+            chn_num = SPDIF_TX_DATAMODE_2CH;
+            break;
+        default:
+            dev_err(priv->dev, "unsupported channel num\n");
+            return -EINVAL;
+    }
+
+    switch (params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            datawidth = SPDIF_TX_DATAMODE_16BIT_PACKED;
+            break;
+        case SNDRV_PCM_FORMAT_S20_LE:
+            datawidth = SPDIF_TX_DATAMODE_20BIT;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            datawidth = SPDIF_TX_DATAMODE_24BIT;
+            break;
+        default:
+            dev_err(priv->dev, "unsupported data format\n");
+            return -EINVAL;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(th1520_special_sample_rates); i++) {
+        if (th1520_special_sample_rates[i] == sample_rate) {
+            is_divclk1 = true;
+            break;
+        }
+    }
+
+    if (is_divclk1 == false) { // audio_divclk0=98304000 for 48k
+        regmap_update_bits(priv->audio_cpr_regmap,
+                        CPR_PERI_CLK_SEL_REG, CPR_SPDIF_SRC_SEL_MSK, CPR_SPDIF_SRC_SEL(2));
+        src_clk = AUDIO_DIVCLK0;
+    } else { // audio_divclk1=135475200 for 44.1k
+        regmap_update_bits(priv->audio_cpr_regmap,
+                        CPR_PERI_CLK_SEL_REG, CPR_SPDIF_SRC_SEL_MSK, CPR_SPDIF_SRC_SEL(1));
+        src_clk = AUDIO_DIVCLK1;
+    }
+
+    if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+        tx_div = src_clk / (sample_rate * (32 * 2) * 2);
+        tx_div = tx_div / 2 - 1;
+
+        regmap_update_bits(priv->regmap, SPDIF_TX_CTL,
+                SPDIF_TX_DIV_MSK, SPDIF_TX_DIV_SEL(tx_div));
+        regmap_update_bits(priv->regmap, SPDIF_TX_CTL,
+                SPDIF_TX_DIV_BYPASS_MSK, SPDIF_TX_DIV_BYPASS_SEL(1));
+        regmap_update_bits(priv->regmap, SPDIF_TX_CTL,
+                SPDIF_TX_CH_SEL_MSK, SPDIF_TX_CH_SEL_SEL(chn_num));
+        regmap_update_bits(priv->regmap, SPDIF_TX_CTL,
+                SPDIF_TX_DATAMODE_MSK, SPDIF_TX_DATAMODE_SEL(datawidth));
+        // Channel Status
+        regmap_update_bits(priv->regmap, SPDIF_TX_CS_A,
+                SPDIF_TX_T_FS_SEL_MSK, SPDIF_TX_T_FS_SEL_SEL(2)); // 2 for 48k
+        regmap_update_bits(priv->regmap, SPDIF_TX_CS_A,
+                SPDIF_TX_T_CH_NUM_MSK, SPDIF_TX_T_CH_NUM_SEL(1)); // Left in 2 channel format
+        regmap_update_bits(priv->regmap, SPDIF_TX_CS_B,
+                SPDIF_TX_T_B_FS_SEL_MSK, SPDIF_TX_T_B_FS_SEL_SEL(2)); // 2 for 48k
+        regmap_update_bits(priv->regmap, SPDIF_TX_CS_B,
+                SPDIF_TX_T_B_CH_NUM_MSK, SPDIF_TX_T_B_CH_NUM_SEL(2)); // Right in 2 channel format
+    } else {
+        regmap_update_bits(priv->regmap, SPDIF_RX_CTL,
+                SPDIF_RX_DIV_MSK, SPDIF_RX_DIV_SEL(0));
+        regmap_update_bits(priv->regmap, SPDIF_RX_CTL,
+                SPDIF_RX_DIV_BYPASS_MSK, SPDIF_RX_DIV_BYPASS_SEL(0)); // spdif_rx_clk = src_clk
+        regmap_update_bits(priv->regmap, SPDIF_RX_CTL,
+                SPDIF_RX_DATAMODE_MSK, SPDIF_RX_DATAMODE_SEL(datawidth));
+        regmap_update_bits(priv->regmap, SPDIF_RX_DMA_TH,
+                SPDIF_RDMA_TH_MSK, SPDIF_RDMA_TH_SEL(8));
+    }
+
+    return 0;
+}
+
+static const struct snd_soc_dai_ops th1520_spdif_dai_ops = {
+    .startup = th1520_spdif_dai_startup,
+    .shutdown = th1520_spdif_dai_shutdown,
+    .trigger = th1520_spdif_dai_trigger,
+    .hw_params = th1520_spdif_dai_hw_params,
+};
+
+static struct snd_soc_dai_driver th1520_spdif_soc_dai = {
+    .playback = {
+        .stream_name = "Playback",
+        .rates = TH1520_RATES,
+        .formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S20_LE | SNDRV_PCM_FMTBIT_S16_LE,
+        .channels_min = 2,
+        .channels_max = 2,
+    },
+    .capture = {
+        .stream_name = "Capture",
+        .rates = TH1520_RATES,
+        .formats = SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S20_LE,
+        .channels_min = 2,
+        .channels_max = 2,
+    },
+    .ops = &th1520_spdif_dai_ops,
+    .symmetric_rate = 1,
+}; 
+
+static const struct snd_soc_component_driver th1520_spdif_soc_component = {
+	.name		= "th1520_spdif",
+};
+
+static const struct regmap_config th1520_spdif_regmap_config = {
+        .reg_bits = 32,
+        .reg_stride = 4,
+        .val_bits = 32,
+        .max_register = SPDIF_RX_USER_B5,
+        .cache_type = REGCACHE_NONE,
+};
+
+static int th1520_spdif_runtime_suspend(struct device *dev)
+{
+    struct th1520_spdif_priv *priv = dev_get_drvdata(dev);
+
+    regmap_update_bits(priv->regmap, SPDIF_EN,
+                SPDIF_SPDIFEN_MSK, SPDIF_SPDIFEN_SEL(0));
+
+    reset_control_assert(priv->rst);
+
+    clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int th1520_spdif_runtime_resume(struct device *dev)
+{
+    struct th1520_spdif_priv *priv = dev_get_drvdata(dev);
+    int ret;
+
+    ret = clk_prepare_enable(priv->clk);
+    if (ret) {
+            dev_err(priv->dev, "clock enable failed %d\n", ret);
+            return ret;
+    }
+    
+    reset_control_deassert(priv->rst);
+
+    regmap_update_bits(priv->regmap, SPDIF_EN,
+        SPDIF_SPDIFEN_MSK, SPDIF_SPDIFEN_SEL(1));
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int th1520_spdif_suspend(struct device *dev)
+{
+    struct th1520_spdif_priv *priv = dev_get_drvdata(dev);
+
+    pm_runtime_get_sync(dev);
+
+    regmap_read(priv->regmap, SPDIF_TX_EN, &priv->suspend_tx_en);
+    regmap_read(priv->regmap, SPDIF_TX_CTL, &priv->suspend_tx_ctl);
+    regmap_read(priv->regmap, SPDIF_TX_DMA_EN, &priv->suspend_tx_dma_en);
+    regmap_read(priv->regmap, SPDIF_RX_EN, &priv->suspend_rx_en);
+    regmap_read(priv->regmap, SPDIF_RX_CTL, &priv->suspend_rx_ctl);
+    regmap_read(priv->regmap, SPDIF_RX_DMA_EN, &priv->suspend_rx_dma_en);
+    regmap_read(priv->audio_cpr_regmap, CPR_PERI_DIV_SEL_REG, &priv->cpr_peri_div_sel);
+    regmap_read(priv->audio_cpr_regmap, CPR_PERI_CTRL_REG, &priv->cpr_peri_ctrl);
+    regmap_read(priv->audio_cpr_regmap, CPR_PERI_CLK_SEL_REG, &priv->cpr_peri_clk_sel);
+
+    regmap_update_bits(priv->regmap, SPDIF_EN,
+                SPDIF_SPDIFEN_MSK, SPDIF_SPDIFEN_SEL(0));
+
+    reset_control_assert(priv->rst);
+
+    pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static int th1520_spdif_resume(struct device *dev)
+{
+    struct th1520_spdif_priv *priv = dev_get_drvdata(dev);
+    int ret;
+
+	pm_runtime_get_sync(dev);
+
+    reset_control_deassert(priv->rst);
+    regmap_write(priv->audio_cpr_regmap, CPR_PERI_DIV_SEL_REG, priv->cpr_peri_div_sel);
+    regmap_write(priv->audio_cpr_regmap, CPR_PERI_CTRL_REG, priv->cpr_peri_ctrl);
+    regmap_write(priv->audio_cpr_regmap, CPR_PERI_CLK_SEL_REG, priv->cpr_peri_clk_sel);
+
+    regmap_update_bits(priv->regmap, SPDIF_EN,
+        SPDIF_SPDIFEN_MSK, SPDIF_SPDIFEN_SEL(1));
+
+    regmap_write(priv->regmap, SPDIF_TX_EN, priv->suspend_tx_en);
+    regmap_write(priv->regmap, SPDIF_TX_CTL, priv->suspend_tx_ctl);
+    regmap_write(priv->regmap, SPDIF_TX_DMA_EN, priv->suspend_tx_dma_en);
+    regmap_write(priv->regmap, SPDIF_RX_EN, priv->suspend_rx_en);
+    regmap_write(priv->regmap, SPDIF_RX_CTL, priv->suspend_rx_ctl);
+    regmap_write(priv->regmap, SPDIF_RX_DMA_EN, priv->suspend_rx_dma_en);
+
+    pm_runtime_put_sync(dev);
+
+    return ret;
+}
+#endif
+
+static const struct of_device_id th1520_spdif_of_match[] = {
+	{ .compatible = "xuantie,th1520-spdif"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, th1520_spdif_of_match);
+
+irqreturn_t spdif_interrupt(int irq, void* dev_id)
+{
+    //struct th1520_spdif_priv* priv = (struct th1520_spdif_priv*)dev_id;
+    return IRQ_HANDLED;
+}
+
+static int th1520_spdif_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    const uint32_t *iprop;
+    struct th1520_spdif_priv *priv;
+    struct resource *res;
+    struct device *dev = &pdev->dev;
+    int ret = 0;
+    struct reset_control *resets;
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct th1520_spdif_priv), GFP_KERNEL);
+    if (!priv) {
+        return -ENOMEM;
+    }
+
+    priv->dev = dev;
+
+    dev_set_drvdata(dev, priv);
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+    priv->clk = devm_clk_get(&pdev->dev, "pclk");
+    if (IS_ERR(priv->clk))
+                return PTR_ERR(priv->clk);
+
+    priv->regs = devm_ioremap_resource(dev, res);
+    if (IS_ERR(priv->regs)) {
+        return PTR_ERR(priv->regs);
+    }
+
+    priv->regmap = devm_regmap_init_mmio(dev, priv->regs,
+                                                &th1520_spdif_regmap_config);
+    if (IS_ERR(priv->regmap)) {
+        dev_err(dev, "Failed to initialise managed register map\n");
+        return PTR_ERR(priv->regmap);
+    }
+
+    priv->audio_cpr_regmap = syscon_regmap_lookup_by_phandle(np, "audio-cpr-regmap");
+    if (IS_ERR(priv->audio_cpr_regmap)) {
+        dev_err(dev, "cannot find regmap for audio cpr register\n");
+        return -EINVAL;
+    }
+
+    resets = devm_reset_control_get_optional_shared(&pdev->dev, NULL);
+    if (IS_ERR(resets)) {
+        ret = PTR_ERR(resets);
+        return ret;
+    }
+    priv->rst = resets;
+
+    reset_control_deassert(priv->rst);
+
+    pm_runtime_enable(&pdev->dev);
+    pm_runtime_resume_and_get(&pdev->dev); // clk gate is enabled by hardware as default register value
+    pm_runtime_put_sync(&pdev->dev);
+
+    //AUDIO_DIV1 set to 1/6. 812.8512MHz / 6 = 135.4752MHz
+    regmap_update_bits(priv->audio_cpr_regmap,
+                            CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV1_SEL_MSK, CPR_AUDIO_DIV1_SEL(5));
+    regmap_update_bits(priv->audio_cpr_regmap,
+                            CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV1_CG_MSK, CPR_AUDIO_DIV1_CG(1));
+    //AUDIO_DIV0 set to 1/3. 294.912MHz / 3 = 98304000Hz
+    regmap_update_bits(priv->audio_cpr_regmap,
+                            CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV0_SEL_MSK, CPR_AUDIO_DIV0_SEL(2)); // 2=98304000 5=49152000
+    regmap_update_bits(priv->audio_cpr_regmap,
+                            CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV0_CG_MSK, CPR_AUDIO_DIV0_CG(1));
+    //enable spdif0/1 sync
+    regmap_update_bits(priv->audio_cpr_regmap,
+                            CPR_PERI_CTRL_REG, CPR_SPDIF_SYNC_MSK, CPR_SPDIF_SYNC_EN);
+
+    priv->irq = platform_get_irq(pdev, 0);
+    if (priv->irq== 0) {
+        dev_err(dev, "could not map IRQ.\n");
+        return -ENXIO;
+    }
+
+    //ret = request_irq(priv->irq , spdif_interrupt,
+    //		IRQF_SHARED|IRQF_TRIGGER_RISING, "AUDIO_TDM_IRQ", (char *)priv);
+    //if (ret) {
+    //	dev_err(dev, "%s[%d]:request irq error!\n", __func__, __LINE__);
+    //	return ret;
+    //}
+
+    priv->dma_params_tx.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    priv->dma_params_rx.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    priv->dma_params_tx.maxburst = I2S_DMA_MAXBURST;
+    priv->dma_params_rx.maxburst = I2S_DMA_MAXBURST;
+    priv->dma_params_tx.addr = res->start + SPDIF_TX_FIFO_DR;
+    priv->dma_params_rx.addr = res->start + SPDIF_RX_FIFO_DR;
+
+    ret = th1520_pcm_dma_init(pdev, TH1520_TDM_DMABUF_SIZE);
+	if (ret) {
+		dev_err(dev, "th1520_pcm_dma_init error\n");
+		return -EIO;
+	}
+
+    ret = devm_snd_soc_register_component(dev, &th1520_spdif_soc_component,
+                        &th1520_spdif_soc_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd component register\n");
+	}
+
+    return ret;
+}
+
+static int th1520_spdif_remove(struct platform_device *pdev)
+{
+    struct th1520_spdif_priv *priv = dev_get_drvdata(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+            th1520_spdif_runtime_suspend(&pdev->dev);
+    clk_disable_unprepare(priv->clk);
+    return 0;
+}
+
+static const struct dev_pm_ops th1520_spdif_pm_ops = {
+    SET_RUNTIME_PM_OPS(th1520_spdif_runtime_suspend, th1520_spdif_runtime_resume, NULL)
+    SET_SYSTEM_SLEEP_PM_OPS(th1520_spdif_suspend,
+				     th1520_spdif_resume)
+};
+
+static struct platform_driver th1520_spdif_driver = {
+    .driver = {
+        .name = "th1520-spdif-audio",
+        .pm = &th1520_spdif_pm_ops,
+        .of_match_table = th1520_spdif_of_match,
+    },
+    .probe = th1520_spdif_probe,
+    .remove = th1520_spdif_remove,
+};
+
+module_platform_driver(th1520_spdif_driver);
+
+MODULE_AUTHOR("nanli.yd <nanli.yd@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie TH1520 spdif driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/xuantie/th1520-spdif.h b/sound/soc/xuantie/th1520-spdif.h
new file mode 100644
index 000000000000..81567fefdc6b
--- /dev/null
+++ b/sound/soc/xuantie/th1520-spdif.h
@@ -0,0 +1,233 @@
+#ifndef _TH1520_SPDIF_H_
+#define _TH1520_SPDIF_H_
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+#include <linux/sh_dma.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "th1520-pcm.h"
+#include <linux/spinlock.h>
+
+#define SPDIF_EN   0x00
+#define SPDIF_TX_EN  0x04
+#define SPDIF_TX_CTL   0x08
+#define SPDIF_TX_CS_A   0x0c
+#define SPDIF_TX_USER_A0   0x10
+#define SPDIF_TX_USER_A1   0x14
+#define SPDIF_TX_USER_A2	0x18
+#define SPDIF_TX_USER_A3	0x1C
+#define SPDIF_TX_USER_A4	0x20
+#define SPDIF_TX_USER_A5	0x24
+#define SPDIF_TX_FIFO_DR	0x28
+#define SPDIF_TX_FIFO_TH	0x2C
+#define SPDIF_TX_FIFO_DL	0x30
+#define SPDIF_TX_DMA_EN	0x34
+#define SPDIF_TX_DMA_TH	0x38
+#define SPDIF_SR	0x3C
+#define SPDIF_IMR	0x40
+#define SPDIF_ISR	0x44
+#define SPDIF_RISR	0x48
+#define SPDIF_ICR	0x4C
+#define SPDIF_RX_EN	0x50
+#define SPDIF_RX_CTL	0x54
+#define SPDIF_RX_CS_A	0x58
+#define SPDIF_RX_USER_A0	0x5C
+#define SPDIF_RX_USER_A1	0x60
+#define SPDIF_RX_USER_A2	0x64
+#define SPDIF_RX_USER_A3    0x68
+#define SPDIF_RX_USER_A4    0x6C
+#define SPDIF_RX_USER_A5    0x70
+#define SPDIF_RX_FIFO_DR    0x74
+#define SPDIF_RX_FIFO_TH    0x78
+#define SPDIF_RX_FIFO_DL    0x7C
+#define SPDIF_RX_DMA_EN     0x80
+#define SPDIF_RX_DMA_TH     0x84
+#define SPDIF_TX_CS_B   0x88
+#define SPDIF_TX_USER_B0    0x8C
+#define SPDIF_TX_USER_B1    0x90
+#define SPDIF_TX_USER_B2    0x94
+#define SPDIF_TX_USER_B3    0x98
+#define SPDIF_TX_USER_B4    0x9C
+#define SPDIF_TX_USER_B5    0xa0
+#define SPDIF_RX_CS_B   0xa4
+#define SPDIF_RX_USER_B0    0xa8
+#define SPDIF_RX_USER_B1    0xaC
+#define SPDIF_RX_USER_B2    0xb0
+#define SPDIF_RX_USER_B3    0xb4
+#define SPDIF_RX_USER_B4    0xb8
+#define SPDIF_RX_USER_B5    0xbC
+
+/* SPDIF_EN */
+#define SPDIF_SPDIFEN_POS                             (0U) 
+#define SPDIF_SPDIFEN_MSK                         (0x1U << SPDIF_SPDIFEN_POS)
+#define SPDIF_SPDIFEN_SEL(X)                  (X << SPDIF_SPDIFEN_POS)
+
+/* SPDIF_TX_EN */
+#define SPDIF_TXEN_POS                             (0U) 
+#define SPDIF_TXEN_MSK                         (0x1U << SPDIF_TXEN_POS)
+#define SPDIF_TXEN_SEL(X)                  (X << SPDIF_TXEN_POS)
+
+/* SPDIF_TX_CTL */
+#define SPDIF_TX_DIV_POS                             (9U) 
+#define SPDIF_TX_DIV_MSK                         (0x7FU << SPDIF_TX_DIV_POS)
+#define SPDIF_TX_DIV_SEL(X)                  (X << SPDIF_TX_DIV_POS)
+#define SPDIF_TX_DIV_BYPASS_POS                             (8U) 
+#define SPDIF_TX_DIV_BYPASS_MSK                         (0x1U << SPDIF_TX_DIV_BYPASS_POS)
+#define SPDIF_TX_DIV_BYPASS_SEL(X)                  (X << SPDIF_TX_DIV_BYPASS_POS)
+#define SPDIF_TX_CH_SEL_POS                             (4U) 
+#define SPDIF_TX_CH_SEL_MSK                         (0x1U << SPDIF_TX_CH_SEL_POS)
+#define SPDIF_TX_CH_SEL_SEL(X)                  (X << SPDIF_TX_CH_SEL_POS)
+#define SPDIF_TX_DATAMODE_POS                             (0U) 
+#define SPDIF_TX_DATAMODE_MSK                         (0x3U << SPDIF_TX_DATAMODE_POS)
+#define SPDIF_TX_DATAMODE_SEL(X)                  (X << SPDIF_TX_DATAMODE_POS)
+
+#define SPDIF_TX_DATAMODE_2CH       0x0
+#define SPDIF_TX_DATAMODE_1CH       0x1
+#define SPDIF_TX_DATAMODE_16BIT_PACKED 0x3
+#define SPDIF_TX_DATAMODE_16BIT 0x2
+#define SPDIF_TX_DATAMODE_20BIT    0x1
+#define SPDIF_TX_DATAMODE_24BIT 0x0
+
+/* SPDIF_TX_CS_A */
+#define SPDIF_TX_T_FS_SEL_POS           (24U)
+#define SPDIF_TX_T_FS_SEL_MSK                         (0xFU << SPDIF_TX_T_FS_SEL_POS)
+#define SPDIF_TX_T_FS_SEL_SEL(X)                  (X << SPDIF_TX_T_FS_SEL_POS)
+#define SPDIF_TX_T_CH_NUM_POS           (20U)
+#define SPDIF_TX_T_CH_NUM_MSK                         (0xFU << SPDIF_TX_T_CH_NUM_POS)
+#define SPDIF_TX_T_CH_NUM_SEL(X)                  (X << SPDIF_TX_T_CH_NUM_POS)
+
+/* SPDIF_RX_DMA_TH */
+#define SPDIF_RDMA_TH_POS           (0U)
+#define SPDIF_RDMA_TH_MSK                         (0xFU << SPDIF_RDMA_TH_POS)
+#define SPDIF_RDMA_TH_SEL(X)                  (X << SPDIF_RDMA_TH_POS)
+
+/* SPDIF_TX_CS_B */
+#define SPDIF_TX_T_B_FS_SEL_POS           (24U)
+#define SPDIF_TX_T_B_FS_SEL_MSK                         (0xFU << SPDIF_TX_T_B_FS_SEL_POS)
+#define SPDIF_TX_T_B_FS_SEL_SEL(X)                  (X << SPDIF_TX_T_B_FS_SEL_POS)
+#define SPDIF_TX_T_B_CH_NUM_POS           (20U)
+#define SPDIF_TX_T_B_CH_NUM_MSK                         (0xFU << SPDIF_TX_T_B_CH_NUM_POS)
+#define SPDIF_TX_T_B_CH_NUM_SEL(X)                  (X << SPDIF_TX_T_B_CH_NUM_POS)
+
+/* SPDIF_TX_DMA_EN */
+#define SPDIF_TDMA_EN_POS                             (0U) 
+#define SPDIF_TDMA_EN_MSK                         (0x1U << SPDIF_TDMA_EN_POS)
+#define SPDIF_TDMA_EN_SEL(X)                  (X << SPDIF_TDMA_EN_POS)
+
+/* SPDIF_RX_EN */
+#define SPDIF_RXEN_POS                             (0U) 
+#define SPDIF_RXEN_MSK                         (0x1U << SPDIF_RXEN_POS)
+#define SPDIF_RXEN_SEL(X)                  (X << SPDIF_RXEN_POS)
+
+/* SPDIF_RX_CTL */
+#define SPDIF_RX_DIV_POS                             (13U) 
+#define SPDIF_RX_DIV_MSK                         (0x7FU << SPDIF_RX_DIV_POS)
+#define SPDIF_RX_DIV_SEL(X)                  (X << SPDIF_RX_DIV_POS)
+#define SPDIF_RX_DIV_BYPASS_POS                             (12U) 
+#define SPDIF_RX_DIV_BYPASS_MSK                         (0x1U << SPDIF_RX_DIV_BYPASS_POS)
+#define SPDIF_RX_DIV_BYPASS_SEL(X)                  (X << SPDIF_RX_DIV_BYPASS_POS)
+#define SPDIF_RX_VALID_EN_POS                             (8U) 
+#define SPDIF_RX_VALID_EN_MSK                         (0x1U << SPDIF_RX_VALID_EN_POS)
+#define SPDIF_RX_VALID_EN_SEL(X)                  (X << SPDIF_RX_VALID_EN_POS)
+#define SPDIF_RX_PARITY_EN_POS                             (4U) 
+#define SPDIF_RX_PARITY_EN_MSK                         (0x1U << SPDIF_RX_PARITY_EN_POS)
+#define SPDIF_RX_PARITY_EN_SEL(X)                  (X << SPDIF_RX_PARITY_EN_POS)
+#define SPDIF_RX_DATAMODE_POS                             (0U) 
+#define SPDIF_RX_DATAMODE_MSK                         (0x3U << SPDIF_RX_DATAMODE_POS)
+#define SPDIF_RX_DATAMODE_SEL(X)                  (X << SPDIF_RX_DATAMODE_POS)
+
+/* SPDIF_RX_DMA_EN */
+#define SPDIF_RDMA_EN_POS                             (0U) 
+#define SPDIF_RDMA_EN_MSK                         (0x1U << SPDIF_RDMA_EN_POS)
+#define SPDIF_RDMA_EN_SEL(X)                  (X << SPDIF_RDMA_EN_POS)
+
+
+#define CPR_PERI_DIV_SEL_REG  0x004 /*audio sys clock div Register*/
+#define CPR_PERI_CLK_SEL_REG  0x008 /*audio sys clock selection Register*/
+#define CPR_PERI_CTRL_REG  0x00C /*Peripheral control signal configuration register*/
+#define CPR_IP_CG_REG   0x010 /* ip clock gate register */
+#define CPR_IP_RST_REG  0x014
+
+/* AUDIO SYS DIV SEL REG, offset: 0x4 */
+#define CPR_AUDIO_DIV1_CG_POS                     (17U)
+#define CPR_AUDIO_DIV1_CG_MSK                     (0x1U << CPR_AUDIO_DIV1_CG_POS)
+#define CPR_AUDIO_DIV1_CG(X)                      (X << CPR_AUDIO_DIV1_CG_POS)
+#define CPR_AUDIO_DIV1_SEL_POS                     (12U)
+#define CPR_AUDIO_DIV1_SEL_MSK                     (0x1FU << CPR_AUDIO_DIV1_SEL_POS)
+#define CPR_AUDIO_DIV1_SEL(X)                      (X << CPR_AUDIO_DIV1_SEL_POS)
+#define CPR_AUDIO_DIV0_CG_POS                     (9U)
+#define CPR_AUDIO_DIV0_CG_MSK                     (0x1U << CPR_AUDIO_DIV0_CG_POS)
+#define CPR_AUDIO_DIV0_CG(X)                      (X << CPR_AUDIO_DIV0_CG_POS)
+#define CPR_AUDIO_DIV0_SEL_POS                  (4U)
+#define CPR_AUDIO_DIV0_SEL_MSK               (0x1FU << CPR_AUDIO_DIV0_SEL_POS)
+#define CPR_AUDIO_DIV0_SEL(X)                      (X << CPR_AUDIO_DIV0_SEL_POS)
+/* CPR_PERI_CLK_SEL_REG  0x008 */
+#define CPR_SPDIF_SRC_SEL_POS                     (24U)
+#define CPR_SPDIF_SRC_SEL_MSK                     (0x3U << CPR_SPDIF_SRC_SEL_POS)
+#define CPR_SPDIF_SRC_SEL(X)                          (X << CPR_SPDIF_SRC_SEL_POS)
+/* PERI_CTRL_REG, Offset: 0xC */
+#define CPR_SPDIF_SYNC_POS                (14U)
+#define CPR_SPDIF_SYNC_MSK                (0x1U << CPR_SPDIF_SYNC_POS)
+#define CPR_SPDIF_SYNC_EN                 (CPR_SPDIF_SYNC_MSK)
+/* CPR_IP_CG_REG   0x010 */
+#define CPR_SPDIF0_CG_SEL_POS                      (23U)
+#define CPR_SPDIF0_CG_SEL_MSK                       (0x1U << CPR_SPDIF0_CG_SEL_POS)
+#define CPR_SPDIF0_CG_SEL(X)                            (X << CPR_SPDIF0_CG_SEL_POS)
+#define CPR_SPDIF1_CG_SEL_POS                      (24U)
+#define CPR_SPDIF1_CG_SEL_MSK                       (0x1U << CPR_SPDIF1_CG_SEL_POS)
+#define CPR_SPDIF1_CG_SEL(X)                            (X << CPR_SPDIF1_CG_SEL_POS)
+/* CPR_IP_RST_REG */
+#define CPR_SPDIF0_SRST_N_SEL_POS                      (23U)
+#define CPR_SPDIF0_SRST_N_SEL_MSK                       (0x1U << CPR_SPDIF0_SRST_N_SEL_POS)
+#define CPR_SPDIF0_SRST_N_SEL(X)                            (X << CPR_SPDIF0_SRST_N_SEL_POS)
+#define CPR_SPDIF1_SRST_N_SEL_POS                      (24U)
+#define CPR_SPDIF1_SRST_N_SEL_MSK                       (0x1U << CPR_SPDIF1_SRST_N_SEL_POS)
+#define CPR_SPDIF1_SRST_N_SEL(X)                            (X << CPR_SPDIF1_SRST_N_SEL_POS)
+
+#define TH1520_TDM_DMABUF_SIZE     (64 * 1024)
+#define SPDIF_STATE_IDLE				0
+#define SPDIF_STATE_TX_RUNNING	    1
+#define SPDIF_STATE_RX_RUNNING	    2
+
+struct th1520_spdif_priv {
+    void __iomem *regs;
+    struct regmap *regmap;
+    struct regmap *audio_cpr_regmap;
+    struct reset_control *rst;
+    struct clk *clk;
+    struct snd_dmaengine_dai_dma_data dma_params_tx;
+    struct snd_dmaengine_dai_dma_data dma_params_rx;
+    struct device *dev; 
+    unsigned int irq;
+    u32 suspend_tx_en;
+    u32 suspend_tx_ctl;
+    u32 suspend_tx_fifo_th;
+    u32 suspend_tx_fifo_dl;
+    u32 suspend_tx_dma_en;
+    u32 suspend_tx_dma_th;
+    u32 suspend_spdif_imr;
+    u32 suspend_rx_en;
+    u32 suspend_rx_ctl;
+    u32 suspend_rx_fifo_th;
+    u32 suspend_rx_fifo_dl;
+    u32 suspend_rx_dma_en;
+    u32 suspend_rx_dma_th;
+    u32 cpr_peri_div_sel;
+    u32 cpr_peri_ctrl;
+    u32 cpr_peri_clk_sel;
+    u32 state;
+};
+
+
+#endif
-- 
2.43.0

