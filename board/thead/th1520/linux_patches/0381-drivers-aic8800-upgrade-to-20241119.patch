From c1707d8d7fb55ebbb02e06ac44a899321840602b Mon Sep 17 00:00:00 2001
From: NekoRouter <nekorouter@outlook.com>
Date: Mon, 7 Jul 2025 18:06:30 +0800
Subject: [PATCH 381/400] drivers: aic8800: upgrade to 20241119

Update aic8800 driver to 20241119 (aic8800d_linux_sdk_V4.0_2024_1119_06da8476).

Signed-off-by: NekoRouter <nekorouter@outlook.com>
---
 drivers/net/wireless/aic8800/Makefile         |    5 +-
 .../net/wireless/aic8800/aic8800_bsp/Makefile |   17 +-
 .../aic8800/aic8800_bsp/aic8800d80_compat.c   |   17 +-
 .../aic8800/aic8800_bsp/aic8800dc_compat.c    |  378 +++-
 .../aic8800/aic8800_bsp/aic8800dc_compat.h    |    4 +
 .../aic8800/aic8800_bsp/aic_bsp_driver.c      |  174 +-
 .../aic8800/aic8800_bsp/aic_bsp_driver.h      |   39 +-
 .../aic8800/aic8800_bsp/aic_bsp_export.h      |    8 +-
 .../aic8800/aic8800_bsp/aic_bsp_main.c        |   71 +-
 .../wireless/aic8800/aic8800_bsp/aicsdio.c    |  140 +-
 .../wireless/aic8800/aic8800_bsp/aicsdio.h    |    3 +-
 .../aic8800/aic8800_bsp/rwnx_version_gen.h    |    2 +-
 .../wireless/aic8800/aic8800_fdrv/Makefile    |   46 +-
 .../aic8800/aic8800_fdrv/aic_bsp_export.h     |    8 +-
 .../aic8800/aic8800_fdrv/aic_priv_cmd.c       | 1920 +++++++++++++++++
 .../aic8800/aic8800_fdrv/aic_priv_cmd.h       |   33 +
 .../aic8800/aic8800_fdrv/aic_vendor.c         |  340 ++-
 .../aic8800/aic8800_fdrv/aic_vendor.h         |   17 +
 .../aic8800_fdrv/aicwf_compat_8800d80.c       |  114 +-
 .../aic8800_fdrv/aicwf_compat_8800d80.h       |    6 +
 .../aic8800_fdrv/aicwf_compat_8800dc.c        |  143 ++
 .../aic8800/aic8800_fdrv/aicwf_sdio.c         |  525 ++++-
 .../aic8800/aic8800_fdrv/aicwf_sdio.h         |   42 +-
 .../aic8800/aic8800_fdrv/aicwf_tcp_ack.c      |   11 +-
 .../aic8800/aic8800_fdrv/aicwf_txrxif.c       |    2 -
 .../wireless/aic8800/aic8800_fdrv/hal_desc.h  |   30 +
 .../wireless/aic8800/aic8800_fdrv/lmac_msg.h  |  136 +-
 .../net/wireless/aic8800/aic8800_fdrv/regdb.c |    1 +
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.c |   39 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_cmds.h |    2 +-
 .../aic8800/aic8800_fdrv/rwnx_compat.h        |    5 +-
 .../aic8800/aic8800_fdrv/rwnx_debugfs.c       |   22 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_defs.h |   19 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.c | 1794 ++-------------
 .../wireless/aic8800/aic8800_fdrv/rwnx_main.h |   14 -
 .../aic8800/aic8800_fdrv/rwnx_mod_params.c    |  103 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_rx.c        |  184 +-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.c        |  516 ++++-
 .../aic8800/aic8800_fdrv/rwnx_msg_tx.h        |    9 +-
 .../aic8800/aic8800_fdrv/rwnx_platform.c      | 1038 ++++++++-
 .../aic8800/aic8800_fdrv/rwnx_platform.h      |   10 +
 .../aic8800/aic8800_fdrv/rwnx_radar.c         |    7 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.c   |  197 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_rx.h   |    8 +-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.c   |  398 +++-
 .../wireless/aic8800/aic8800_fdrv/rwnx_tx.h   |    8 +
 .../aic8800/aic8800_fdrv/rwnx_version_gen.h   |    2 +-
 .../aic8800/aic8800_fdrv/rwnx_wakelock.c      |    4 +
 48 files changed, 6511 insertions(+), 2100 deletions(-)
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
 create mode 100644 drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h

diff --git a/drivers/net/wireless/aic8800/Makefile b/drivers/net/wireless/aic8800/Makefile
index e8df07b36bcf..570ef3580990 100644
--- a/drivers/net/wireless/aic8800/Makefile
+++ b/drivers/net/wireless/aic8800/Makefile
@@ -10,7 +10,7 @@ MAKEFLAGS +=-j$(shell nproc)
 
 ########## config option ##########
 export CONFIG_USE_FW_REQUEST = n
-export CONFIG_PREALLOC_RX_SKB = n
+export CONFIG_PREALLOC_RX_SKB = y
 export CONFIG_PREALLOC_TXQ = y
 export CONFIG_OOB = n
 export CONFIG_GPIO_WAKEUP = n
@@ -62,7 +62,8 @@ KDIR =  $(LINUX_DIR)
 PWD   = $(shell pwd)
 KVER = $(shell uname -r)
 #MODDESTDIR = /lib/modules/$(KVER)/kernel/drivers/net/wireless/aic8800
-#ARCH = x86_64
+#SUBARCH = $(shell uname -m | sed -e s/i.86/i386/ -e s/armv.l/arm/ -e s/aarch64/arm64/)
+#ARCH ?= $(SUBARCH)
 #CROSS_COMPILE ?=
 endif
 ###########################################
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/Makefile b/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
index ba8a4afec7be..803a8ee276c4 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/Makefile
@@ -25,10 +25,20 @@ CONFIG_OOB ?= n
 CONFIG_PREALLOC_TXQ = y
 CONFIG_DPD = y
 CONFIG_FORCE_DPD_CALIB = y
+CONFIG_LOFT_CALIB = n
+CONFIG_EXT_FEM_8800DCDW = n
 CONFIG_RESV_MEM_SUPPORT ?= y
-CONFIG_AMSDU_RX = n
+CONFIG_AMSDU_RX = y
 CONFIG_IRQ_FALL ?= n
 CONFIG_SDIO_BT = n
+CONFIG_RADAR_OR_IR_DETECT =n
+CONFIG_FOR_IPCAM = n
+
+ifeq ($(CONFIG_EXT_FEM_8800DCDW), y)
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
+CONFIG_LOFT_CALIB = y
+endif
 
 ccflags-$(CONFIG_GPIO_WAKEUP) += -DCONFIG_GPIO_WAKEUP
 ccflags-$(CONFIG_M2D_OTA_AUTO_SUPPORT) += -DCONFIG_M2D_OTA_AUTO_SUPPORT
@@ -43,10 +53,15 @@ ccflags-$(CONFIG_OOB) += -DCONFIG_OOB
 ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
 ccflags-$(CONFIG_DPD)  += -DCONFIG_DPD
 ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
+ccflags-$(CONFIG_LOFT_CALIB) += -DCONFIG_LOFT_CALIB
+ccflags-$(CONFIG_EXT_FEM_8800DCDW) += -DCONFIG_EXT_FEM_8800DCDW
 ccflags-$(CONFIG_RESV_MEM_SUPPORT) += -DCONFIG_RESV_MEM_SUPPORT
 ccflags-$(CONFIG_AMSDU_RX) += -DCONFIG_AMSDU_RX
 ccflags-$(CONFIG_IRQ_FALL) += -DCONFIG_IRQ_FALL
 ccflags-$(CONFIG_SDIO_BT) += -DCONFIG_SDIO_BT
+ccflags-$(CONFIG_RADAR_OR_IR_DETECT) += -DCONFIG_RADAR_OR_IR_DETECT
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
+
 
 obj-m := $(MODULE_NAME).o
 $(MODULE_NAME)-y := \
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
index ae94ac146141..bd70bf65ab98 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800d80_compat.c
@@ -47,13 +47,15 @@ u32 adaptivity_patch_tbl_8800d80[][2] = {
 	{0x0168, 0x00010000}, //tx_adaptivity_en
 };
 
+#define USER_PWROFST_COVER_CALIB_FLAG	0x01U
 #define USER_CHAN_MAX_TXPWR_EN_FLAG     (0x01U << 1)
 #define USER_TX_USE_ANA_F_FLAG          (0x01U << 2)
 
-#define CFG_USER_CHAN_MAX_TXPWR_EN  0
+#define CFG_PWROFST_COVER_CALIB     1
+#define CFG_USER_CHAN_MAX_TXPWR_EN  1
 #define CFG_USER_TX_USE_ANA_F       0
 
-#define CFG_USER_EXT_FLAGS_EN   (CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
+#define CFG_USER_EXT_FLAGS_EN   (CFG_PWROFST_COVER_CALIB || CFG_USER_CHAN_MAX_TXPWR_EN || CFG_USER_TX_USE_ANA_F)
 
 u32 patch_tbl_8800d80[][2] = {
 	#ifdef USE_5G
@@ -62,14 +64,17 @@ u32 patch_tbl_8800d80[][2] = {
 	{0x00b4, 0xf3010000},
 	#endif
 #if defined(CONFIG_AMSDU_RX)
-        {0x170, 0x0100000a}
+        {0x170, 0x0100000a},
 #endif
 #ifdef CONFIG_IRQ_FALL
 	{0x00000170, 0x0000010a}, //irqf
 #endif
 
     #if CFG_USER_EXT_FLAGS_EN
-    {0x0188, 0x00000001
+    {0x0188, 0x00000000
+	#if CFG_PWROFST_COVER_CALIB
+	| USER_PWROFST_COVER_CALIB_FLAG
+	#endif
         #if CFG_USER_CHAN_MAX_TXPWR_EN
         | USER_CHAN_MAX_TXPWR_EN_FLAG
         #endif
@@ -78,6 +83,10 @@ u32 patch_tbl_8800d80[][2] = {
         #endif
     }, // user_ext_flags
     #endif
+
+#ifdef CONFIG_RADAR_OR_IR_DETECT
+	{0x019c, 0x00000100}, //enable radar detect
+#endif
 };
 
 #ifdef CONFIG_OOB
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
index 796a321681e6..8efd2b81e194 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.c
@@ -1323,7 +1323,7 @@ uint32_t agc_cfg_ram[] = {
     0x00000000
 };
 
-
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 uint32_t txgain_map[96] =  {
 #ifdef CONFIG_FPGA_VERIFICATION
     0x20c0c971,
@@ -1503,9 +1503,9 @@ uint32_t txgain_map[96] =  {
     0x00ffcd70,
     0x00ffcd80,
     0x00ffcd90,
-    0x00ffce80,
-    0x00ffce93,
-    0x00ffcf90,
+    0x00ffcf68,
+    0x00ffcf75,
+    0x00ffcf83,
     0x00ffc080,
     0x00ffc090,
     0x00ffc180,
@@ -1604,8 +1604,8 @@ const uint32_t txgain_map_h[96] =
     0xffcc6b, //15
     0xffcc79, //16
     0xffcd72, //17
-    0xffce60, //18
-    0xffce72, //19
+    0xffcf5b, //18
+    0xffcf66, //19
     0xffcf72, //20
     0xffcf80, //21
     0xffcf90, //22
@@ -1628,6 +1628,213 @@ const uint32_t txgain_map_h[96] =
     0xffc86b, //7
 };
 
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+const uint32_t txgain_map_femkct[96] =
+{
+    //11b
+    0x00ffd780,//15
+    0x00ffd872,//16
+    0x00ffd880,//17
+    0x00ffd972,//18
+    0x00ffd980,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd36d,//6
+    0x00ffd379,//7
+    0x00ffd46d,//8
+    0x00ffd479,//9
+    0x00ffd572,//10
+    0x00ffd580,//11
+    0x00ffd672,//12
+    0x00ffd680,//13
+    0x00ffd772,//14
+    //high
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+    //low
+    0x00ffc872,//11
+    0x00ffc880,//12
+    0x00ffc972,//13
+    0x00ffc980,//14
+    0x00ffca72,//15
+    0x00ffca80,//16
+    0x00ffcb72,//17
+    0x00ffcb80,//18
+    0x00ffcc72,//19
+    0x00ffcc80,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//26
+    0x00ffcf80,//27
+    0x00ffc072,//-5
+    0x00ffc080,//-4
+    0x00ffc172,//-3
+    0x00ffc180,//-2
+    0x00ffc272,//-1
+    0x00ffc280,//0
+    0x00ffc372,//1
+    0x00ffc380,//2
+    0x00ffc472,//3
+    0x00ffc480,//4
+    0x00ffc572,//5
+    0x00ffc580,//6
+    0x00ffc672,//7
+    0x00ffc680,//8
+    0x00ffc772,//9
+    0x00ffc780,//10
+};
+
+const uint32_t txgain_map_femkct_h[96] =
+{
+    //11b
+    0x00ffd872,//15
+    0x00ffd880,//16
+    0x00ffd972,//17
+    0x00ffd980,//18
+    0x00ffd990,//19
+    0x00ffda72,//20
+    0x00ffda80,//21
+    0x00ffdb72,//22
+    0x00ffdb80,//23
+    0x00ffdc72,//24
+    0x00ffdc80,//25
+    0x00ffdd72,//26
+    0x00ffdd80,//27
+    0x00ffde72,//28
+    0x00ffde80,//29
+    0x00ffdf72,//30
+    0x00ffd072,//-1
+    0x00ffd072,//0
+    0x00ffd080,//1
+    0x00ffd172,//2
+    0x00ffd180,//3
+    0x00ffd272,//4
+    0x00ffd280,//5
+    0x00ffd379,//6
+    0x00ffd46d,//7
+    0x00ffd479,//8
+    0x00ffd572,//9
+    0x00ffd580,//10
+    0x00ffd672,//11
+    0x00ffd680,//12
+    0x00ffd772,//13
+    0x00ffd780,//14
+    //high
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+    //low
+    0x00ffc880,//11
+    0x00ffc972,//12
+    0x00ffc980,//13
+    0x00ffca72,//14
+    0x00ffca80,//15
+    0x00ffcb72,//16
+    0x00ffcb80,//17
+    0x00ffcc72,//18
+    0x00ffcc80,//19
+    0x00ffcc90,//20
+    0x00ffcd72,//21
+    0x00ffcd80,//22
+    0x00ffce72,//23
+    0x00ffce80,//24
+    0x00ffcf72,//25
+    0x00ffcf80,//26
+    0x00ffc080,//-5
+    0x00ffc172,//-4
+    0x00ffc180,//-3
+    0x00ffc272,//-2
+    0x00ffc280,//-1
+    0x00ffc372,//0
+    0x00ffc380,//1
+    0x00ffc472,//2
+    0x00ffc480,//3
+    0x00ffc572,//4
+    0x00ffc580,//5
+    0x00ffc672,//6
+    0x00ffc680,//7
+    0x00ffc772,//8
+    0x00ffc780,//9
+    0x00ffc872,//10
+};
+#endif
 
 u32 jump_tbl[][2] =
 {
@@ -1689,6 +1896,16 @@ u32 patch_tbl_rf_func[][2] =
     {0x00110bf0, 0x00180001},
 };
 
+
+//adap test
+u32 adaptivity_patch_tbl_8800dc[][2] = {
+    {0x000C, 0x0000320A}, //linkloss_thd
+    {0x009C, 0x00000000}, //ac_param_conf
+    {0x0128, 0xF6140001}, //tx_adaptivity_en
+};
+//adap test
+
+
 static u8 chip_id = 0;
 #define CHIP_ID_H_MASK  0xC0
 #define IS_CHIP_ID_H()  ((chip_id & CHIP_ID_H_MASK) == CHIP_ID_H_MASK)
@@ -1698,7 +1915,7 @@ int set_bbpll_config(struct aic_sdio_dev *rwnx_hw){
 //    {0x40505010, 0x7C301010},//bbpll
 	int ret = 0;
 	struct dbg_mem_read_cfm rd_mem_addr_cfm;
-	
+
 	//Read crystal provided by CPU or not.
     ret = rwnx_send_dbg_mem_read_req(rwnx_hw, 0x40500148, &rd_mem_addr_cfm);
     if (ret) {
@@ -1707,7 +1924,7 @@ int set_bbpll_config(struct aic_sdio_dev *rwnx_hw){
     }
 
 	AICWFDBG(LOGDEBUG, "%s rd_mem_addr_cfm.memdata:%x \r\n", __func__, rd_mem_addr_cfm.memdata);
-	
+
 	if(!(rd_mem_addr_cfm.memdata & 0x01)){
 		AICWFDBG(LOGINFO, "%s Crystal not provided by CPU \r\n", __func__);
 		return 0;
@@ -1724,11 +1941,11 @@ int set_bbpll_config(struct aic_sdio_dev *rwnx_hw){
 			AICWFDBG(LOGERROR, "%s Not need to set \r\n", __func__);
 			return 0;
 		}else{
-			rd_mem_addr_cfm.memdata |= ((0x1 << 29) | (0x1 << 30)); 
+			rd_mem_addr_cfm.memdata |= ((0x1 << 29) | (0x1 << 30));
 			rd_mem_addr_cfm.memdata &= (~(0x1 << 31));
 			rwnx_send_dbg_mem_write_req(rwnx_hw, 0x40505010, rd_mem_addr_cfm.memdata);
 		}
-	}	
+	}
 	return 0;
 }
 //Crystal provided by CPU (end)
@@ -1865,6 +2082,7 @@ void system_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 
 }
 
+extern int adap_test;
 
 void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 {
@@ -1887,6 +2105,11 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
         u32 jump_tbl_size = 0;
         u32 patch_tbl_func_num = 0;
 
+	//adap test
+	int adap_patch_num = 0;
+	//adap test
+
+
         array2_tbl_t jump_tbl_base = NULL;
         array2_tbl_t patch_tbl_func_base = NULL;
 		array2_tbl_t patch_tbl_wifisetting_8800dc_base = NULL;
@@ -1944,6 +2167,19 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 			}
 		}
 
+//adap test
+		if(adap_test){
+            AICWFDBG(LOGINFO, "%s for adaptivity test \r\n", __func__);
+			adap_patch_num = sizeof(adaptivity_patch_tbl_8800dc)/sizeof(u32)/2;
+			for(cnt = 0; cnt < adap_patch_num; cnt++)
+			{
+				if((ret = rwnx_send_dbg_mem_write_req(rwnx_hw, wifisetting_cfg_addr + adaptivity_patch_tbl_8800dc[cnt][0], adaptivity_patch_tbl_8800dc[cnt][1]))) {
+					AICWFDBG(LOGERROR, "%x write fail\n", wifisetting_cfg_addr + adaptivity_patch_tbl_8800dc[cnt][0]);
+				}
+			}
+		}
+//adap test
+
         if (ldpc_cfg_size > 512) {// > 0.5KB data
             for (i = 0; i < (ldpc_cfg_size - 512); i += 512) {//each time write 0.5KB
                 ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ldpc_cfg_addr + i, 512, ldpc_cfg_ram + i / 4);
@@ -1980,11 +2216,21 @@ void aicwf_patch_config_8800dc(struct aic_sdio_dev *rwnx_hw)
 
         #if !defined(CONFIG_FPGA_VERIFICATION)
         if ((IS_CHIP_ID_H())) {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct_h);
+            txgain_cfg_array = (u32 *)txgain_map_femkct_h;
+            #else
             txgain_cfg_size = sizeof(txgain_map_h);
             txgain_cfg_array = (u32 *)txgain_map_h;
+            #endif
         } else {
+            #if defined(CONFIG_EXT_FEM_8800DCDW)
+            txgain_cfg_size = sizeof(txgain_map_femkct);
+            txgain_cfg_array = (u32 *)txgain_map_femkct;
+            #else
             txgain_cfg_size = sizeof(txgain_map);
             txgain_cfg_array = (u32 *)txgain_map;
+            #endif
         }
         ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, txgain_cfg_addr, txgain_cfg_size, txgain_cfg_array);
         if (ret) {
@@ -2272,4 +2518,116 @@ int aicwf_dpd_result_write_8800dc(void *buf, int buf_len)
 #endif /* !CONFIG_FORCE_DPD_CALIB */
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct aic_sdio_dev *sdiodev, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t fw_addr, boot_type;
+    int valid_flag;
+
+    printk("%s\n", __func__);
+
+    ret = aicwf_misc_ram_valid_check_8800dc(sdiodev, &valid_flag);
+    if (ret) {
+        AICWFDBG(LOGINFO, "misc ram check fail: %d\n", ret);
+        return ret;
+    }
+    if (valid_flag) {
+        AICWFDBG(LOGINFO, "misc ram valid, skip calib process\n");
+        return ret;
+    }
+    ret = aicwf_plat_calib_load_8800dc(sdiodev);
+    if (ret) {
+        AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
+        return ret;
+    }
+    /* fw start */
+    fw_addr = 0x00130009;
+    boot_type = HOST_START_APP_FNCALL;
+    AICWFDBG(LOGINFO, "Start app: %08x, %d\n", fw_addr, boot_type);
+    ret = rwnx_send_dbg_start_app_req(sdiodev, fw_addr, boot_type, NULL);
+    if (ret) {
+        AICWFDBG(LOGINFO, "start app fail: %d\n", ret);
+        return ret;
+    }
+    { // read loft res
+        const uint32_t cfg_base = 0x10164;
+        struct dbg_mem_read_cfm cfm;
+        uint32_t misc_ram_addr;
+        uint32_t ram_base_addr, ram_word_cnt;
+        int i;
+        ret = rwnx_send_dbg_mem_read_req(sdiodev, cfg_base + 0x14, &cfm);
+        if (ret) {
+            AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+            return ret;
+        }
+        misc_ram_addr = cfm.memdata;
+        // bit_mask
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+        ram_word_cnt = (MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved)) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(sdiodev, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "bit_mask[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->bit_mask[i] = cfm.memdata;
+        }
+        // loft_res
+        ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+        ram_word_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res) / 4;
+        for (i = 0; i < ram_word_cnt; i++) {
+            ret = rwnx_send_dbg_mem_read_req(sdiodev, ram_base_addr + i * 4, &cfm);
+            if (ret) {
+                AICWFDBG(LOGERROR, "loft_res[0x%x] rd fail: %d\n",  ram_base_addr + i * 4, ret);
+                return ret;
+            }
+            loft_res->loft_res[i] = cfm.memdata;
+        }
+    }
+    return ret;
+}
 
+int aicwf_loft_result_apply_8800dc(struct aic_sdio_dev *sdiodev, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", loft_res->bit_mask[1]);
+    if (loft_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void loft_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == FW_RFTEST_MODE) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(sdiodev, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
+    /* Copy loft_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", loft_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(sdiodev, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->bit_mask[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", loft_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(sdiodev, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    return ret;
+}
+#endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
index 67074cecfc5f..23b8185761eb 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic8800dc_compat.h
@@ -30,6 +30,10 @@ int aicwf_dpd_result_load_8800dc(struct aic_sdio_dev *sdiodev, rf_misc_ram_lite_
 int aicwf_dpd_result_write_8800dc(void *buf, int buf_len);
 #endif/* !CONFIG_FORCE_DPD_CALIB */
 #endif
+#ifdef CONFIG_LOFT_CALIB
+int aicwf_loft_calib_8800dc(struct aic_sdio_dev *sdiodev, rf_misc_ram_lite_t *loft_res);
+int aicwf_loft_result_apply_8800dc(struct aic_sdio_dev *sdiodev, rf_misc_ram_lite_t *loft_res);
+#endif
 
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
index 5d7e6bbb3968..929c58bc3c5f 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.c
@@ -262,7 +262,7 @@ void rwnx_set_cmd_tx(void *dev, struct lmac_msg *msg, uint len)
     if (sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         sdiodev->chipid == PRODUCT_ID_AIC8800DW)
         buffer[3] = 0x0;
-    else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+    else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
 	    buffer[3] = crc8_ponl_107(&buffer[0], 3); // crc8
 	index += 4;
 	//there is a dummy word
@@ -984,7 +984,7 @@ int aicwf_plat_rftest_load_8800dc(struct aic_sdio_dev *sdiodev)
     return ret;
 }
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 int aicwf_misc_ram_valid_check_8800dc(struct aic_sdio_dev *sdiodev, int *valid_out)
 {
     int ret = 0;
@@ -998,7 +998,7 @@ int aicwf_misc_ram_valid_check_8800dc(struct aic_sdio_dev *sdiodev, int *valid_o
         *valid_out = 0;
     }
     if (testmode == FW_RFTEST_MODE) {
-		
+
 	    uint32_t vect1 = 0;
 	    uint32_t vect2 = 0;
 	    cfg_base = RAM_LMAC_FW_ADDR + 0x0004;
@@ -1061,19 +1061,21 @@ int aicwf_plat_calib_load_8800dc(struct aic_sdio_dev *sdiodev)
     if (chip_sub_id == 1) {
         ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_U02);
         if (ret) {
-            AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
             return ret;
         }
     } else if (chip_sub_id == 2) {
         ret = rwnx_plat_bin_fw_upload_android(sdiodev, ROM_FMAC_CALIB_ADDR, RWNX_MAC_CALIB_NAME_8800DC_H_U02);
         if (ret) {
-            AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
+            AICWFDBG(LOGINFO, "load calib bin fail: %d\n", ret);
             return ret;
         }
     }
     return ret;
 }
+#endif
 
+#ifdef CONFIG_DPD
 #ifndef CONFIG_FORCE_DPD_CALIB
 int is_file_exist(char* name)
 {
@@ -1111,6 +1113,11 @@ rf_misc_ram_lite_t dpd_res = {{0},};
 EXPORT_SYMBOL(dpd_res);
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+rf_misc_ram_lite_t loft_res_local = {{0},};
+EXPORT_SYMBOL(loft_res_local);
+#endif
+
 static int rwnx_plat_patch_load(struct aic_sdio_dev *sdiodev)
 {
 	int ret = 0;
@@ -1168,6 +1175,15 @@ static int rwnx_plat_patch_load(struct aic_sdio_dev *sdiodev)
                 }
                 #endif
                 else
+                #elif defined(CONFIG_LOFT_CALIB)
+                if (1) {
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(sdiodev, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                } else
                 #endif
                 {
                     ret = aicwf_misc_ram_init_8800dc(sdiodev);
@@ -1193,8 +1209,23 @@ static int rwnx_plat_patch_load(struct aic_sdio_dev *sdiodev)
                         return ret;
                     }
                 }
-                #endif
-                #endif
+                #endif/*CONFIG_FORCE_DPD_CALIB*/
+                #elif defined(CONFIG_LOFT_CALIB)
+                {
+                    AICWFDBG(LOGINFO, "patch load\n");
+                    ret = aicwf_plat_patch_load_8800dc(sdiodev);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "load patch bin fail: %d\n", ret);
+                        return ret;
+                    }
+                    AICWFDBG(LOGINFO, "loft calib\n");
+                    ret = aicwf_loft_calib_8800dc(sdiodev, &loft_res_local);
+                    if (ret) {
+                        AICWFDBG(LOGINFO, "loft calib fail: %d\n", ret);
+                        return ret;
+                    }
+                }
+                #endif/*CONFIG_DPD*/
                 ret = aicwf_plat_rftest_load_8800dc(sdiodev);
                 if (ret) {
                     AICWFDBG(LOGINFO, "load rftest bin fail: %d\n", ret);
@@ -1360,14 +1391,85 @@ struct aicbt_patch_table *aicbt_patch_table_alloc(const char *filename)
 }
 int aicbt_patch_info_unpack(struct aicbt_patch_info_t *patch_info, struct aicbt_patch_table *head_t)
 {
+    uint8_t *patch_info_array = (uint8_t*)patch_info;
+    int base_len = 0;
+    int memcpy_len = 0;
+    
     if (AICBT_PT_INF == head_t->type) {
-        patch_info->info_len = head_t->len;
-        if(patch_info->info_len == 0)
+        base_len = ((offsetof(struct aicbt_patch_info_t,  ext_patch_nb_addr) - offsetof(struct aicbt_patch_info_t,  adid_addrinf) )/sizeof(uint32_t))/2;
+        AICWFDBG(LOGDEBUG, "%s head_t->len:%d base_len:%d \r\n", __func__, head_t->len, base_len);
+
+        if (head_t->len > base_len){
+            patch_info->info_len = base_len;
+            memcpy_len = patch_info->info_len + 1;//include ext patch nb     
+        } else{
+            patch_info->info_len = head_t->len;
+            memcpy_len = patch_info->info_len;
+        }
+        AICWFDBG(LOGDEBUG, "%s memcpy_len:%d \r\n", __func__, memcpy_len);   
+
+        if (patch_info->info_len == 0)
             return 0;
-        memcpy(&patch_info->adid_addrinf, head_t->data, patch_info->info_len * sizeof(uint32_t) * 2);
+       
+        memcpy(((patch_info_array) + sizeof(patch_info->info_len)), 
+            head_t->data, 
+            memcpy_len * sizeof(uint32_t) * 2);
+        AICWFDBG(LOGDEBUG, "%s adid_addrinf:%x addr_adid:%x \r\n", __func__, 
+            ((struct aicbt_patch_info_t *)patch_info_array)->adid_addrinf,
+            ((struct aicbt_patch_info_t *)patch_info_array)->addr_adid);
+
+        if (patch_info->ext_patch_nb > 0){
+            int index = 0;
+            patch_info->ext_patch_param = (uint32_t *)(head_t->data + ((memcpy_len) * 2));
+            
+            for(index = 0; index < patch_info->ext_patch_nb; index++){
+                AICWFDBG(LOGDEBUG, "%s id:%x addr:%x \r\n", __func__, 
+                    *(patch_info->ext_patch_param + (index * 2)),
+                    *(patch_info->ext_patch_param + (index * 2) + 1));
+            }
+        }
+
     }
     return 0;
 }
+
+int aicbt_ext_patch_data_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_info_t *patch_info)
+{
+    int ret = 0;
+    uint32_t ext_patch_nb = patch_info->ext_patch_nb;
+    char ext_patch_file_name[50];
+    int index = 0;
+    uint32_t id = 0;
+    uint32_t addr = 0;
+
+    
+    if (ext_patch_nb > 0){
+        if (sdiodev->chipid == PRODUCT_ID_AIC8800DC) {
+			AICWFDBG(LOGDEBUG, "[0x40506004]: 0x04318000\n");
+			ret = rwnx_send_dbg_mem_write_req(sdiodev, 0x40506004, 0x04318000);
+			AICWFDBG(LOGDEBUG, "[0x40506004]: 0x04338000\n");
+			ret = rwnx_send_dbg_mem_write_req(sdiodev, 0x40506004, 0x04338000);
+        }
+        for (index = 0; index < patch_info->ext_patch_nb; index++){
+            id = *(patch_info->ext_patch_param + (index * 2));
+            addr = *(patch_info->ext_patch_param + (index * 2) + 1); 
+            memset(ext_patch_file_name, 0, sizeof(ext_patch_file_name));
+            sprintf(ext_patch_file_name,"%s%d.bin",
+                aicbsp_firmware_list[aicbsp_info.cpmode].bt_ext_patch,
+                id);
+            AICWFDBG(LOGDEBUG, "%s ext_patch_file_name:%s ext_patch_id:%x ext_patch_addr:%x \r\n",
+                __func__,ext_patch_file_name, id, addr);
+            
+            if (rwnx_plat_bin_fw_upload_android(sdiodev, addr, ext_patch_file_name)) {
+                ret = -1;
+                break;
+            }
+        }
+    }
+    return ret;
+}
+
+
 int aicbt_patch_trap_data_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_table *head)
 {
 	struct aicbt_patch_info_t patch_info = {
@@ -1380,6 +1482,8 @@ int aicbt_patch_trap_data_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_
         .reset_val         = 0,
         .adid_flag_addr    = 0,
         .adid_flag         = 0,
+        .ext_patch_nb_addr = 0,
+        .ext_patch_nb      = 0,
 	};
     if(head == NULL){
         return -1;
@@ -1426,6 +1530,8 @@ int aicbt_patch_trap_data_load(struct aic_sdio_dev *sdiodev, struct aicbt_patch_
 		return -1;
 	if (rwnx_plat_bin_fw_upload_android(sdiodev, patch_info.addr_patch, aicbsp_firmware_list[aicbsp_info.cpmode].bt_patch))
 		return -1;
+	if (aicbt_ext_patch_data_load(sdiodev, &patch_info))
+		return -1;
 	return 0;
 
 }
@@ -1738,6 +1844,12 @@ int aicwifi_init(struct aic_sdio_dev *sdiodev)
 			printk("download wifi fw fail\n");
 			return -1;
 		}
+		if (testmode == FW_NORMAL_MODE) {
+			if (rwnx_plat_bin_fw_upload_android(sdiodev, RAM_FMAC_FW_PATCH_ADDR, RAM_FMAC_FW_PATCH_NAME)) {
+				printk("download wifi fw patch fail\n");
+				return -1;
+			}
+		}
 
 		if (aicwifi_patch_config(sdiodev)) {
 			printk("aicwifi_patch_config fail\n");
@@ -1792,9 +1904,18 @@ int aicwifi_init(struct aic_sdio_dev *sdiodev)
 			printk("8800d80 wifi start fail\n");
 			return -1;
 		}
+	}else if(sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		if (rwnx_plat_bin_fw_upload_android(sdiodev, RAM_FMAC_FW_ADDR, aicbsp_firmware_list[aicbsp_info.cpmode].wl_fw)) {
+			printk("8800d80x2 download wifi fw fail\n");
+			return -1;
+		}
+		if (aicwifi_start_from_bootrom(sdiodev)) {
+			printk("8800d80x2 wifi start fail\n");
+			return -1;
+		}
 	}
 
-#ifdef CONFIG_GPIO_WAKEUP
+#if (defined(CONFIG_GPIO_WAKEUP) || defined(CONFIG_SDIO_PWRCTRL))
 	if (aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 4)) {
 		sdio_err("reg:%d write failed!\n", sdiodev->sdio_reg.wakeup_reg);
 		return -1;
@@ -1920,16 +2041,33 @@ int aicbsp_driver_fw_init(struct aic_sdio_dev *sdiodev)
 		if (rwnx_send_dbg_mem_read_req(sdiodev, mem_addr, &rd_mem_addr_cfm))
 			return -1;
 
-		aicbsp_info.chip_rev = (u8)(rd_mem_addr_cfm.memdata >> 16);
+		aicbsp_info.chip_rev = (u8)((rd_mem_addr_cfm.memdata >> 16) & 0x3F);
+		is_chip_id_h = (u8)(((rd_mem_addr_cfm.memdata >> 16) & 0xC0) == 0xC0);
 		btenable = 1;
-
-		if (aicbsp_info.chip_rev == CHIP_REV_U01)
-            aicbsp_firmware_list = fw_8800d80_u01;
-        if (aicbsp_info.chip_rev == CHIP_REV_U02 || aicbsp_info.chip_rev == CHIP_REV_U03)
-            aicbsp_firmware_list = fw_8800d80_u02;
+		if (is_chip_id_h) {
+			AICWFDBG(LOGINFO, "IS_CHIP_ID_H \n");
+			aicbsp_firmware_list = fw_8800d80_h_u02;
+		} else {
+			if (aicbsp_info.chip_rev == CHIP_REV_U01)
+				aicbsp_firmware_list = fw_8800d80_u01;
+			if (aicbsp_info.chip_rev == CHIP_REV_U02 || aicbsp_info.chip_rev == CHIP_REV_U03)
+				aicbsp_firmware_list = fw_8800d80_u02;
+		}
         if (aicbsp_system_config_8800d80(sdiodev))
             return -1;
 	}
+	else if(sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		if (rwnx_send_dbg_mem_read_req(sdiodev, mem_addr, &rd_mem_addr_cfm))
+			return -1;
+
+		aicbsp_info.chip_rev = (u8)((rd_mem_addr_cfm.memdata >> 16) & 0x3F);
+			if (aicbsp_info.chip_rev >= (CHIP_REV_U04 + 8))
+				aicbsp_firmware_list = fw_8800d80x2;
+			else{
+					pr_err("aicbsp: %s, unsupport chip rev: %d\n", __func__, aicbsp_info.chip_rev);
+					return -1;
+			}
+	}
 
 	AICWFDBG(LOGINFO, "aicbsp: %s, chip rev: %d\n", __func__, aicbsp_info.chip_rev);
 
@@ -1955,7 +2093,7 @@ int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path)
         aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800DW){
 	    feature->sdio_clock = FEATURE_SDIO_CLOCK;
-	}else if (aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	}else if (aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800D80 || aicbsp_sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
         feature->sdio_clock = FEATURE_SDIO_CLOCK_V3;
 	}
 	feature->sdio_phase = FEATURE_SDIO_PHASE;
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
index 9b42fdbad843..00da3c8be397 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_driver.h
@@ -16,7 +16,7 @@
 #include <linux/module.h>
 #include "aic_bsp_export.h"
 
-#define RWNX_80211_CMD_TIMEOUT_MS    3000//500//300
+#define RWNX_80211_CMD_TIMEOUT_MS    6000//500//300
 
 #define RWNX_CMD_FLAG_NONBLOCK      BIT(0)
 #define RWNX_CMD_FLAG_REQ_CFM       BIT(1)
@@ -310,7 +310,7 @@ struct dbg_start_app_cfm {
 
 int aicwf_plat_patch_load_8800dc(struct aic_sdio_dev *sdiodev);
 int aicwf_plat_rftest_load_8800dc(struct aic_sdio_dev *sdiodev);
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 int aicwf_misc_ram_valid_check_8800dc(struct aic_sdio_dev *sdiodev, int *valid_out);
 int aicwf_plat_calib_load_8800dc(struct aic_sdio_dev *sdiodev);
 #endif
@@ -343,6 +343,7 @@ int aicbsp_resv_mem_deinit(void);
 #define AICBSP_FW_PATH_MAX          200
 
 #define RAM_FMAC_FW_ADDR                    0x00120000
+#define RAM_FMAC_FW_PATCH_ADDR              0x00190000
 #define FW_RAM_ADID_BASE_ADDR               0x00161928
 #define FW_RAM_ADID_BASE_ADDR_U03           0x00161928
 #define FW_RAM_PATCH_BASE_ADDR              0x00100000
@@ -369,7 +370,8 @@ int aicbsp_resv_mem_deinit(void);
 #define ROM_FMAC_FW_ADDR               0x00010000
 #define ROM_FMAC_PATCH_ADDR            0x00180000
 
-#define RWNX_MAC_CALIB_BASE_NAME_8800DC        "fmacfw_calib_8800dc"
+#define RAM_FMAC_FW_PATCH_NAME      			"fmacfw_patch.bin"
+#define RWNX_MAC_CALIB_BASE_NAME_8800DC         "fmacfw_calib_8800dc"
 #define RWNX_MAC_CALIB_NAME_8800DC_U02          RWNX_MAC_CALIB_BASE_NAME_8800DC"_u02.bin"
 #ifdef CONFIG_SDIO_BT
 #define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_hbt_u02.bin"
@@ -377,8 +379,10 @@ int aicbsp_resv_mem_deinit(void);
 #define RWNX_MAC_CALIB_NAME_8800DC_H_U02        RWNX_MAC_CALIB_BASE_NAME_8800DC"_h_u02.bin"
 #endif
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 #define ROM_FMAC_CALIB_ADDR            0x00130000
+#endif
+#ifdef CONFIG_DPD
 #ifndef CONFIG_FORCE_DPD_CALIB
 #define FW_DPDRESULT_NAME_8800DC        "aic_dpdresult_lite_8800dc.bin"
 #endif
@@ -539,15 +543,21 @@ struct aicbt_info_t {
 };
 
 struct aicbt_patch_info_t {
-       uint32_t info_len;
-       uint32_t adid_addrinf;
-	uint32_t addr_adid;
-       uint32_t patch_addrinf;
-	uint32_t addr_patch;
-	uint32_t reset_addr;
-	uint32_t reset_val;
-	uint32_t adid_flag_addr;
-	uint32_t adid_flag;
+    uint32_t info_len;
+//base len start
+    uint32_t adid_addrinf;
+    uint32_t addr_adid;
+    uint32_t patch_addrinf;
+    uint32_t addr_patch;
+    uint32_t reset_addr;
+    uint32_t reset_val;
+    uint32_t adid_flag_addr;
+    uint32_t adid_flag;
+//base len end
+//ext patch nb
+    uint32_t ext_patch_nb_addr;
+    uint32_t ext_patch_nb;
+    uint32_t *ext_patch_param;
 };
 
 struct aicbsp_firmware {
@@ -556,6 +566,7 @@ struct aicbsp_firmware {
 	const char *bt_patch;
 	const char *bt_table;
 	const char *wl_fw;
+    const char *bt_ext_patch;
 };
 
 struct aicbsp_info_t {
@@ -577,5 +588,7 @@ extern const struct aicbsp_firmware fw_8800dc_u02[];
 extern const struct aicbsp_firmware fw_8800dc_h_u02[];
 extern const struct aicbsp_firmware fw_8800d80_u01[];
 extern const struct aicbsp_firmware fw_8800d80_u02[];
+extern const struct aicbsp_firmware fw_8800d80_h_u02[];
+extern const struct aicbsp_firmware fw_8800d80x2[];
 
 #endif
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
index 249d6ec082ea..5535df6e0d14 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_export.h
@@ -31,7 +31,7 @@ struct aicbsp_feature_t {
 	uint8_t  irqf;
 };
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 typedef struct {
     uint32_t bit_mask[3];
     uint32_t reserved;
@@ -53,10 +53,16 @@ typedef struct {
 
 #define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
 #define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+#endif
 
+#ifdef CONFIG_DPD
 extern rf_misc_ram_lite_t dpd_res;
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+extern rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicbsp_set_subsys(int, int);
 int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path);
 struct sk_buff *aicbsp_resv_mem_alloc_skb(unsigned int length, uint32_t id);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
index b3b5dd0eab7f..0788eaa7f7c2 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aic_bsp_main.c
@@ -17,6 +17,8 @@
 
 int aicwf_dbg_level_bsp = LOGERROR;
 
+struct semaphore aicbsp_probe_semaphore;
+
 static struct platform_device *aicbsp_pdev;
 
 const struct aicbsp_firmware *aicbsp_firmware_list = fw_u02;
@@ -91,6 +93,7 @@ const struct aicbsp_firmware fw_8800dc_u02[] = {
 		.bt_adid       = "fw_adid_8800dc_u02.bin",
 		.bt_patch      = "fw_patch_8800dc_u02.bin",
 		.bt_table      = "fw_patch_table_8800dc_u02.bin",
+		.bt_ext_patch  = "fw_patch_8800dc_u02_ext",
 		.wl_fw         = "fmacfw_patch_8800dc_u02.bin"
 	},
 
@@ -99,6 +102,7 @@ const struct aicbsp_firmware fw_8800dc_u02[] = {
 		.bt_adid       = "fw_adid_8800dc_u02.bin",
 		.bt_patch      = "fw_patch_8800dc_u02.bin",
 		.bt_table      = "fw_patch_table_8800dc_u02.bin",
+		.bt_ext_patch  = "fw_patch_8800dc_u02_ext",
 		.wl_fw         = "lmacfw_rf_8800dc.bin" //u01,u02 lmacfw load same bin
 	},
 };
@@ -109,6 +113,7 @@ const struct aicbsp_firmware fw_8800dc_h_u02[] = {
 		.bt_adid       = "fw_adid_8800dc_u02h.bin",
 		.bt_patch      = "fw_patch_8800dc_u02h.bin",
 		.bt_table      = "fw_patch_table_8800dc_u02h.bin",
+		.bt_ext_patch  = "fw_patch_8800dc_u02h_ext",
 		.wl_fw         = "fmacfw_patch_8800dc_h_u02.bin"
 	},
 
@@ -117,6 +122,7 @@ const struct aicbsp_firmware fw_8800dc_h_u02[] = {
 		.bt_adid       = "fw_adid_8800dc_u02h.bin",
 		.bt_patch      = "fw_patch_8800dc_u02h.bin",
 		.bt_table      = "fw_patch_table_8800dc_u02h.bin",
+		.bt_ext_patch  = "fw_patch_8800dc_u02h_ext",
 		.wl_fw         = "lmacfw_rf_8800dc.bin" //u01,u02 lmacfw load same bin
 	},
 };
@@ -146,11 +152,40 @@ const struct aicbsp_firmware fw_8800d80_u02[] = {
 		.bt_adid       = "fw_adid_8800d80_u02.bin",
 		.bt_patch      = "fw_patch_8800d80_u02.bin",
 		.bt_table      = "fw_patch_table_8800d80_u02.bin",
-	#ifdef CONFIG_SDIO_BT
-		.wl_fw         = "fmacfwbt_8800d80_u02.bin"
+	#if defined CONFIG_SDIO_BT
+		.wl_fw         = "fmacfwbt_8800d80_u02.bin",
+	#elif defined CONFIG_FOR_IPCAM
+		.wl_fw		   = "fmacfw_8800d80_u02_ipc.bin",
+	#else
+		.wl_fw         = "fmacfw_8800d80_u02.bin",
+	#endif
+        .bt_ext_patch  = "fw_patch_8800d80_u02_ext"
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(8800d80 sdio u02)",
+		.bt_adid       = "fw_adid_8800d80_u02.bin",
+		.bt_patch      = "fw_patch_8800d80_u02.bin",
+		.bt_table      = "fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "lmacfw_rf_8800d80_u02.bin",
+		.bt_ext_patch  = "fw_patch_8800d80_u02_ext"
+	},
+};
+
+const struct aicbsp_firmware fw_8800d80_h_u02[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(8800d80 sdio h_u02)",
+		.bt_adid       = "fw_adid_8800d80_u02.bin",
+		.bt_patch      = "fw_patch_8800d80_u02.bin",
+		.bt_table      = "fw_patch_table_8800d80_u02.bin",
+	#if defined CONFIG_SDIO_BT
+		.wl_fw         = "fmacfwbt_8800d80_h_u02.bin",
+	#elif defined CONFIG_FOR_IPCAM
+		.wl_fw         = "fmacfw_8800d80_h_u02_ipc.bin",
 	#else
-		.wl_fw         = "fmacfw_8800d80_u02.bin"
+		.wl_fw         = "fmacfw_8800d80_h_u02.bin",
 	#endif
+        .bt_ext_patch  = "fw_patch_8800d80_u02_ext"
 	},
 
 	[AICBSP_CPMODE_TEST] = {
@@ -158,7 +193,32 @@ const struct aicbsp_firmware fw_8800d80_u02[] = {
 		.bt_adid       = "fw_adid_8800d80_u02.bin",
 		.bt_patch      = "fw_patch_8800d80_u02.bin",
 		.bt_table      = "fw_patch_table_8800d80_u02.bin",
-		.wl_fw         = "lmacfw_rf_8800d80_u02.bin"
+		.wl_fw         = "lmacfw_rf_8800d80_u02.bin",
+		.bt_ext_patch  = "fw_patch_8800d80_u02_ext"
+	},
+};
+
+const struct aicbsp_firmware fw_8800d80x2[] = {
+	[AICBSP_CPMODE_WORK] = {
+		.desc          = "normal work mode(8800d80x2 sdio)",
+		.bt_adid       = "fw_adid_8800d80_u02.bin",
+		.bt_patch      = "fw_patch_8800d80_u02.bin",
+		.bt_table      = "fw_patch_table_8800d80_u02.bin",
+	#ifdef CONFIG_SDIO_BT
+		.wl_fw         = "fmacfwbt_8800d80_h_u02.bin",
+	#else
+		.wl_fw         = "fmacfw_8800d80x2.bin",
+	#endif
+        .bt_ext_patch  = "fw_patch_8800d80_u02_ext"
+	},
+
+	[AICBSP_CPMODE_TEST] = {
+		.desc          = "rf test mode(8800d80x2 sdio)",
+		.bt_adid       = "fw_adid_8800d80_u02.bin",
+		.bt_patch      = "fw_patch_8800d80_u02.bin",
+		.bt_table      = "fw_patch_table_8800d80_u02.bin",
+		.wl_fw         = "lmacfw_rf_8800d80x2.bin",
+		.bt_ext_patch  = "fw_patch_8800d80_u02_ext"
 	},
 };
 
@@ -337,6 +397,9 @@ static int __init aicbsp_init(void)
 	aicbsp_info.cpmode = testmode;
 
 	aicbsp_resv_mem_init();
+    
+    sema_init(&aicbsp_probe_semaphore, 0);
+    
 	ret = platform_driver_register(&aicbsp_driver);
 	if (ret) {
 		pr_err("register platform driver failed: %d\n", ret);
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
index 4a9707c03beb..813c0f39f8ed 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.c
@@ -48,7 +48,7 @@ static void aicbsp_platform_power_off(void);
 
 struct aic_sdio_dev *aicbsp_sdiodev = NULL;
 static struct semaphore *aicbsp_notify_semaphore;
-static struct semaphore *aicbsp_probe_semaphore;
+extern struct semaphore aicbsp_probe_semaphore;
 
 static const struct sdio_device_id aicbsp_sdmmc_ids[];
 static bool aicbsp_load_fw_in_fdrv = false;
@@ -77,10 +77,12 @@ extern int testmode;
 #define SDIO_VENDOR_ID_AIC8801              0x5449
 #define SDIO_VENDOR_ID_AIC8800DC            0xc8a1
 #define SDIO_VENDOR_ID_AIC8800D80           0xc8a1
+#define SDIO_VENDOR_ID_AIC8800D80X2         0xc8a1
 
 #define SDIO_DEVICE_ID_AIC8801				0x0145
 #define SDIO_DEVICE_ID_AIC8800DC			0xc08d
 #define SDIO_DEVICE_ID_AIC8800D80           0x0082
+#define SDIO_DEVICE_ID_AIC8800D80X2         0x2082
 
 
 static int aicbsp_dummy_probe(struct sdio_func *func, const struct sdio_device_id *id)
@@ -244,6 +246,10 @@ static int aicwf_sdio_chipmatch(struct aic_sdio_dev *sdio_dev, uint16_t vid, uin
 		sdio_dev->chipid = PRODUCT_ID_AIC8800D80;
 		AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
 		return 0;
+	}else if(vid == SDIO_VENDOR_ID_AIC8800D80X2 && did == SDIO_DEVICE_ID_AIC8800D80X2){
+		sdio_dev->chipid = PRODUCT_ID_AIC8800D80X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D80X2\r\n", __func__);
+		return 0;
 	}else{
 		return -1;
 	}
@@ -266,6 +272,11 @@ static int aicbsp_sdio_probe(struct sdio_func *func,
 	struct aicwf_bus *bus_if;
 	int err = -ENODEV;
 
+	if (func == NULL) {
+		sdio_err("%s func is null\n", __func__);
+		return err;
+	}
+
 	sdio_dbg("%s:%d vid:0x%04X  did:0x%04X\n", __func__, func->num,
 		func->vendor, func->device);
 
@@ -285,8 +296,11 @@ static int aicbsp_sdio_probe(struct sdio_func *func,
 		return err;
 	}
 
-	func = func->card->sdio_func[1 - 1]; //replace 2 with 1
 	host = func->card->host;
+	host->caps |= MMC_CAP_NONREMOVABLE;
+
+	func = func->card->sdio_func[1 - 1]; //replace 2 with 1
+
 	sdio_dbg("%s after replace:%d\n", __func__, func->num);
 
 	bus_if = kzalloc(sizeof(struct aicwf_bus), GFP_KERNEL);
@@ -319,7 +333,7 @@ static int aicbsp_sdio_probe(struct sdio_func *func,
 	dev_set_drvdata(&func->dev, bus_if);
 	sdiodev->dev = &func->dev;
 
-    if (sdiodev->chipid != PRODUCT_ID_AIC8800D80) {
+    if (sdiodev->chipid != PRODUCT_ID_AIC8800D80 && sdiodev->chipid != PRODUCT_ID_AIC8800D80X2) {
 	    err = aicwf_sdio_func_init(sdiodev);
     } else {
         err = aicwf_sdiov3_func_init(sdiodev);
@@ -333,11 +347,11 @@ static int aicbsp_sdio_probe(struct sdio_func *func,
 		sdio_err("sdio bus init err\r\n");
 		goto fail;
 	}
-	host->caps |= MMC_CAP_NONREMOVABLE;
+
 	aicbsp_platform_init(sdiodev);
-	
-	up(aicbsp_probe_semaphore);
-	
+
+	up(&aicbsp_probe_semaphore);
+
 	return 0;
 fail:
 	aicwf_sdio_func_deinit(sdiodev);
@@ -347,33 +361,37 @@ static int aicbsp_sdio_probe(struct sdio_func *func,
 	return err;
 }
 
+
 static void aicbsp_sdio_remove(struct sdio_func *func)
 {
 	struct mmc_host *host;
 	struct aicwf_bus *bus_if = NULL;
 	struct aic_sdio_dev *sdiodev = NULL;
 
-	sdio_dbg("%s\n", __func__);
+	AICWFDBG(LOGINFO, "%s\n", __func__);
 	if (aicbsp_sdiodev == NULL) {
-		sdio_dbg("%s: allready unregister\n", __func__);
-		return;
+		AICWFDBG(LOGERROR, "%s: allready unregister\n", __func__);
+		goto done;
 	}
-
-    bus_if = aicbsp_get_drvdata(&func->dev);
-
-	if (!bus_if) {
-        AICWFDBG(LOGERROR, "%s bus_if is NULL \r\n", __func__);
-		return;
+	if (func == NULL) {
+		AICWFDBG(LOGERROR, "%s, sdio func is null\n", __func__);
+		goto done;
 	}
 
-	func = aicbsp_sdiodev->func;
 	host = func->card->host;
 	host->caps &= ~MMC_CAP_NONREMOVABLE;
 
+	bus_if = aicbsp_get_drvdata(&func->dev);
+
+	if (!bus_if) {
+		AICWFDBG(LOGERROR, "%s bus_if is NULL \r\n", __func__);
+		goto done;
+	}
+
 	sdiodev = bus_if->bus_priv.sdio;
 	if (!sdiodev) {
-        AICWFDBG(LOGERROR, "%s sdiodev is NULL \r\n", __func__);
-		return;
+		AICWFDBG(LOGERROR, "%s sdiodev is NULL \r\n", __func__);
+		goto done;
 	}
 
 	aicwf_sdio_release(sdiodev);
@@ -381,11 +399,15 @@ static void aicbsp_sdio_remove(struct sdio_func *func)
 
 	dev_set_drvdata(&sdiodev->func->dev, NULL);
 	kfree(sdiodev);
-	kfree(bus_if);
+
+done:
+	if (bus_if)
+		kfree(bus_if);
 	aicbsp_sdiodev = NULL;
 	sdio_dbg("%s done\n", __func__);
 }
 
+
 static int aicbsp_sdio_suspend(struct device *dev)
 {
 	struct sdio_func *func = dev_to_sdio_func(dev);
@@ -565,17 +587,13 @@ static void aicbsp_platform_power_off(void)
 
 int aicbsp_sdio_init(void)
 {
-	struct semaphore aic_chipup_sem;
 
-	sema_init(&aic_chipup_sem, 0);
-	aicbsp_probe_semaphore = &aic_chipup_sem;
-	
 	if (sdio_register_driver(&aicbsp_sdio_driver)) {
 		return -1;
 	} else {
 		//may add mmc_rescan here
 	}
-	if (down_timeout(aicbsp_probe_semaphore, msecs_to_jiffies(2000)) != 0){
+	if (down_timeout(&aicbsp_probe_semaphore, msecs_to_jiffies(2000)) != 0){
 		printk("%s aicbsp_sdio_probe fail\r\n", __func__);
 		return -1;
 	}
@@ -739,7 +757,7 @@ int aicwf_sdio_wakeup(struct aic_sdio_dev *sdiodev)
         sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
         wakeup_reg_val = 1;
-    } else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    } else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         wakeup_reg_val = 0x11;
     }
 
@@ -959,7 +977,8 @@ static int aicwf_sdio_tx_msg(struct aic_sdio_dev *sdiodev)
 	} else
 		len = payload_len;
 
-	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80 || 
+		sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		buffer_cnt = aicwf_sdio_flow_ctrl(sdiodev);
 		while ((buffer_cnt <= 0 || (buffer_cnt > 0 && len > (buffer_cnt * BUFFER_SIZE))) && retry < 10) {
 			retry++;
@@ -969,7 +988,8 @@ static int aicwf_sdio_tx_msg(struct aic_sdio_dev *sdiodev)
 	}
 	down(&sdiodev->tx_priv->cmd_txsema);
 
-	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		if (buffer_cnt > 0 && len < (buffer_cnt * BUFFER_SIZE)) {
 			err = aicwf_sdio_send_pkt(sdiodev, payload, len);
 			if (err) {
@@ -1203,7 +1223,7 @@ int aicwf_sdio_aggr(struct aicwf_tx_priv *tx_priv, struct sk_buff *pkt)
 	if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8801 || tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800DW)
         sdio_header[3] = 0; //reserved
-    else if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+    else if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80  || tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
 	    sdio_header[3] = crc8_ponl_107(&sdio_header[0], 3); // crc8
 
 	memcpy(tx_priv->tail, (u8 *)&sdio_header, sizeof(sdio_header));
@@ -1310,7 +1330,7 @@ static int aicwf_sdio_bus_start(struct device *dev)
 
 		if (ret != 0)
 			sdio_err("func2 intr register failed:%d\n", ret);
-	}else if(sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	}else if(sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		sdio_claim_host(sdiodev->func);
 		sdio_claim_irq(sdiodev->func, aicwf_sdio_hal_irqhandler);
 
@@ -1451,7 +1471,7 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
 
     	    ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.block_cnt_reg, &intstatus);
     	}
-    }else if (sdiodev->chipid  == PRODUCT_ID_AIC8800D80) {
+    }else if (sdiodev->chipid  == PRODUCT_ID_AIC8800D80 || sdiodev->chipid  == PRODUCT_ID_AIC8800D80X2) {
         do {
             ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.misc_int_status_reg, &intstatus);
             if (!ret) {
@@ -1606,22 +1626,33 @@ void aicwf_sdio_release_func2(struct aic_sdio_dev *sdiodev)
 
 void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 {
-	struct aicwf_bus *bus_if;
+	struct aicwf_bus *bus_if = NULL;
+	struct aicwf_bus *bus_if_t = NULL;
 	int ret = 0;
 
 	sdio_dbg("%s\n", __func__);
+	if (sdiodev->func == NULL) {
+		printk("%s, NULL sdio func\n", __func__);
+		return;
+	}
 
 	bus_if = aicbsp_get_drvdata(sdiodev->dev);
-	bus_if->state = BUS_DOWN_ST;
+	if (bus_if)
+		bus_if->state = BUS_DOWN_ST;
 
-	sdio_claim_host(sdiodev->func);
-	//disable sdio interrupt
-	ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
-	if (ret < 0) {
-		sdio_err("reg:%d write failed!, ret=%d\n", sdiodev->sdio_reg.intr_config_reg, ret);
+	bus_if_t = dev_get_drvdata(sdiodev->dev);
+
+	if ((bus_if_t != NULL) && (sdiodev->bus_if == bus_if_t)) {
+		sdio_dbg("%s bsp release\n", __func__);
+		sdio_claim_host(sdiodev->func);
+		//disable sdio interrupt
+		ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
+		if (ret < 0) {
+			sdio_err("reg:%d write failed!, ret=%d\n", sdiodev->sdio_reg.intr_config_reg, ret);
+		}
+		sdio_release_irq(sdiodev->func);
+		sdio_release_host(sdiodev->func);
 	}
-	sdio_release_irq(sdiodev->func);
-	sdio_release_host(sdiodev->func);
 
 	if(sdiodev->chipid == PRODUCT_ID_AIC8800DC || sdiodev->chipid == PRODUCT_ID_AIC8800DW){
 		aicwf_sdio_release_func2(sdiodev);
@@ -1639,6 +1670,8 @@ void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 	rwnx_cmd_mgr_deinit(&sdiodev->cmd_mgr);
 }
 
+
+
 void aicwf_sdio_reg_init(struct aic_sdio_dev *sdiodev)
 {
     sdio_dbg("%s\n", __func__);
@@ -1655,7 +1688,7 @@ void aicwf_sdio_reg_init(struct aic_sdio_dev *sdiodev)
         sdiodev->sdio_reg.block_cnt_reg =          SDIOWIFI_BLOCK_CNT_REG;
         sdiodev->sdio_reg.rd_fifo_addr =           SDIOWIFI_RD_FIFO_ADDR;
         sdiodev->sdio_reg.wr_fifo_addr =           SDIOWIFI_WR_FIFO_ADDR;
-	} else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	} else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
         sdiodev->sdio_reg.bytemode_len_reg =       SDIOWIFI_BYTEMODE_LEN_REG_V3;
         sdiodev->sdio_reg.intr_config_reg =        SDIOWIFI_INTR_ENABLE_REG_V3;
         sdiodev->sdio_reg.sleep_reg =              SDIOWIFI_INTR_PENDING_REG_V3;
@@ -1847,16 +1880,35 @@ int aicwf_sdiov3_func_init(struct aic_sdio_dev *sdiodev)
 
 void aicwf_sdio_func_deinit(struct aic_sdio_dev *sdiodev)
 {
-	sdio_claim_host(sdiodev->func);
-	sdio_disable_func(sdiodev->func);
-	sdio_release_host(sdiodev->func);
+	struct aicwf_bus *bus_if = NULL;
+
+	if (sdiodev->func == NULL) {
+		sdio_err("%s, NULL sdio func\n", __func__);
+		return;
+	}
+
+	bus_if = dev_get_drvdata(sdiodev->dev);
+	if (bus_if == NULL) {
+		sdio_err("%s, bus_if is null\n", __func__);
+		return;
+	}
+
+	if (sdiodev->bus_if == bus_if) {
+		sdio_dbg("%s bsp disable\n", __func__);
+		sdio_claim_host(sdiodev->func);
+		sdio_disable_func(sdiodev->func);
+		sdio_release_host(sdiodev->func);
+	}
+
 	if(sdiodev->chipid == PRODUCT_ID_AIC8800DC || sdiodev->chipid == PRODUCT_ID_AIC8800DW){
 		sdio_claim_host(sdiodev->func_msg);
 		sdio_disable_func(sdiodev->func_msg);
 		sdio_release_host(sdiodev->func_msg);
 	}
+
 }
 
+
 void *aicwf_sdio_bus_init(struct aic_sdio_dev *sdiodev)
 {
 	int ret;
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
index 68efaf5f642c..65d73510ad3a 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/aicsdio.h
@@ -69,7 +69,8 @@ enum AICWF_IC{
 	PRODUCT_ID_AIC8801	=	0,
 	PRODUCT_ID_AIC8800DC,
 	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80
+	PRODUCT_ID_AIC8800D80,
+	PRODUCT_ID_AIC8800D80X2
 };
 
 struct aic_sdio_reg {
diff --git a/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
index ed5429ee9420..df078d3c2487 100644
--- a/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_bsp/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "241c091M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - - 241c091M (master)"
-#define RELEASE_DATE "2024_0327_3561b08f"
+#define RELEASE_DATE "2024_1119_06da8476"
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
index 8c10df7e19a4..2b24142d6e56 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/Makefile
@@ -75,22 +75,20 @@ CONFIG_RFTEST=y
 CONFIG_USB_BT =y
 CONFIG_SDIO_BT=n
 CONFIG_USE_5G ?= y
-CONFIG_SDIO_PWRCTRL ?= y
 CONFIG_CREATE_TRACE_POINTS = n
 CONFIG_TXRX_THREAD_PRIO = y
 # CONFIG_COEX = n for BT_ONLY, CONFIG_COEX =y for combo and sw
 CONFIG_COEX = y
 CONFIG_RX_NETIF_RECV_SKB = y
-CONFIG_GPIO_WAKEUP ?= n
 CONFIG_SET_VENDOR_EXTENSION_IE = n
 CONFIG_SUPPORT_REALTIME_CHANGE_MAC = y
 CONFIG_WPA3_FOR_OLD_KERNEL ?= n
 CONFIG_VHT_FOR_OLD_KERNEL ?= n
 CONFIG_HE_FOR_OLD_KERNEL ?= n
-CONFIG_PREALLOC_RX_SKB = n
+CONFIG_PREALLOC_RX_SKB ?= n
 CONFIG_WIFI_SUSPEND_FOR_LINUX = n
 # Need to set fw path in BOARD_KERNEL_CMDLINE
-CONFIG_USE_FW_REQUEST = n
+CONFIG_USE_FW_REQUEST ?= n
 CONFIG_USE_P2P0=n
 CONFIG_TX_NETIF_FLOWCTRL = n
 CONFIG_ONE_TXQ = n
@@ -103,17 +101,38 @@ CONFIG_USE_CUSTOMER_MAC = n
 CONFIG_PREALLOC_TXQ ?= y
 CONFIG_DPD = y
 CONFIG_FORCE_DPD_CALIB = y
-CONFIG_FILTER_TCP_ACK =n
+CONFIG_LOFT_CALIB = n
+CONFIG_FILTER_TCP_ACK =y
 CONFIG_RESV_MEM_SUPPORT ?= y
 CONFIG_GKI = n
 CONFIG_TEMP_COMP = n
+CONFIG_TEMP_CONTROL = n
+CONFIG_EXT_FEM_8800DCDW = n
+CONFIG_SHUTDOWN_CALLBACK = y
+CONFIG_FOR_IPCAM = n
 # CONFIG_MCC = n for sta and p2p concurrent in same channel.
 CONFIG_MCC = y
+CONFIG_APF = n
+CONFIG_POWER_LIMIT = n
+
+#CONFIG FOR LOW POWER MODE
+CONFIG_SDIO_PWRCTRL ?= y
+CONFIG_GPIO_WAKEUP ?= n
+CONFIG_AUTO_POWERSAVE = n
+
+# Enable wifi-hal Latency Mode
+CONFIG_AICWF_LATENCY_MODE = n
 
 ifneq ($(CONFIG_WIRELESS_EXT), y)
 CONFIG_USE_WIRELESS_EXT = n
 endif
 
+ifeq ($(CONFIG_EXT_FEM_8800DCDW), y)
+CONFIG_DPD = n
+CONFIG_FORCE_DPD_CALIB = n
+CONFIG_LOFT_CALIB = y
+endif
+
 # Support of MU-MIMO transmission (need FW support)
 ifeq ($(CONFIG_RWNX_BFMER), y)
 CONFIG_RWNX_MUMIMO_TX ?= n
@@ -128,7 +147,9 @@ CONFIG_RWNX_RADAR ?= y
 CONFIG_RWNX_BCMC ?= y
 
 # Enable Monitor+Data interface support (need FW support)
-CONFIG_RWNX_MON_DATA =y
+CONFIG_RWNX_MON_DATA =n
+CONFIG_RWNX_MON_XMIT ?= n
+
 
 # extra DEBUG config
 CONFIG_RWNX_SW_PROFILING ?= n
@@ -162,6 +183,7 @@ $(MODULE_NAME)-y := \
 	aicwf_compat_8800d80.o \
 	rwnx_wakelock.o		\
 	regdb.o				   \
+	aic_priv_cmd.o		\
 	aicwf_rx_prealloc.o
 
 $(MODULE_NAME)-$(CONFIG_BR_SUPPORT)       += aic_br_ext.o
@@ -226,6 +248,7 @@ ccflags-y += -I$(srctree)/$(src)/../aic8800_bsp
 ccflags-y += -DCONFIG_AIC_FW_PATH=\"$(CONFIG_AIC_FW_PATH)\"
 ccflags-$(CONFIG_RWNX_RADAR) += -DCONFIG_RWNX_RADAR
 ccflags-$(CONFIG_RWNX_MON_DATA) += -DCONFIG_RWNX_MON_DATA
+ccflags-$(CONFIG_RWNX_MON_XMIT) += -DCONFIG_RWNX_MON_XMIT
 ccflags-$(CONFIG_RWNX_BFMER) += -DCONFIG_RWNX_BFMER
 ccflags-$(CONFIG_RWNX_SPLIT_TX_BUF) += -DCONFIG_RWNX_SPLIT_TX_BUF
 ifeq ($(CONFIG_RWNX_SPLIT_TX_BUF), y)
@@ -251,16 +274,23 @@ ccflags-$(CONFIG_USE_P2P0) += -DCONFIG_USE_P2P0
 ccflags-$(CONFIG_FDRV_NO_REG_SDIO) += -DCONFIG_FDRV_NO_REG_SDIO
 ccflags-$(CONFIG_SCHED_SCAN) += -DCONFIG_SCHED_SCAN
 ccflags-$(CONFIG_OOB) += -DCONFIG_OOB
+ccflags-$(CONFIG_AICWF_LATENCY_MODE) += -DAICWF_LATENCY_MODE
 ccflags-$(CONFIG_USE_CUSTOMER_MAC) += -DCONFIG_USE_CUSTOMER_MAC
 ccflags-$(CONFIG_PREALLOC_TXQ) += -DCONFIG_PREALLOC_TXQ
 ccflags-$(CONFIG_DPD) += -DCONFIG_DPD
 ccflags-$(CONFIG_FORCE_DPD_CALIB) += -DCONFIG_FORCE_DPD_CALIB -DCONFIG_DPD
+ccflags-$(CONFIG_LOFT_CALIB) += -DCONFIG_LOFT_CALIB
 ccflags-$(CONFIG_FILTER_TCP_ACK) += -DCONFIG_FILTER_TCP_ACK
 ccflags-$(CONFIG_SDIO_BT) += -DCONFIG_SDIO_BT
 ccflags-$(CONFIG_RESV_MEM_SUPPORT) += -DCONFIG_RESV_MEM_SUPPORT
 ccflags-$(CONFIG_GKI) += -DCONFIG_GKI
 ccflags-$(CONFIG_TEMP_COMP) += -DCONFIG_TEMP_COMP
+ccflags-$(CONFIG_TEMP_CONTROL) += -DCONFIG_TEMP_CONTROL
+ccflags-$(CONFIG_POWER_LIMIT) += -DCONFIG_POWER_LIMIT
+ccflags-$(CONFIG_EXT_FEM_8800DCDW) += -DCONFIG_EXT_FEM_8800DCDW
 ccflags-$(CONFIG_MCC) += -DCONFIG_MCC
+ccflags-$(CONFIG_SHUTDOWN_CALLBACK) += -DCONFIG_SHUTDOWN_CALLBACK
+ccflags-$(CONFIG_FOR_IPCAM) += -DCONFIG_FOR_IPCAM
 
 
 ifeq ($(CONFIG_SDIO_SUPPORT), y)
@@ -296,11 +326,13 @@ endif
 
 ccflags-$(CONFIG_RX_REORDER) += -DAICWF_RX_REORDER
 ccflags-$(CONFIG_ARP_OFFLOAD) += -DAICWF_ARP_OFFLOAD
-ccflags-$(CONFIG_RADAR_DETECT) += -DRADAR_OR_IR_DETECT
+ccflags-$(CONFIG_RADAR_OR_IR_DETECT) += -DCONFIG_RADAR_OR_IR_DETECT
 ccflags-$(CONFIG_DOWNLOAD_FW)  += -DCONFIG_DOWNLOAD_FW
 ccflags-$(CONFIG_RX_NETIF_RECV_SKB) += -DCONFIG_RX_NETIF_RECV_SKB
 ccflags-$(CONFIG_ONE_TXQ)  += -DCONFIG_ONE_TXQ
 ccflags-$(CONFIG_TX_NETIF_FLOWCTRL) += -DCONFIG_TX_NETIF_FLOWCTRL
+ccflags-$(CONFIG_APF) += -DCONFIG_APF
+ccflags-$(CONFIG_AUTO_POWERSAVE) += -DCONFIG_AUTO_POWERSAVE
 
 ccflags-y += -DAIC_TRACE_INCLUDE_PATH=$(src)
 MAKEFLAGS +=-j$(shell nproc)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
index bd806fad5935..d3d020533a84 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_bsp_export.h
@@ -23,7 +23,7 @@ enum skb_buff_id {
 	AIC_RESV_MEM_TXDATA,
 };
 
-#ifdef CONFIG_DPD
+#if defined(CONFIG_DPD) || defined(CONFIG_LOFT_CALIB)
 typedef struct {
     uint32_t bit_mask[3];
     uint32_t reserved;
@@ -45,10 +45,16 @@ typedef struct {
 
 #define MEMBER_SIZE(type, member)   sizeof(((type *)0)->member)
 #define DPD_RESULT_SIZE_8800DC      sizeof(rf_misc_ram_lite_t)
+#endif
 
+#ifdef CONFIG_DPD
 extern rf_misc_ram_lite_t dpd_res;
 #endif
 
+#ifdef CONFIG_LOFT_CALIB
+extern rf_misc_ram_lite_t loft_res_local;
+#endif
+
 int aicbsp_set_subsys(int, int);
 int aicbsp_get_feature(struct aicbsp_feature_t *feature, char *fw_path);
 bool aicbsp_get_load_fw_in_fdrv(void);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
new file mode 100644
index 000000000000..b23ae702b968
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.c
@@ -0,0 +1,1920 @@
+/**
+ ******************************************************************************
+ *
+ * @file aic_priv_cmd.c
+ *
+ * @brief Entry point of the AIC driver
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#include <linux/netdevice.h>
+#include <linux/ctype.h>
+#include "rwnx_defs.h"
+#include "rwnx_msg_tx.h"
+#include "rwnx_debugfs.h"
+#include "rwnx_main.h"
+#include "aicwf_sdio.h"
+#include "aic_priv_cmd.h"
+
+extern int testmode;
+static void print_help(const char *cmd);
+struct dbg_rftest_cmd_cfm cfm = {{0,}};
+
+#ifdef CONFIG_RFTEST
+enum {
+	SET_TX,
+	SET_TXSTOP,
+	SET_TXTONE,
+	SET_RX,
+	GET_RX_RESULT,
+	SET_RXSTOP,
+	SET_RX_METER,
+	SET_POWER,
+	SET_XTAL_CAP,
+	SET_XTAL_CAP_FINE,
+	GET_EFUSE_BLOCK,
+	SET_FREQ_CAL,
+	SET_FREQ_CAL_FINE,
+	GET_FREQ_CAL,
+	SET_MAC_ADDR,
+	GET_MAC_ADDR,
+	SET_BT_MAC_ADDR,
+	GET_BT_MAC_ADDR,
+	SET_VENDOR_INFO,
+	GET_VENDOR_INFO,
+	RDWR_PWRMM,
+	RDWR_PWRIDX,
+	RDWR_PWRLVL = RDWR_PWRIDX,
+	RDWR_PWROFST,
+	RDWR_DRVIBIT,
+	RDWR_EFUSE_PWROFST,
+	RDWR_EFUSE_DRVIBIT,
+	SET_PAPR,
+	SET_CAL_XTAL,
+	GET_CAL_XTAL_RES,
+	SET_COB_CAL,
+	GET_COB_CAL_RES,
+	RDWR_EFUSE_USRDATA,
+	SET_NOTCH,
+	RDWR_PWROFSTFINE,
+	RDWR_EFUSE_PWROFSTFINE,
+	RDWR_EFUSE_SDIOCFG,
+	RDWR_EFUSE_USBVIDPID,
+	SET_SRRC,
+	SET_FSS,
+	RDWR_EFUSE_HE_OFF,
+	SET_USB_OFF,
+	SET_PLL_TEST,
+	SET_ANT_MODE,
+	RDWR_BT_EFUSE_PWROFST,
+};
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+	u8_l mode;
+	u8_l rate;
+	u16_l length;
+	u16_l tx_intv_us;
+	s8_l max_pwr;
+} cmd_rf_settx_t;
+
+typedef struct {
+	u8_l val;
+} cmd_rf_setfreq_t;
+
+typedef struct {
+	u8_l chan;
+	u8_l bw;
+} cmd_rf_rx_t;
+
+typedef struct {
+	u8_l block;
+} cmd_rf_getefuse_t;
+
+typedef struct {
+	u8_l dutid;
+	u8_l chip_num;
+	u8_l dis_xtal;
+} cmd_rf_setcobcal_t;
+
+typedef struct {
+	u16_l dut_rcv_golden_num;
+	u8_l golden_rcv_dut_num;
+	s8_l rssi_static;
+	s8_l snr_static;
+	s8_l dut_rssi_static;
+	u16_l reserved;
+} cob_result_ptr_t;
+#endif
+
+typedef struct
+{
+	u8_l func;
+	u8_l cnt;
+	u8_l reserved[2];
+	u32_l usrdata[3]; // 3 words totally
+} cmd_ef_usrdata_t;
+
+#define CMD_MAXARGS 10
+#define POWER_LEVEL_INVALID_VAL     (127)
+
+#if 0//#include <linux/ctype.h>
+#define isblank(c)		((c) == ' ' || (c) == '\t')
+#define isascii(c)		(((unsigned char)(c)) <= 0x7F)
+
+static int isdigit(unsigned char c)
+{
+	return ((c >= '0') && (c <='9'));
+}
+
+static int isxdigit(unsigned char c)
+{
+	if ((c >= '0') && (c <='9'))
+		return 1;
+	if ((c >= 'a') && (c <='f'))
+		return 1;
+	if ((c >= 'A') && (c <='F'))
+		return 1;
+	return 0;
+}
+
+static int islower(unsigned char c)
+{
+	return ((c >= 'a') && (c <='z'));
+}
+
+static unsigned char toupper(unsigned char c)
+{
+	if (islower(c))
+		c -= 'a'-'A';
+	return c;
+}
+#endif
+
+static int parse_line (char *line, char *argv[])
+{
+	int nargs = 0;
+
+	while (nargs < CMD_MAXARGS) {
+		/* skip any white space */
+		while ((*line == ' ') || (*line == '\t')) {
+			++line;
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		/* Argument include space should be bracketed by quotation mark */
+		if (*line == '\"') {
+			/* Skip quotation mark */
+			line++;
+
+			/* Begin of argument string */
+			argv[nargs++] = line;
+
+			/* Until end of argument */
+			while (*line && (*line != '\"')) {
+				++line;
+			}
+		} else {
+			argv[nargs++] = line;    /* begin of argument string    */
+
+			/* find end of string */
+			while (*line && (*line != ' ') && (*line != '\t')) {
+				++line;
+			}
+		}
+
+		if (*line == '\0') {    /* end of line, no more args    */
+			argv[nargs] = 0;
+			return nargs;
+		}
+
+		*line++ = '\0';         /* terminate current arg     */
+	}
+
+	printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
+
+	return nargs;
+}
+
+unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned int result = 0, value, is_neg = 0;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	if (*cp == '-') {
+		is_neg = 1;
+		cp++;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (is_neg)
+		result = (unsigned int)((int)result * (-1));
+
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+/*
+ * aic_priv_cmd handers.
+ */
+static int aic_priv_cmd_set_tx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_settx_t settx_param;
+#ifdef CONFIG_POWER_LIMIT
+	int8_t max_pwr;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+	txpwr_loss_conf_t *txpwr_loss;
+	txpwr_loss = &txpwr_loss_tmp;
+#endif
+
+	if (argc < 6)
+		return -EINVAL;
+
+	settx_param.chan = command_strtoul(argv[1], NULL, 10);
+	settx_param.bw = command_strtoul(argv[2], NULL, 10);
+	settx_param.mode = command_strtoul(argv[3], NULL, 10);
+	settx_param.rate = command_strtoul(argv[4], NULL, 10);
+	settx_param.length = command_strtoul(argv[5], NULL, 10);
+	if (argc > 6) {
+		settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
+	} else {
+		settx_param.tx_intv_us = 10000; // set default val 10ms
+	}
+	settx_param.max_pwr = POWER_LEVEL_INVALID_VAL;
+	AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
+		settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
+
+#ifdef CONFIG_POWER_LIMIT
+	txpwr_loss = &txpwr_loss_tmp;
+	get_userconfig_txpwr_loss(txpwr_loss);
+	if (txpwr_loss->loss_enable_2g4 == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+					txpwr_loss->loss_value_2g4);
+	if (txpwr_loss->loss_enable_5g == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+	max_pwr = get_powerlimit_by_chnum(settx_param.chan);
+	if (settx_param.chan >= 36) {
+		if (txpwr_loss->loss_enable_5g == 1)
+			max_pwr -= txpwr_loss->loss_value_5g;
+	} else {
+		if (txpwr_loss->loss_enable_2g4 == 1)
+			max_pwr -= txpwr_loss->loss_value_2g4;
+	}
+	settx_param.max_pwr = max_pwr;
+	AICWFDBG(LOGINFO, "max_pwr:%d\n", settx_param.max_pwr);
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_txstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_rx_t setrx_param;
+
+	if (argc < 3) {
+		return -EINVAL;
+	}
+	setrx_param.chan = command_strtoul(argv[1], NULL, 10);
+	setrx_param.bw = command_strtoul(argv[2], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_rx_result (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	return 8;
+}
+
+static int aic_priv_cmd_set_rxstop (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_tx_tone (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	u8_l buf[2];
+	s8_l freq_ = 0;
+
+	AICWFDBG(LOGINFO, "%s argc:%d\n", argv[0], argc);
+	if ((argc == 2) || (argc == 3)) {
+		AICWFDBG(LOGINFO, "argv 1:%s\n",argv[1]);
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		if (argc == 3) {
+			AICWFDBG(LOGINFO, "argv 2:%s\n",argv[2]);
+			freq_ = (u8_l)command_strtoul(argv[2], NULL, 10);
+		} else {
+			freq_ = 0;
+		};
+		buf[0] = func;
+		buf[1] = (u8_l)freq_;
+		rwnx_send_rftest_req(rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_rx_meter (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	s8_l freq = 0;
+
+	freq = (int)command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_RX_METER, sizeof(freq), (u8_l *)&freq, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_set_power (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l ana_pwr;
+	u8_l dig_pwr;
+	u8_l pwr;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801) {
+		ana_pwr = command_strtoul(argv[1], NULL, 16);
+		dig_pwr = command_strtoul(argv[2], NULL, 16);
+		pwr = (ana_pwr << 4 | dig_pwr);
+		if (ana_pwr > 0xf || dig_pwr > 0xf)
+			return -EINVAL;
+	} else {
+		ana_pwr = command_strtoul(argv[1], NULL, 10);
+		pwr = ana_pwr;
+		if (ana_pwr > 0x1e)
+			return -EINVAL;
+	}
+	AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
+	rwnx_send_rftest_req(rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_xtal_cap (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_xtal_cap_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l xtal_cap_fine;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
+	rwnx_send_rftest_req(rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_efuse_block (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_getefuse_t getefuse_param;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	getefuse_param.block = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, GET_EFUSE_BLOCK, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
+	AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_set_freq_cal_fine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setfreq_t cmd_setfreq;
+
+	if (argc < 2)
+		return -EINVAL;
+
+	cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
+	rwnx_send_rftest_req(rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_get_freq_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l val;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	val = cfm.rftest_result[0];
+	if (dev->chipid != PRODUCT_ID_AIC8801) {
+		AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
+				val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
+	} else {
+		AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
+	}
+	return 4;
+}
+
+static int aic_priv_cmd_set_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l mac_addr[6];
+
+	if (argc < 7)
+		return -EINVAL;
+
+	mac_addr[5] = command_strtoul(argv[1], NULL, 16);
+	mac_addr[4] = command_strtoul(argv[2], NULL, 16);
+	mac_addr[3] = command_strtoul(argv[3], NULL, 16);
+	mac_addr[2] = command_strtoul(argv[4], NULL, 16);
+	mac_addr[1] = command_strtoul(argv[5], NULL, 16);
+	mac_addr[0] = command_strtoul(argv[6], NULL, 16);
+	AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
+	rwnx_send_rftest_req(rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_bt_mac_addr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u32_l addr0, addr1;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 8);
+	addr0 = cfm.rftest_result[0];
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
+		addr1 = cfm.rftest_result[1] & 0x0000FFFF;
+		AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
+	} else {
+		addr1 = cfm.rftest_result[1];
+		AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
+	}
+	return 8;
+}
+
+static int aic_priv_cmd_set_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l vendor_info;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	vendor_info = command_strtoul(argv[1], NULL, 16);
+	AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
+	rwnx_send_rftest_req(rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_get_vendor_info (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	rwnx_send_rftest_req(rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) {
+		memcpy(command, &cfm.rftest_result[0], 2);
+		return 2;
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 1);
+		return 1;
+	}
+	AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
+}
+
+static int aic_priv_cmd_rdwr_pwrmm (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	if (argc <= 1) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
+	} else { // write
+		u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
+		pwrmm = (pwrmm) ? 1 : 0;
+		AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_pwridx (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid != PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+		}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr idx
+		if (argc > 3) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, type, pwridx};
+			AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 9);
+	return 9;
+}
+
+static int aic_priv_cmd_rdwr_pwrlvl (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (dev->chipid == PRODUCT_ID_AIC8801){
+		AICWFDBG(LOGERROR, "unsupported cmd\n");
+		return -EINVAL;
+	}
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr lvl
+		if (argc > 4) {
+			u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l idx, size;
+			u8_l buf[14] = {func, grp,};
+			if (argc > 12) { // set all grp
+			AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+				   "  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
+				if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
+					size = 10;
+				} else {
+					size = 12;
+				}
+				for (idx = 0; idx < size; idx++) {
+					s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
+					buf[2 + idx] = (u8_l)pwrlvl;
+					if (idx && !(idx & 0x3)) {
+						AICWFDBG(LOGINFO, " ");
+					}
+					AICWFDBG(LOGINFO, " %2d", pwrlvl);
+				}
+				AICWFDBG(LOGINFO, "\n");
+				size += 2;
+			} else { // set grp[idx]
+				u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
+				s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
+				buf[2] = idx;
+				buf[3] = (u8_l)pwrlvl;
+				size = 4;
+				AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
+					   "  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
+			}
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
+		} else {
+		AICWFDBG(LOGERROR, "wrong args\n");
+		return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if(dev->chipid == PRODUCT_ID_AIC8800D80 || dev->chipid == PRODUCT_ID_AIC8800D80X2){
+		memcpy(command, &cfm.rftest_result[0], 6 * 12);
+		return (6 * 12);
+	} else {
+		memcpy(command, &cfm.rftest_result[0], 3 * 12);
+		return (3 * 12);
+	}
+}
+
+static int aic_priv_cmd_rdwr_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if ((argc > 4) && (dev->chipid == PRODUCT_ID_AIC8800D80 || dev->chipid == PRODUCT_ID_AIC8800D80X2)) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && (dev->chipid != PRODUCT_ID_AIC8800D80) && (dev->chipid != PRODUCT_ID_AIC8800D80X2)) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
+		res_len = 3;
+	} else if (dev->chipid == PRODUCT_ID_AIC8800D80 || dev->chipid == PRODUCT_ID_AIC8800D80X2) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = 3 * 3 + 3 * 6;
+	} else {
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set drvibit:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 16);
+	return 16;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	int res_len = 0;
+#ifdef AICWF_SDIO_SUPPORT
+	struct aic_sdio_dev *dev = g_rwnx_plat->sdiodev;
+#endif
+#ifdef AICWF_USB_SUPPORT
+	struct aic_usb_dev *dev = g_rwnx_plat->usbdev;
+#endif
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if ((argc > 4) && (dev->chipid == PRODUCT_ID_AIC8800D80 || dev->chipid == PRODUCT_ID_AIC8800D80X2)) {
+			u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
+			u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else if ((argc > 3) && (dev->chipid != PRODUCT_ID_AIC8800D80) && (dev->chipid != PRODUCT_ID_AIC8800D80X2)) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	if ((dev->chipid == PRODUCT_ID_AIC8800DC) || (dev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
+		res_len = 3 * 2;
+	} else if (dev->chipid == PRODUCT_ID_AIC8800D80 || dev->chipid == PRODUCT_ID_AIC8800D80X2) { // 3 * 2 (2.4g) + 3 * 6 (5g)
+		res_len = (3 * 3 + 3 * 6) * 2;
+	} else { // 7 = 3(2.4g) + 4(5g)
+		res_len = 3 + 4;
+	}
+	memcpy(command, &cfm.rftest_result[0], res_len);
+	return res_len;
+}
+
+static int aic_priv_cmd_rdwr_efuse_pwrofstfine (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
+	} else if (func <= 2) { // write 2.4g/5g pwr ofst
+		if (argc > 3) {
+			u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
+			s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
+			u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
+			AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 7);
+	return 7;
+}
+
+static int aic_priv_cmd_rdwr_efuse_drvibit (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
+	} else if (func == 1) { // write 2.4g pa drv_ibit
+		if (argc > 2) {
+		u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+		u8_l buf[2] = {func, ibit};
+		AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usrdata (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_ef_usrdata_t cmd_ef_usrdata;
+
+	if (argc <= 1) { // read all
+		cmd_ef_usrdata.func = 0;
+		cmd_ef_usrdata.cnt = 3;
+	} else if (argc >= 2) { // read/write
+		cmd_ef_usrdata.func = (u8_l)command_strtoul(argv[1], NULL, 10);
+		cmd_ef_usrdata.cnt = (u8_l)command_strtoul(argv[2], NULL, 10);
+		if (cmd_ef_usrdata.func == 1) {
+			int idx;
+			for (idx = 0; idx < cmd_ef_usrdata.cnt; idx++) {
+				cmd_ef_usrdata.usrdata[idx] = (u32_l)command_strtoul(argv[3 + idx], NULL, 16);
+			}
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong argc: %x\n", argc);
+		return -EINVAL;
+	}
+	rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USRDATA, sizeof(cmd_ef_usrdata), (u8_l *)&cmd_ef_usrdata, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 12);
+	return 12;
+}
+
+static int aic_priv_cmd_rdwr_efuse_sdiocfg (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
+	} else if (func == 1) { // write sdiocfg
+		if (argc > 2) {
+			u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[2] = {func, ibit};
+			AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_usbvidpid (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	AICWFDBG(LOGINFO, "read/write usb vid/pid into efuse\n");
+	if (argc > 1) {
+		func = (u8_l)command_strtoul(argv[1], NULL, 16);
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, 0, NULL, &cfm);
+	} else if (func == 1) { // write USB vid+pid
+		if (argc > 2) {
+			u32_l usb_id = (u32_l)command_strtoul(argv[2], NULL, 16);
+			u8_l buf[5] = {func, (u8_l)usb_id, (u8_l)(usb_id >> 8), (u8_l)(usb_id >> 16), (u8_l)(usb_id >> 24)};
+			AICWFDBG(LOGINFO, "set efuse usb vid/pid:[%x]=%x\r\n", func, usb_id);
+			rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_USBVIDPID, sizeof(buf), buf, &cfm);
+		} else {
+			AICWFDBG(LOGERROR, "wrong args\n");
+			return -EINVAL;
+		}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 4);
+	return 4;
+}
+
+static int aic_priv_cmd_rdwr_efuse_he_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+
+	func = command_strtoul(argv[1], NULL, 10);
+	AICWFDBG(LOGINFO, "set he off: %d\n", func);
+	if(func == 1 || func == 0) {
+		rwnx_send_rftest_req(rwnx_hw, RDWR_EFUSE_HE_OFF, sizeof(func), (u8_l *)&func, &cfm);
+		AICWFDBG(LOGINFO, "he_off cfm: %d\n", cfm.rftest_result[0]);
+		memcpy(command, &cfm.rftest_result[0], 4);
+		return 4;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_cal_xtal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_CAL_XTAL, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cal_xtal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, GET_CAL_XTAL_RES, 0, NULL, &cfm);
+	memcpy(command, &cfm.rftest_result[0], 4);
+	AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
+	return 4;
+}
+
+static int aic_priv_cmd_set_cob_cal (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	cmd_rf_setcobcal_t setcob_cal;
+
+	if (argc < 3)
+		return -EINVAL;
+	setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
+	setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
+	setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_get_cob_cal_res (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cob_result_ptr_t *cob_result_ptr;
+
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_do_cob_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l state;
+	cmd_rf_setcobcal_t setcob_cal;
+	cob_result_ptr_t *cob_result_ptr;
+
+	setcob_cal.dutid = 1;
+	setcob_cal.chip_num = 1;
+	setcob_cal.dis_xtal = 0;
+	if (argc > 1)
+		setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
+	rwnx_send_rftest_req(rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
+	msleep(2000);
+	rwnx_send_rftest_req(rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
+	state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
+	if (!state){
+		AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
+		cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
+		cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
+		AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
+		cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
+		cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
+		memcpy(command, &cfm.rftest_result, 16);
+		return 16;
+	} else {
+		AICWFDBG(LOGERROR, "cob not idle\n");
+		return -EINVAL;
+	}
+}
+
+static int aic_priv_cmd_set_papr (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "papr %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_PAPR, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_notch (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "notch %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_NOTCH, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_srrc (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "srrc %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_SRRC, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_fss (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "fss %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_FSS, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_usb_off (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	rwnx_send_rftest_req(rwnx_hw, SET_USB_OFF, 0, NULL, NULL);
+	return 0;
+}
+
+static int aic_priv_cmd_set_pll_test (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0, tx_pwr = 0xc;
+	s8_l freq = 0;
+
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 16);
+	}
+	if (argc > 3) {
+		freq = (s8_l)command_strtoul(argv[2], NULL, 10);
+		tx_pwr = command_strtoul(argv[3], NULL, 16);
+	}
+	if (func <= 1) {
+		u8_l buf[3] = {func, (u8_l)freq, tx_pwr};
+		AICWFDBG(LOGINFO, "set pll_test %d: freq=%d, tx_pwr=0x%x\n", func, freq, tx_pwr);
+		rwnx_send_rftest_req(rwnx_hw, SET_PLL_TEST, sizeof(buf), buf, &cfm);
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_get_txpwr(struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	s8_l power=0;
+	power = get_txpwr_max(power);
+	memcpy(command, &power, 1);
+	return 1;
+}
+
+static int aic_priv_cmd_set_txpwr_loss(struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	s8_l func;
+	if (argc > 1) {
+		func = (s8_l)command_strtoul(argv[1], NULL, 10);
+		printk("set txpwr loss: %d\n", func);
+		if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+			set_txpwr_loss_ofst(func);
+			rwnx_send_txpwr_lvl_v3_req(g_rwnx_plat->sdiodev->rwnx_hw);
+		}else if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+			set_txpwr_loss_ofst(func);
+			rwnx_send_txpwr_lvl_req(g_rwnx_plat->sdiodev->rwnx_hw);
+		}else{
+			AICWFDBG(LOGINFO,"error:don't support 8800D");
+		}
+	} else {
+		printk("wrong args\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_set_ant_mode (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc > 1) {
+		func = command_strtoul(argv[1], NULL, 10);
+		AICWFDBG(LOGINFO, "ant %d\r\n", func);
+		rwnx_send_rftest_req(rwnx_hw, SET_ANT_MODE, sizeof(func), (u8_l *)&func, NULL);
+	} else {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int aic_priv_cmd_rdwr_bt_efuse_pwrofst (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	u8_l func = 0;
+	if (argc == 1) {
+		func = 0;
+	} else if (argc == 2) {
+		func = 1;
+	}
+	if (func == 0) { // read cur
+		rwnx_send_rftest_req(rwnx_hw, RDWR_BT_EFUSE_PWROFST, 0, NULL, &cfm);
+	} else if (func == 1) { // write bt tx pwrofst
+			int8_t bt_txpwrofst = command_strtoul(argv[1], NULL, 10);
+			AICWFDBG(LOGINFO, "set bt efuse pwrofst %d\r\n",bt_txpwrofst);
+			if (bt_txpwrofst < -7 ||  bt_txpwrofst > 7) {
+				AICWFDBG(LOGERROR, "wrong params %d,  pwrofst limit -7 ~ 7\n", bt_txpwrofst);
+				return -EINVAL;
+			} else {
+				rwnx_send_rftest_req(rwnx_hw, RDWR_BT_EFUSE_PWROFST, sizeof(bt_txpwrofst), &bt_txpwrofst, &cfm);
+			}
+	} else {
+		AICWFDBG(LOGERROR, "wrong func: %x\n", func);
+		return -EINVAL;
+	}
+	memcpy(command, &cfm.rftest_result[0], 2);
+	return 2;
+}
+
+static int aic_priv_cmd_help (struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command)
+{
+	print_help(argc > 0 ? argv[0] : NULL);
+	return 0;
+}
+
+struct aic_priv_cmd {
+	const char *cmd;
+	int (*handler)(struct rwnx_hw *rwnx_hw, int argc, char *argv[], char *command);
+	const char *usage;
+};
+
+static const struct aic_priv_cmd aic_priv_commands[] = {
+	{ "set_tx", aic_priv_cmd_set_tx,
+	  "<chan> <bw> <mode> <rate> <length> <interval>" },
+	{ "set_txstop", aic_priv_cmd_set_txstop,
+	  "= stop tx " },
+	{ "set_rx", aic_priv_cmd_set_rx,
+	  "<chan_num> <bw> " },
+	{ "get_rx_result", aic_priv_cmd_get_rx_result,
+	  "= display rx fcsok/total pkt num" },
+	{ "set_rxstop", aic_priv_cmd_set_rxstop,
+	  "= stop rx " },
+	{ "set_txtone", aic_priv_cmd_set_tx_tone,
+	  "<val> val = 0/off" },
+	{ "set_rx_meter", aic_priv_cmd_set_rx_meter,
+	  "= set rx meter " },
+	{ "set_power", aic_priv_cmd_set_set_power,
+	  "<dec val> " },
+	{ "set_xtal_cap", aic_priv_cmd_set_xtal_cap,
+	  "<dec val> [0 ~ 31]" },
+	{ "set_xtal_cap_fine", aic_priv_cmd_set_xtal_cap_fine,
+	  "<dec val> [0 ~ 63]" },
+	{ "get_efuse_block", aic_priv_cmd_get_efuse_block,
+	  "<val>" },
+	{ "set_freq_cal", aic_priv_cmd_set_freq_cal,
+	  "<hex val>" },
+	{ "set_freq_cal_fine", aic_priv_cmd_set_freq_cal_fine,
+	  "<hex val>" },
+	{ "get_freq_cal", aic_priv_cmd_get_freq_cal,
+	  "= display cap & cap fine" },
+	{ "set_mac_addr", aic_priv_cmd_set_mac_addr,
+	  "= write WiFi MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_mac_addr", aic_priv_cmd_get_mac_addr,
+	  "= display WiFi MAC stored in efuse or flash" },
+	{ "set_bt_mac_addr", aic_priv_cmd_set_bt_mac_addr,
+	  "= write BT MAC into efuse or flash is limited to a maximum of two times" },
+	{ "get_bt_mac_addr", aic_priv_cmd_get_bt_mac_addr,
+	  "= display BT MAC stored in efuse or flash" },
+	{ "set_vendor_info", aic_priv_cmd_set_vendor_info,
+	  "= write vendor info into efuse or flash is allowed only once" },
+	{ "get_vendor_info", aic_priv_cmd_get_vendor_info,
+	  "= display vendor info stored in efuse or flash" },
+	{ "rdwr_pwrmm", aic_priv_cmd_rdwr_pwrmm,
+	  "<val> = 0/rdwr_pwrlvl, 1/set_power = read/write txpwr manul mode" },
+	{ "rdwr_pwridx", aic_priv_cmd_rdwr_pwridx,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrlvl", aic_priv_cmd_rdwr_pwrlvl,
+	  "<band> <mod> <idx>" },
+	{ "rdwr_pwrofst", aic_priv_cmd_rdwr_pwrofst,
+	  "<band> <rate> <ch> <ofst>" },
+	{ "rdwr_pwrofstfine", aic_priv_cmd_rdwr_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine>" },
+	{ "rdwr_drvibit", aic_priv_cmd_rdwr_drvibit,
+	  "<func> <val> read/write 8800D pa drvibit" },
+	{ "set_cal_xtal", aic_priv_cmd_set_cal_xtal,
+	  "= set cal xtal" },
+	{ "get_cal_xtal_res", aic_priv_cmd_get_cal_xtal_res,
+	  "= get cal xtal result cap & cap_fine" },
+	{ "set_cob_cal", aic_priv_cmd_set_cob_cal,
+	  "<dutid> <chip_num> <disxtal> = dut cob test" },
+	{ "get_cob_cal_res", aic_priv_cmd_get_cob_cal_res,
+	  "= get cob cal result" },
+	{ "do_cob_test", aic_priv_cmd_do_cob_test,
+	  "<func> = 0/xtal, 1/dis_xtal, 2/only_xtal" },
+	{ "rdwr_efuse_pwrofst", aic_priv_cmd_rdwr_efuse_pwrofst,
+	  "<band> <rate> <ch> <ofst> limited to a maximum of two times" },
+	{ "rdwr_efuse_pwrofstfine", aic_priv_cmd_rdwr_efuse_pwrofstfine,
+	  "<band> <rate> <ch> <ofstfine> limited to a maximum of two times" },
+	{ "rdwr_efuse_drvibit", aic_priv_cmd_rdwr_efuse_drvibit,
+	  "<func> <val> = read/write 8800D efuse pa drvibitis allowed only once" },
+	{ "rdwr_efuse_usrdata", aic_priv_cmd_rdwr_efuse_usrdata,
+	  "<func> <val> = read/write efuse usrdata" },
+	{ "rdwr_efuse_sdiocfg", aic_priv_cmd_rdwr_efuse_sdiocfg,
+	  "<func> <val> = read/write sdiocfg_bit into efuse" },
+	{ "rdwr_efuse_usbvidpid", aic_priv_cmd_rdwr_efuse_usbvidpid,
+	  "<func> <val> = read/write usb vid/pid into efuse" },
+	{ "rdwr_efuse_he_off", aic_priv_cmd_rdwr_efuse_he_off,
+	  "<func> = read/write he_off into efuse" },
+	{ "set_papr", aic_priv_cmd_set_papr,
+	  "<val> = configure papr filter to optimize sideband suppression" },
+	{ "set_notch", aic_priv_cmd_set_notch,
+	  "<val> = configure filter to optimize sideband suppression" },
+	{ "set_srrc", aic_priv_cmd_set_srrc,
+	  "<func> = disable/enable sideband suppression for SRRC" },
+	{ "set_fss", aic_priv_cmd_set_fss,
+	  "<func> = disable/enable treatment of spurious emissions and burrs" },
+	{ "set_usb_off", aic_priv_cmd_set_usb_off,
+	  "= off usb configure before usb disconnect" },
+	{ "set_pll_test", aic_priv_cmd_set_pll_test,
+	  "<func> <freq> <tx_pwr> = use pll test to measure saturation power" },
+	{ "get_txpwr", aic_priv_cmd_get_txpwr,
+	  "= get userconfig max txpwr" },
+	{ "set_txpwr_loss",aic_priv_cmd_set_txpwr_loss,
+	  "<val> = txpwr will change ,val can be negative" },
+	{ "set_ant", aic_priv_cmd_set_ant_mode,
+	  "<val> = 0/ant0, 1/ant1, 2/both" },
+	{ "rdwr_bt_efuse_pwrofst", aic_priv_cmd_rdwr_bt_efuse_pwrofst,
+	  "<pwrofst> = read/write bt tx power offset into efuse" },
+//Reserve for new aic_priv_cmd.
+	{ "help", aic_priv_cmd_help,
+	  "= show usage help" },
+	{ NULL, NULL, NULL }
+
+};
+
+
+/*
+ * Prints command usage, lines are padded with the specified string.
+ */
+static void print_help(const char *cmd)
+{
+	int n;
+	printk("commands:\n");
+	for (n = 0; aic_priv_commands[n].cmd; n++) {
+		if (cmd != NULL)
+			printk("%s %s\n", aic_priv_commands[n].cmd, aic_priv_commands[n].usage);
+	}
+}
+
+int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
+{
+	const struct aic_priv_cmd *cmd, *match = NULL;
+	int count;
+	int bytes_written = 0;
+	char *argv[CMD_MAXARGS + 1];
+	int argc;
+	struct rwnx_vif *vif = container_of(net->ieee80211_ptr, struct rwnx_vif, wdev);
+	struct rwnx_hw *p_rwnx_hw = vif->rwnx_hw;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	if(!testmode) {
+		AICWFDBG(LOGERROR, "not in testmdoe\n");
+		return -1;
+	}
+	argc = parse_line(command, argv);
+	if (argc == 0) {
+		return -1;
+	}
+
+	count = 0;
+	cmd = aic_priv_commands;
+	while (cmd->cmd) {
+		if (strncasecmp(cmd->cmd, argv[0], strlen(argv[0])) == 0)
+		{
+			match = cmd;
+			if (strcasecmp(cmd->cmd, argv[0]) == 0) {
+				/* we have an exact match */
+				count = 1;
+				break;
+			}
+			count++;
+		}
+		cmd++;
+	}
+
+	if (count > 1) {
+		AICWFDBG(LOGINFO, "Ambiguous command '%s'; possible commands:", argv[0]);
+		cmd = aic_priv_commands;
+		while (cmd->cmd) {
+			if (strncasecmp(cmd->cmd, argv[0],
+					   strlen(argv[0])) == 0) {
+				AICWFDBG(LOGINFO, " %s", cmd->cmd);
+			}
+			cmd++;
+		}
+		AICWFDBG(LOGINFO, "\n");
+	} else if (count == 0) {
+		AICWFDBG(LOGERROR, "Unknown command '%s'\n", argv[0]);
+	} else {
+		AICWFDBG(LOGINFO, "match %s", match->cmd);
+		bytes_written = match->handler(p_rwnx_hw, argc, &argv[0], command);
+	}
+
+	if (bytes_written < 0)
+		AICWFDBG(LOGERROR, "wrong param\n");
+
+	return bytes_written;
+}
+
+#define RWNX_COUNTRY_CODE_LEN 2
+#define CMD_SET_COUNTRY "COUNTRY"
+#define CMD_SET_VENDOR_EX_IE "SET_VENDOR_EX_IE"
+#define CMD_SET_AP_WPS_P2P_IE "SET_AP_WPS_P2P_IE"
+#define CMD_SETSUSPENDMODE "SETSUSPENDMODE"
+#define CMD_SET_MON_FREQ	"SET_MON_FREQ"
+
+struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
+struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
+extern int reg_regdb_size;
+
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+extern u8_l vendor_extension_data[256];
+extern int vendor_extension_len;
+extern int testmode = 0;
+
+void set_vendor_extension_ie(char *command){
+
+	char databyte[3]={0x00, 0x00, 0x00};
+	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
+	int command_index = skip;
+	int data_index = 0;
+
+	memset(vendor_extension_data, 0, 256);
+	vendor_extension_len = 0;
+	memcpy(databyte, command + command_index, 2);
+	vendor_extension_len = command_strtoul(databyte, NULL, 16);
+	printk("%s len:%d \r\n", __func__, vendor_extension_len);
+
+	//parser command and save data in vendor_extension_data
+	for(data_index = 0;data_index < vendor_extension_len; data_index++){
+		command_index = command_index + 3;
+		memcpy(databyte, command + command_index, 2);
+		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
+	}
+
+}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+int rwnx_cfg80211_set_monitor_channel_(struct wiphy *wiphy,
+                                             struct cfg80211_chan_def *chandef);
+int rwnx_atoi2(char *value, int c_len);
+void set_mon_chan(struct rwnx_vif *vif, char *parameter){
+    struct cfg80211_chan_def *chandef = NULL;
+    int freq = 0;
+    
+    
+    chandef = (struct cfg80211_chan_def *)vmalloc(sizeof(struct cfg80211_chan_def));
+    memset(chandef, 0, sizeof(struct cfg80211_chan_def));
+    chandef->chan = (struct ieee80211_channel *)vmalloc(sizeof(struct ieee80211_channel));
+    memset(chandef->chan, 0, sizeof(struct ieee80211_channel));
+    
+    freq = rwnx_atoi2(parameter, 4);
+
+    if(freq <= 2484){
+        chandef->chan->band = NL80211_BAND_2GHZ;
+    }else{
+        chandef->chan->band = NL80211_BAND_5GHZ;
+    }
+    chandef->chan->center_freq = freq;
+    chandef->width = NL80211_CHAN_WIDTH_20;
+    chandef->center_freq1 = chandef->chan->center_freq;
+    chandef->center_freq2 = 0;
+
+    rwnx_cfg80211_set_monitor_channel_(vif->rwnx_hw->wiphy, chandef);
+
+    vfree(chandef->chan);
+    vfree(chandef);
+
+}
+
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+#define PRIVATE_COMMAND_MAX_LEN 8192
+#define PRIVATE_COMMAND_DEF_LEN 4096
+
+	struct rwnx_vif *vif = netdev_priv(net);
+	int ret = 0;
+	char *command = NULL;
+	int bytes_written = 0;
+	android_wifi_priv_cmd priv_cmd;
+	int buf_size = 0;
+	int skip = 0;
+	char *country = NULL;
+#ifdef CONFIG_GPIO_WAKEUP
+	int setsusp_mode;
+#endif
+	struct ieee80211_regdomain *regdomain;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	///todo: add our lock
+	//net_os_wake_lock(net);
+
+
+/*	if (!capable(CAP_NET_ADMIN)) {
+		ret = -EPERM;
+		goto exit;
+	}*/
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+			goto exit;
+		}
+	}
+	if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
+		printk("%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
+	command = kmalloc((buf_size + 1), GFP_KERNEL);
+
+	if (!command) {
+		printk("%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	command[priv_cmd.total_len] = '\0';
+
+	/* outputs */
+	AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
+	AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
+	AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
+
+#if 1//Handle Android command
+		if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
+			skip = strlen(CMD_SET_COUNTRY) + 1;
+			country = command + skip;
+			if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
+				printk("%s: invalid country code\n", __func__);
+				ret = -EINVAL;
+				goto exit;
+			}
+#if 0
+			for(index = 0; index < reg_regdb_size; index++){
+				regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
+				if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+					printk("regulatory_set_wiphy_regd fail \r\n");
+				}else{
+					printk("regulatory_set_wiphy_regd ok \r\n");
+				}
+			}
+#endif
+			AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
+			regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
+				printk("regulatory_set_wiphy_regd fail \r\n");
+			}
+#else
+			wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
+#endif
+#ifdef CONFIG_POWER_LIMIT
+			if (vif->rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+				rwnx_plat_powerlimit_load_8800d80(vif->rwnx_hw);
+			if (!testmode)
+				rwnx_send_me_chan_config_req(vif->rwnx_hw);
+#endif
+			ret = 0;
+			goto exit;
+		}
+#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
+		else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
+			set_vendor_extension_ie(command);
+			ret = 0;
+			goto exit;
+		}
+#endif//CONFIG_SET_VENDOR_EXTENSION_IE
+		else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
+			ret = 0;
+			goto exit;
+		}
+		else if(!strncasecmp(command, CMD_SETSUSPENDMODE, strlen(CMD_SETSUSPENDMODE)) && testmode == 0){
+#ifdef AICWF_SDIO_SUPPORT           
+#if defined(CONFIG_GPIO_WAKEUP) && !defined(CONFIG_AUTO_POWERSAVE)
+			skip = strlen(CMD_SETSUSPENDMODE) + 1;
+			setsusp_mode = command_strtoul((command + skip), NULL, 10);
+#ifdef AICWF_LATENCY_MODE
+			if (setsusp_mode)
+				rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, setsusp_mode, 0);
+			else
+				rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1, 1);
+#else
+			rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, setsusp_mode, !setsusp_mode);
+#endif
+			#if 0
+			if (setsusp_mode == 1) {                
+#if defined(CONFIG_SDIO_PWRCTRL)                
+				aicwf_sdio_pwr_stctl(g_rwnx_plat->sdiodev, SDIO_SLEEP_ST);              
+#endif              
+				ret = aicwf_sdio_writeb(g_rwnx_plat->sdiodev, SDIOWIFI_WAKEUP_REG, 2);              
+				if (ret < 0) {                  
+					sdio_err("reg:%d write failed!\n", SDIOWIFI_WAKEUP_REG);                
+				}           
+			}           
+			#endif
+			AICWFDBG(LOGINFO, "set suspend mode %d\n", setsusp_mode);
+#endif//CONFIG_GPIO_WAKEUP  
+#endif
+			goto exit;
+		}
+#ifdef CONFIG_RWNX_MON_DATA
+        else if(!strncasecmp(command, CMD_SET_MON_FREQ, strlen(CMD_SET_MON_FREQ))){
+                char *set_parameter;
+                skip = strlen(CMD_SET_MON_FREQ) + 1;
+                set_parameter = command + skip;
+                set_mon_chan(vif, set_parameter);
+                ret = 0;
+                goto exit;
+        }
+#endif
+
+#endif//Handle Android command
+
+	bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
+			command[0] = '\0';
+		}
+		if (bytes_written >= priv_cmd.total_len) {
+			printk("%s: err. bytes_written:%d >= buf_size:%d \n",
+				__FUNCTION__, bytes_written, buf_size);
+			goto exit;
+		}
+		bytes_written++;
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+			printk("%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	} else {
+		/* Propagate the error */
+		ret = bytes_written;
+	}
+
+exit:
+	///todo: add our unlock
+	//net_os_wake_unlock(net);
+	kfree(command);
+	return ret;
+}
+
+#ifdef CONFIG_MCU_MESSAGE
+#define CMD_GET_VERSION_STR "GET_VERSION"
+#define CMD_GET_SSID_STR    "GET_SSID"
+#define CMD_SET_SSID_STR    "SET_SSID"
+#define CMD_GET_PASS_STR    "GET_PASS"
+#define CMD_SET_PASS_STR    "SET_PASS"
+#define CMD_GET_VAR_STR     "GET_VAR"
+#define CMD_SET_VAR_STR     "SET_VAR"
+
+enum custmsg_cmd_tag
+{
+	CUST_CMD_GET_VERSION = 0,
+	CUST_CMD_GET_SSID,
+	CUST_CMD_SET_SSID,
+	CUST_CMD_GET_PASS,
+	CUST_CMD_SET_PASS,
+	CUST_CMD_GET_VAR,
+	CUST_CMD_SET_VAR,
+	CUST_CMD_MAX
+};
+
+int handle_custom_msg(char *command, u32 cmd_len)
+{
+	int bytes_read = 0, max_bytes_to_read = 0;
+	struct rwnx_hw *p_rwnx_hw = NULL;
+	u32 cmd, len = 0, flags = 0;
+	char *buf = NULL;
+	struct dbg_custom_msg_cfm *cust_msg_cfm;
+	printk("cmd,%s,%ld\n",command,strlen(command));
+	if (strncasecmp(command, CMD_GET_VERSION_STR, strlen(CMD_GET_VERSION_STR)) == 0) {
+		cmd = CUST_CMD_GET_VERSION;
+		max_bytes_to_read = 32; // max str len for version
+	} else if (strncasecmp(command, CMD_GET_SSID_STR, strlen(CMD_GET_SSID_STR)) == 0) {
+		cmd = CUST_CMD_GET_SSID;
+		max_bytes_to_read = 48; // max str len for ssid
+	} else if (strncasecmp(command, CMD_SET_SSID_STR, strlen(CMD_SET_SSID_STR)) == 0) {
+		cmd = CUST_CMD_SET_SSID;
+		len = cmd_len - (strlen(CMD_SET_SSID_STR) + 1);
+		buf = command + (strlen(CMD_SET_SSID_STR) + 1);
+		max_bytes_to_read = 0;
+	} else if (strncasecmp(command, CMD_GET_PASS_STR, strlen(CMD_GET_PASS_STR)) == 0) {
+		cmd = CUST_CMD_GET_PASS;
+		max_bytes_to_read = 64; // max str len for PASS
+	} else if (strncasecmp(command, CMD_SET_PASS_STR, strlen(CMD_SET_PASS_STR)) == 0) {
+		cmd = CUST_CMD_SET_PASS;
+		len = cmd_len - (strlen(CMD_SET_PASS_STR) + 1);
+		buf = command + (strlen(CMD_SET_PASS_STR) + 1);
+		max_bytes_to_read = 0;
+	} else if (strncasecmp(command, CMD_GET_VAR_STR, strlen(CMD_GET_VAR_STR)) == 0) {
+		cmd = CUST_CMD_GET_VAR;
+		max_bytes_to_read = 64; // max str len for VAR
+	} else if (strncasecmp(command, CMD_SET_VAR_STR, strlen(CMD_SET_VAR_STR)) == 0) {
+		cmd = CUST_CMD_SET_VAR;
+		len = cmd_len - (strlen(CMD_SET_VAR_STR) + 1);
+		buf = command + (strlen(CMD_SET_VAR_STR) + 1);
+		max_bytes_to_read = 0;
+	} else {
+		printk("invalid cmd: %s\r\n", command);
+		return -1;
+	}
+	if (len < 0) {
+		printk("invalid len: %d\r\n", len);
+		return -3;
+	}
+	#ifdef AICWF_SDIO_SUPPORT
+	p_rwnx_hw = g_rwnx_plat->sdiodev->rwnx_hw;
+	#endif
+	#ifdef AICWF_USB_SUPPORT
+	p_rwnx_hw = g_rwnx_plat->usbdev->rwnx_hw;
+	#endif
+	cust_msg_cfm = (struct dbg_custom_msg_cfm *)kmalloc((offsetof(struct dbg_custom_msg_cfm, buf) + max_bytes_to_read), GFP_KERNEL);
+	if (cust_msg_cfm == NULL) {
+		printk("msg cfm alloc fail\r\n");
+		return -2;
+	}
+	rwnx_send_dbg_custom_msg_req(p_rwnx_hw, cmd, buf, len, flags, cust_msg_cfm);
+	bytes_read = cust_msg_cfm->len;
+	printk("Custom msg cfm: cmd=%d, len=%d, status=%x\n", cust_msg_cfm->cmd, bytes_read, cust_msg_cfm->status);
+	if (bytes_read) {
+		memcpy(command, cust_msg_cfm->buf, bytes_read);
+		command[bytes_read] = '\0';
+	} else {
+		command[0] = '\0';
+	}
+	if (cust_msg_cfm->status) {
+		printk("cfm status: %x", cust_msg_cfm->status);
+	}
+	return bytes_read;
+}
+
+int devipc_cust_msg(struct net_device *net, struct ifreq *ifr, int cmd)
+{
+#ifdef PRIVATE_COMMAND_MAX_LEN
+#undef PRIVATE_COMMAND_MAX_LEN
+#undef PRIVATE_COMMAND_DEF_LEN
+#define PRIVATE_COMMAND_MAX_LEN 8192
+#define PRIVATE_COMMAND_DEF_LEN 4096
+#endif
+	int ret = 0;
+	char *command = NULL;
+	int bytes_written = 0;
+	android_wifi_priv_cmd priv_cmd;
+	int buf_size = 0;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	///todo: add our lock
+	//net_os_wake_lock(net);
+
+
+/*	if (!capable(CAP_NET_ADMIN)) {
+		ret = -EPERM;
+		goto exit;
+	}*/
+	if (!ifr->ifr_data) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+			goto exit;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
+		ret = -EFAULT;
+		goto exit;
+		}
+	}
+	if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
+		printk("%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
+	command = kmalloc((buf_size + 1), GFP_KERNEL);
+
+	if (!command)
+	{
+		printk("%s: failed to allocate memory\n", __FUNCTION__);
+		ret = -ENOMEM;
+		goto exit;
+	}
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.used_len)) {
+		ret = -EFAULT;
+		goto exit;
+	}
+	command[priv_cmd.used_len] = '\0';
+
+	/* outputs */
+	printk("%s: Devipc custom msg \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
+	printk("cmd = %x\n", cmd);
+	printk("buf_size=%d\n", buf_size);
+
+
+	bytes_written = handle_custom_msg(command, priv_cmd.used_len);
+	if (bytes_written >= 0) {
+		if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
+		command[0] = '\0';
+		}
+		if (bytes_written >= priv_cmd.total_len) {
+			printk("%s: err. bytes_written:%d >= buf_size:%d \n",
+				__FUNCTION__, bytes_written, buf_size);
+			goto exit;
+		}
+		bytes_written++;
+		priv_cmd.used_len = bytes_written;
+		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
+			printk("%s: failed to copy data to user buffer\n", __FUNCTION__);
+			ret = -EFAULT;
+		}
+	}
+	else {
+		/* Propagate the error */
+		ret = bytes_written;
+	}
+
+exit:
+	///todo: add our unlock
+	//net_os_wake_unlock(net);
+	kfree(command);
+	Sreturn ret;
+}
+#endif
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
new file mode 100644
index 000000000000..265658ed1053
--- /dev/null
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_priv_cmd.h
@@ -0,0 +1,33 @@
+/**
+ ******************************************************************************
+ *
+ * @file private_cmd.h
+ *
+ * Copyright (C) Aicsemi 2018-2024
+ *
+ ******************************************************************************
+ */
+
+#ifndef _AIC_PRIV_CMD_H_
+#define _AIC_PRIV_CMD_H_
+
+#include "rwnx_defs.h"
+
+typedef struct _android_wifi_priv_cmd {
+    char *buf;
+    int used_len;
+    int total_len;
+} android_wifi_priv_cmd;
+
+#ifdef CONFIG_COMPAT
+typedef struct _compat_android_wifi_priv_cmd {
+    compat_caddr_t buf;
+    int used_len;
+    int total_len;
+} compat_android_wifi_priv_cmd;
+#endif /* CONFIG_COMPAT */
+
+int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd);
+
+#endif /* _AIC_PRIV_CMD_H_ */
+
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
index 0cc6d5a392b5..004a1a3cfdc9 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.c
@@ -9,6 +9,7 @@
 #include <linux/rtnetlink.h>
 #include <net/netlink.h>
 #include "rwnx_version_gen.h"
+#include "rwnx_msg_tx.h"
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 
@@ -27,6 +28,14 @@ static struct wifi_ring_buffer_status ring_buffer[] = {
 static struct wlan_driver_wake_reason_cnt_t wake_reason_cnt = {
 	.total_cmd_event_wake = 10,
 };
+
+#endif
+
+#ifdef CONFIG_APF
+#define AIC_APF_MEM_SIZE      2048
+#define AIC_APF_VERSION       4
+
+static char apfProgram[AIC_APF_MEM_SIZE];
 #endif
 
 int aic_dev_start_mkeep_alive(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
@@ -305,17 +314,37 @@ static int aicwf_vendor_subcmd_get_channel_list(struct wiphy *wiphy, struct wire
 	return -EMSGSIZE;
 }
 
+struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
+
 static int aicwf_vendor_subcmd_set_country_code(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
 	int ret = 0, rem, type;
 	const struct nlattr *iter;
+    struct ieee80211_regdomain *regdomain;
+    char *country = NULL;
+    struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 
 	nla_for_each_attr(iter, data, len, rem) {
 		type = nla_type(iter);
 		switch (type) {
 		case ANDR_WIFI_ATTRIBUTE_COUNTRY:
 			printk("%s(%d), ANDR_WIFI_ATTRIBUTE_COUNTRY: %s\n", __func__, __LINE__, (char *)nla_data(iter));
+            country = (char *)nla_data(iter);
+            
+            AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, 
+                country[0], 
+                country[1]);
+            
+            regdomain = getRegdomainFromRwnxDB(rwnx_hw->wiphy, country);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+            if((ret = regulatory_set_wiphy_regd(rwnx_hw->wiphy, regdomain))){
+                printk("regulatory_set_wiphy_regd fail \r\n");
+            }
+#else
+            wiphy_apply_custom_regulatory(rwnx_hw->wiphy, regdomain);
+#endif
+
 			break;
 		default:
 			pr_err("%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
@@ -382,6 +411,9 @@ static int aicwf_vendor_subcmd_get_feature_set(struct wiphy *wiphy, struct wirel
 	/*bit 21:WiFi mkeep_alive*/
 	feature |= WIFI_FEATURE_MKEEP_ALIVE;
 
+#ifdef AICWF_LATENCY_MODE
+	feature |= WIFI_FEATURE_SET_LATENCY_MODE;
+#endif
 	if (nla_put_u32(reply, ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET, feature)) {
 		wiphy_err(wiphy, "%s put u32 error\n", __func__);
 		goto out_put_fail;
@@ -578,7 +610,103 @@ static int aicwf_vendor_logger_get_wake_reason_stats(struct wiphy *wiphy, struct
 	return -EMSGSIZE;
 }
 
-static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+static int aicwf_vendor_logger_get_tx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+static int aicwf_vendor_logger_get_rx_pkt_fates(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+#if 0
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	int fate_num;
+	int fate_data;
+
+	AICWFDBG(LOGDEBUG, "%s Enter\r\n", __func__);
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case LOGGER_ATTRIBUTE_PKT_FATE_NUM:
+			fate_num = nla_get_u32(iter);
+			break;
+		case LOGGER_ATTRIBUTE_PKT_FATE_DATA:
+			fate_data = nla_get_u64(iter);
+			break;
+		default:
+			AICWFDBG(LOGERROR, "%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+#endif
+	/* TODO
+	 * Add handle in the future
+	 */
+	return 0;
+}
+
+
+#ifdef AICWF_LATENCY_MODE
+static int aicwf_vendor_subcmd_set_latency_mode(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void *data, int len)
+{
+	int err = 0, rem, type;
+	u32 latency_mode;
+	const struct nlattr *iter;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case ANDR_WIFI_ATTRIBUTE_LATENCY_MODE:
+			latency_mode = nla_get_u32(iter);
+			printk("%s,Setting latency mode %d\n", __func__, latency_mode);
+			#ifdef AICWF_SDIO_SUPPORT
+			if (latency_mode) {
+				rwnx_send_me_set_lp_level(rwnx_hw, 0, 1);
+			} else {
+				rwnx_send_me_set_lp_level(rwnx_hw, 1, 0);
+			}
+			#endif
+			break;
+		default:
+			pr_err("%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return err;
+		}
+	}
+
+	return err;
+}
+#endif
+
+static int aicwf_vendor_logger_start_pkt_fate_monitoring(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
 	/* TODO
@@ -587,6 +715,122 @@ static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct
 	return 0;
 }
 
+#ifdef CONFIG_APF
+static int aicwf_vendor_apf_subcmd_get_capabilities(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+	int ret;
+	struct sk_buff *reply;
+	uint32_t payload;
+	printk("%s\n", __func__);
+
+	/* APF_ATTRIBUTE_VERSION + APF_ATTRIBUTE_MAX_LEN */
+	payload = sizeof(u32) * 2;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put_u32(reply, APF_ATTRIBUTE_VERSION, AIC_APF_VERSION))
+		goto out_put_fail;
+
+	if (nla_put_u32(reply, APF_ATTRIBUTE_MAX_LEN, AIC_APF_MEM_SIZE))
+		goto out_put_fail;
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "reply cmd error\n");
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+static int aicwf_vendor_apf_set_filter(struct wiphy *wiphy, struct wireless_dev *wdev,
+	const void *data, int len)
+{
+	int ret = 0, rem, type;
+	const struct nlattr *iter;
+	unsigned int mProgramLen = 0;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+
+	printk("%s\n", __func__);
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+		case APF_ATTRIBUTE_PROGRAM_LEN:
+			memcpy(&mProgramLen, nla_data(iter), sizeof(unsigned int));
+			ret = (mProgramLen > 0 && mProgramLen <= AIC_APF_MEM_SIZE) ? 0 : -EINVAL;
+			break;
+		case APF_ATTRIBUTE_PROGRAM:
+			if (mProgramLen > AIC_APF_MEM_SIZE || mProgramLen == 0) {
+				printk("%s: apf program size invalid: %d (should > 0 and <= %d)\n",
+						__func__, mProgramLen, AIC_APF_MEM_SIZE);
+				return -EINVAL;
+			}
+
+			memcpy(apfProgram, nla_data(iter), mProgramLen);
+			ret = rwnx_send_set_apf_prog_req(rwnx_hw, apfProgram, mProgramLen);
+			break;
+		default:
+			pr_err("%s(%d), Unknown type: %d\n", __func__, __LINE__, type);
+			return -EINVAL;
+		}
+	}
+
+	return ret;
+}
+
+static int aicwf_vendor_apf_read_filter_data(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void *data, int len)
+{
+	struct sk_buff *reply;
+	int ret, payload, apf_mem_size;
+	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+
+	printk("%s\n", __func__);
+
+	apf_mem_size = AIC_APF_MEM_SIZE;
+	payload = sizeof(u32) + apf_mem_size;
+
+	ret = rwnx_send_get_apf_prog_req(rwnx_hw, apfProgram, apf_mem_size);
+	if (ret != 0) {
+		pr_err("%s, Failed to read apf mem from firmware, ret = %d\n", __func__, ret);
+		return ret;
+	}
+
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply)
+		return -ENOMEM;
+
+	ret = nla_put_u32(reply, APF_ATTRIBUTE_PROGRAM_LEN, apf_mem_size);
+	if (ret < 0) {
+		pr_err("%s, Failed to put APF_ATTRIBUTE_MAX_LEN, ret = %d\n", __func__, ret);
+		goto out_put_fail;
+	}
+
+	/* copy the full apf mem */
+	ret = nla_put(reply, APF_ATTRIBUTE_PROGRAM, apf_mem_size, &apfProgram[0]);
+	if (ret < 0) {
+		pr_err("%s, Failed to put APF_ATTRIBUTE_PROGRAM, ret = %d\n", __func__, ret);
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "reply cmd error\n");
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+#endif
+
 static int aicwf_vendor_sub_cmd_set_mac(struct wiphy *wiphy, struct wireless_dev *wdev,
 	const void *data, int len)
 {
@@ -641,6 +885,17 @@ aicwf_cfg80211_logger_policy[LOGGER_ATTRIBUTE_MAX + 1] = {
 	[LOGGER_ATTRIBUTE_RING_NAME] = { .type = NLA_STRING },
 };
 
+#ifdef CONFIG_APF
+static const struct nla_policy
+aicwf_cfg80211_apf_policy[APF_ATTRIBUTE_MAX + 1] = {
+	[0] = {.type = NLA_UNSPEC },
+	[APF_ATTRIBUTE_VERSION] = {.type = NLA_U32 },
+	[APF_ATTRIBUTE_MAX_LEN] = {.type = NLA_U32 },
+	[APF_ATTRIBUTE_PROGRAM] = { .type = NLA_BINARY },
+	[APF_ATTRIBUTE_PROGRAM_LEN] = { .type = NLA_U32 },
+};
+#endif
+
 static const struct nla_policy
 aicwf_cfg80211_subcmd_policy[GSCAN_ATTRIBUTE_MAX + 1] = {
 	[0] = {.type = NLA_UNSPEC },
@@ -845,6 +1100,7 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
 	},
+#ifdef CONFIG_APF
 	{
 		{
 			.vendor_id = GOOGLE_OUI,
@@ -855,6 +1111,74 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
 		.dumpit = aicwf_dump_interface,
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = aicwf_cfg80211_apf_policy,
+		.maxattr = APF_ATTRIBUTE_MAX,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = APF_SUBCMD_SET_FILTER
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_apf_set_filter,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = aicwf_cfg80211_apf_policy,
+		.maxattr = APF_ATTRIBUTE_MAX,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = APF_SUBCMD_READ_FILTER_DATA
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_apf_read_filter_data,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = aicwf_cfg80211_apf_policy,
+		.maxattr = APF_ATTRIBUTE_MAX
+#endif /* LINUX_VERSION >= 5.3 */
+	},
+#endif
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_START_PKT_FATE_MONITORING
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_start_pkt_fate_monitoring,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_TX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_tx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = LOGGER_GET_RX_PKT_FATES
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |  WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_logger_get_rx_pkt_fates,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
+		.dumpit = aicwf_dump_interface,
+#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0)
 		.policy = VENDOR_CMD_RAW_DATA,
 #endif
@@ -889,6 +1213,20 @@ const struct wiphy_vendor_command aicwf_vendor_cmd[] = {
         .maxattr = WIFI_VENDOR_ATTR_DRIVER_MAX,
 #endif
     	},
+#ifdef AICWF_LATENCY_MODE
+	{
+		{
+			.vendor_id = GOOGLE_OUI,
+			.subcmd = WIFI_SUBCMD_SET_LATENCY_MODE
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = aicwf_vendor_subcmd_set_latency_mode,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 3, 0))
+		.policy = aicwf_cfg80211_andr_wifi_policy,
+		.maxattr = ANDR_WIFI_ATTRIBUTE_MAX
+#endif /* LINUX_VERSION >= 5.3 */
+	},
+#endif
 };
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
index 0e1e3e0c7708..996edefa812e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aic_vendor.h
@@ -117,6 +117,17 @@ enum logger_attributes {
 	LOGGER_ATTRIBUTE_MAX = LOGGER_ATTRIBUTE_AFTER_LAST - 1,
 };
 
+#ifdef CONFIG_APF
+enum wifi_apf_attr {
+	APF_ATTRIBUTE_VERSION,
+	APF_ATTRIBUTE_MAX_LEN,
+	APF_ATTRIBUTE_PROGRAM,
+	APF_ATTRIBUTE_PROGRAM_LEN,
+	APF_ATTRIBUTE_LAST,
+	APF_ATTRIBUTE_MAX = APF_ATTRIBUTE_LAST - 1,
+};
+#endif
+
 enum wifi_sub_command {
 	GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
 	GSCAN_SUBCMD_SET_CONFIG,                            /* 0x1001 */
@@ -143,10 +154,14 @@ enum wifi_sub_command {
 	GSCAN_SUBCMD_ANQPO_CONFIG,                          /* 0x1015 */
 	WIFI_SUBCMD_SET_RSSI_MONITOR,                       /* 0x1016 */
 	WIFI_SUBCMD_CONFIG_ND_OFFLOAD,                      /* 0x1017 */
+	WIFI_SUBCMD_SET_LATENCY_MODE,                       /* 0x1018 */
 	/* Add more sub commands here */
 	GSCAN_SUBCMD_MAX,
 	APF_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START,
 	APF_SUBCMD_SET_FILTER,
+#ifdef CONFIG_APF
+	APF_SUBCMD_READ_FILTER_DATA,
+#endif
 };
 
 enum gscan_attributes {
@@ -190,6 +205,7 @@ enum andr_wifi_attributes {
 	ANDR_WIFI_ATTRIBUTE_NODFS_SET,
 	ANDR_WIFI_ATTRIBUTE_COUNTRY,
 	ANDR_WIFI_ATTRIBUTE_ND_OFFLOAD_VALUE,
+	ANDR_WIFI_ATTRIBUTE_LATENCY_MODE,
 	// Add more attribute here
 	ANDR_WIFI_ATTRIBUTE_AFTER_LAST,
 	ANDR_WIFI_ATTRIBUTE_MAX = ANDR_WIFI_ATTRIBUTE_AFTER_LAST - 1,
@@ -223,6 +239,7 @@ enum wifi_support_feature {
 	WIFI_FEATURE_CONTROL_ROAMING    = 0x800000,    /* Enable/Disable firmware roaming  */
 	WIFI_FEATURE_IE_WHITELIST       = 0x1000000,   /* Support Probe IE white listing   */
 	WIFI_FEATURE_SCAN_RAND          = 0x2000000,   /* Support MAC & Probe Sequence Number randomization */
+	WIFI_FEATURE_SET_LATENCY_MODE   = 0x40000000,  /* Support Latency mode setting     */
 	WIFI_FEATURE_INVALID            = 0xFFFFFFFF,  /* Invalid Feature                  */
 };
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
index 7f50fe6bff14..8dee7597efad 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.c
@@ -4,11 +4,15 @@
 #include "aicwf_compat_8800d80.h"
 
 #define FW_USERCONFIG_NAME_8800D80         "aic_userconfig_8800d80.txt"
+#define FW_USERCONFIG_NAME_8800D80X2       "aic_userconfig_8800d80x2.txt"
+#define FW_POWERLIMIT_NAME_8800D80         "aic_powerlimit_8800d80.txt"
+
 
 int rwnx_request_firmware_common(struct rwnx_hw *rwnx_hw,
 	u32** buffer, const char *filename);
 void rwnx_plat_userconfig_parsing2(char *buffer, int size);
 void rwnx_plat_userconfig_parsing3(char *buffer, int size);
+void rwnx_plat_userconfig_parsing_8800d80x2(char *buffer, int size);
 
 void rwnx_release_firmware_common(u32** buffer);
 
@@ -16,19 +20,28 @@ int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_
 {
 	int ret = 0;
 
-	if ((ret = rwnx_send_txpwr_lvl_v3_req(rwnx_hw))) {
-		return -1;
+	if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+		if ((ret = rwnx_send_txpwr_lvl_v3_req(rwnx_hw))) {
+			return -1;
+		}
+
+		if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
+			return -1;
+		}
+	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		if ((ret = rwnx_send_txpwr_lvl_v4_req(rwnx_hw))) {
+			return -1;
+		}
+		if ((ret = rwnx_send_txpwr_ofst2x_v2_req(rwnx_hw))) {
+			return -1;
+		}
 	}
 
 	if ((ret = rwnx_send_txpwr_lvl_adj_req(rwnx_hw))) {
 		return -1;
 	}
 
-	if ((ret = rwnx_send_txpwr_ofst2x_req(rwnx_hw))) {
-		return -1;
-	}
-
-        if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
+    if ((ret = rwnx_send_rf_calib_req(rwnx_hw, cfm))) {
 		return -1;
 	}
 
@@ -63,4 +76,91 @@ int	rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw)
 
 }
 
+int	rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw)
+{
+    int size;
+    u32 *dst=NULL;
+    char *filename = FW_USERCONFIG_NAME_8800D80X2;
+
+    AICWFDBG(LOGINFO, "userconfig file path:%s \r\n", filename);
+
+    /* load file */
+    size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+    if (size <= 0) {
+            AICWFDBG(LOGERROR, "wrong size of firmware file\n");
+            dst = NULL;
+            return 0;
+    }
+
+	/* Copy the file on the Embedded side */
+    AICWFDBG(LOGINFO, "### Load file done: %s, size=%d\n", filename, size);
+
+	rwnx_plat_userconfig_parsing_8800d80x2((char *)dst, size);
+
+    rwnx_release_firmware_common(&dst);
+
+    AICWFDBG(LOGINFO, "userconfig download complete\n\n");
+    return 0;
+
+}
+
+#ifdef CONFIG_POWER_LIMIT
+extern char country_code[4];
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw)
+{
+	int size;
+	u32 *dst = NULL;
+	char *filename = FW_POWERLIMIT_NAME_8800D80;
+
+	AICWFDBG(LOGDEBUG, "powerlimit file path:%s \r\n", filename);
+
+	/* load file */
+	size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+	if (size <= 0) {
+		AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+		dst = NULL;
+		return 0;
+	}
+
+	AICWFDBG(LOGDEBUG, "### Load file done: %s, size=%d\n", filename, size);
+
+	/* parsing the file */
+	rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
+
+	rwnx_release_firmware_common(&dst);
+
+	AICWFDBG(LOGDEBUG, "powerlimit download complete\n\n");
+	return 0;
+}
+
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw)
+{
+	int size;
+	u32 *dst = NULL;
+	char *filename = FW_POWERLIMIT_NAME_8800D80;
+
+	AICWFDBG(LOGDEBUG, "powerlimit file path:%s \r\n", filename);
+
+	/* load file */
+	size = rwnx_request_firmware_common(rwnx_hw, &dst, filename);
+	if (size <= 0) {
+		AICWFDBG(LOGERROR, "wrong size of cfg file\n");
+		dst = NULL;
+		return 0;
+	}
+
+	AICWFDBG(LOGDEBUG, "### Load file done: %s, size=%d\n", filename, size);
+
+	/* parsing the file */
+	rwnx_plat_powerlimit_parsing((char *)dst, size, country_code);
+
+	rwnx_release_firmware_common(&dst);
+
+	AICWFDBG(LOGDEBUG, "powerlimit download complete\n\n");
+	return 0;
+}
+
+#endif
+
+
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
index df3e9d963a7d..e76577414834 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800d80.h
@@ -4,6 +4,12 @@
 
 int aicwf_set_rf_config_8800d80(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *cfm);
 int	rwnx_plat_userconfig_load_8800d80(struct rwnx_hw *rwnx_hw);
+int	rwnx_plat_userconfig_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+
+#ifdef CONFIG_POWER_LIMIT
+int rwnx_plat_powerlimit_load_8800d80(struct rwnx_hw *rwnx_hw);
+int rwnx_plat_powerlimit_load_8800d80x2(struct rwnx_hw *rwnx_hw);
+#endif
 
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
index f817fc0428df..3e68283f6dc7 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_compat_8800dc.c
@@ -16,6 +16,7 @@ void rwnx_plat_userconfig_parsing2(char *buffer, int size);
 
 void rwnx_release_firmware_common(u32** buffer);
 
+#if !defined(CONFIG_EXT_FEM_8800DCDW)
 u32 wifi_txgain_table_24g_8800dcdw[32] =
 {
     0xA4B22189, //index 0
@@ -160,6 +161,80 @@ u32 wifi_txgain_table_24g_1_8800dcdw_h[32] =
     0x00001825,
 };
 
+#else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+// ofdm
+uint32_t wifi_txgain_table_24g_8800dcdw_femkct[32] = {
+    0x919221C2, //index 0
+    0x00007825,
+    0x899221C3, //index 1
+    0x00007825,
+    0x8B9221C3, //index 2
+    0x00007825,
+    0x929221C3, //index 3
+    0x00007825,
+    0x949221C4, //index 4
+    0x00007825,
+    0x969221C4, //index 5
+    0x00007825,
+    0x949221C6, //index 6
+    0x00007825,
+    0x949221C8, //index 7
+    0x00007825,
+    0x9C9221C8, //index 8
+    0x00007825,
+    0x9C9221CA, //index 9
+    0x00007825,
+    0x9C9221CB, //index 10
+    0x00007825,
+    0x939221D5, //index 11
+    0x00007825,
+    0x9B9221D7, //index 12
+    0x00007825,
+    0xA49221D7, //index 13
+    0x00007825,
+    0xA79221D7, //index 14
+    0x00007825,
+    0xBD9221D7, //index 15
+    0x00007825,
+};
+
+// 11b
+uint32_t wifi_txgain_table_24g_1_8800dcdw_femkct[32] = {
+    0x836E20C2, //index 0
+    0x00003024,
+    0x856E20C2, //index 1
+    0x00003024,
+    0x826E20C3, //index 2
+    0x00003024,
+    0x836E20C3, //index 3
+    0x00003024,
+    0x856E20C3, //index 4
+    0x00003024,
+    0x876E20C3, //index 5
+    0x00003024,
+    0x8B6E20C3, //index 6
+    0x00003024,
+    0x926E20C4, //index 7
+    0x00003024,
+    0x9A6E20C4, //index 8
+    0x00003024,
+    0x936E20C5, //index 9
+    0x00003024,
+    0x936E20C7, //index 10
+    0x00003024,
+    0xA16E20C8, //index 11
+    0x00003024,
+    0xA16E20CA, //index 12
+    0x00003024,
+    0xA26E20CB, //index 13
+    0x00003024,
+    0xAA6E20CD, //index 14
+    0x00003024,
+    0xAC7220CF, //index 15
+    0x00003024,
+};
+#endif
+
 u32 wifi_rxgain_table_24g_20m_8800dcdw[64] = {
     0x82f282d1,//index 0
     0x9591a324,
@@ -378,6 +453,53 @@ int aicwf_fdrv_dpd_result_load_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_
 #endif
 #endif
 
+#if defined(CONFIG_LOFT_CALIB)
+extern rf_misc_ram_lite_t loft_res_local;
+
+int aicwf_fdrv_loft_result_apply_8800dc(struct rwnx_hw *rwnx_hw, rf_misc_ram_lite_t *loft_res)
+{
+    int ret = 0;
+    uint32_t cfg_base = 0x10164;
+    struct dbg_mem_read_cfm cfm;
+    uint32_t misc_ram_addr;
+    uint32_t ram_base_addr, ram_byte_cnt;
+    AICWFDBG(LOGINFO, "bit_mask[1]=%x\n", loft_res->bit_mask[1]);
+    if (loft_res->bit_mask[1] == 0) {
+        AICWFDBG(LOGERROR, "void loft_res, bypass it.\n");
+        return 0;
+    }
+    if (testmode == 1) {
+        cfg_base = RAM_LMAC_FW_ADDR + 0x0164;
+    }
+    if ((ret = rwnx_send_dbg_mem_read_req(rwnx_hw, cfg_base + 0x14, &cfm))) {
+        AICWFDBG(LOGERROR, "rf misc ram[0x%x] rd fail: %d\n", cfg_base + 0x14, ret);
+        return ret;
+    }
+    misc_ram_addr = cfm.memdata;
+    AICWFDBG(LOGINFO, "misc_ram_addr: %x\n", misc_ram_addr);
+    /* Copy loft_res on the Embedded side */
+    // bit_mask
+    AICWFDBG(LOGINFO, "bit_mask[0]=%x\n", loft_res->bit_mask[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, bit_mask);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, bit_mask) + MEMBER_SIZE(rf_misc_ram_t, reserved);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->bit_mask[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "bit_mask wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    // loft_res
+    AICWFDBG(LOGINFO, "loft_res[0]=%x\n", loft_res->loft_res[0]);
+    ram_base_addr = misc_ram_addr + offsetof(rf_misc_ram_t, loft_res);
+    ram_byte_cnt = MEMBER_SIZE(rf_misc_ram_t, loft_res);
+    ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, ram_base_addr, ram_byte_cnt, (u32 *)&loft_res->loft_res[0]);
+    if (ret) {
+        AICWFDBG(LOGERROR, "loft_res wr fail: %x, ret:%d\r\n", ram_base_addr, ret);
+        return ret;
+    }
+    return ret;
+}
+#endif
+
 int aicwf_fdrv_misc_ram_init_8800dc(struct rwnx_hw *rwnx_hw)
 {
     int ret = 0;
@@ -423,6 +545,7 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
 
 
 	if (testmode == 0) {
+        #if !defined(CONFIG_EXT_FEM_8800DCDW)
         if (IS_CHIP_ID_H()) {
             if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_h, 128)))
                 return -1;
@@ -436,6 +559,18 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
             if ((ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw, 128)))
                 return -1;
         }
+        #else /* #ifdef CONFIG_EXT_FEM_8800DCDW */
+        {
+            ret = rwnx_send_rf_config_req(rwnx_hw, 0,    1, (u8_l *)wifi_txgain_table_24g_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+            ret = rwnx_send_rf_config_req(rwnx_hw, 16,    1, (u8_l *)wifi_txgain_table_24g_1_8800dcdw_femkct, 128);
+            if (ret) {
+                return -1;
+            }
+        }
+        #endif
 
 		if ((ret = rwnx_send_rf_config_req(rwnx_hw, 0,	0, (u8_l *)wifi_rxgain_table_24g_20m_8800dcdw, 256)))
 			return -1;
@@ -466,6 +601,14 @@ int aicwf_set_rf_config_8800dc(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_c
                     return ret;
                 }
             }
+            #elif defined(CONFIG_LOFT_CALIB)
+            if (loft_res_local.bit_mask[1]) {
+                ret = aicwf_fdrv_loft_result_apply_8800dc(rwnx_hw, &loft_res_local);
+                if (ret) {
+                    AICWFDBG(LOGINFO, "apply loft res fail: %d\n", ret);
+                    return ret;
+                }
+            }
             #else
             {
                 ret = aicwf_fdrv_misc_ram_init_8800dc(rwnx_hw);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
index 3ab130af7b35..455b5bd1e126 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.c
@@ -21,6 +21,7 @@
 #include "rwnx_defs.h"
 #include "rwnx_platform.h"
 #include "aicwf_rx_prealloc.h"
+#include "rwnx_msg_tx.h"
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
 #include <linux/pm_wakeirq.h>
 #else
@@ -42,7 +43,7 @@
 extern uint8_t scanning;
 
 #ifdef CONFIG_GPIO_WAKEUP
-extern int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level);
+extern int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level, u8 disable_filter);
 
 #ifdef CONFIG_WIFI_SUSPEND_FOR_LINUX
 #include <linux/proc_fs.h>
@@ -83,6 +84,24 @@ int aicwf_sdio_writeb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 val)
 	return ret;
 }
 
+int aicwf_sdio_func2_readb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 *val)
+{
+	int ret;
+	sdio_claim_host(sdiodev->func2);
+	*val = sdio_readb(sdiodev->func2, regaddr, &ret);
+	sdio_release_host(sdiodev->func2);
+	return ret;
+}
+
+int aicwf_sdio_func2_writeb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 val)
+{
+	int ret;
+	sdio_claim_host(sdiodev->func2);
+	sdio_writeb(sdiodev->func2, val, regaddr, &ret);
+	sdio_release_host(sdiodev->func2);
+	return ret;
+}
+
 #ifdef CONFIG_TX_NETIF_FLOWCTRL
 void aicwf_sdio_tx_netif_flowctrl(struct rwnx_hw *rwnx_hw, bool state)
 {
@@ -98,6 +117,158 @@ void aicwf_sdio_tx_netif_flowctrl(struct rwnx_hw *rwnx_hw, bool state)
 }
 #endif
 
+#ifdef CONFIG_TEMP_CONTROL
+//int interval = 30;
+//module_param(interval, int, 0660);
+static int update_state(s8_l value, u8_l current_state)
+{
+	if (value > TEMP_THD_2)
+		return 2;
+	else if (value > (TEMP_THD_2 - BUFFERING_V2) && (current_state == 2))
+		return 2;
+	else if (value > TEMP_THD_1 && current_state != 2)
+		return 1;
+	else if (value > (TEMP_THD_1 - BUFFERING_V1) && current_state == 1)
+		return 1;
+	else if (current_state == 0)
+		return 0;
+	else
+		return 1;
+}
+
+void aicwf_netif_ctrl(struct aic_sdio_dev *sdiodev, int val)
+{
+	unsigned long flags;
+	struct rwnx_vif *rwnx_vif;
+
+	if (sdiodev->net_stop)
+		return;
+
+	spin_lock_irqsave(&sdiodev->tx_flow_lock, flags);
+	list_for_each_entry(rwnx_vif, &sdiodev->rwnx_hw->vifs, list) {
+		if (!rwnx_vif || !rwnx_vif->ndev || !rwnx_vif->up)
+			continue;
+		netif_tx_stop_all_queues(rwnx_vif->ndev);//netif_stop_queue(rwnx_vif->ndev);
+	}
+	spin_unlock_irqrestore(&sdiodev->tx_flow_lock, flags);
+	sdiodev->net_stop = true;
+	mod_timer(&sdiodev->netif_timer, jiffies + msecs_to_jiffies(val));
+
+	return;
+}
+
+void aicwf_temp_ctrl(struct aic_sdio_dev *sdiodev)
+{
+	if (sdiodev->set_level) {
+		if (sdiodev->set_level == 1) {
+			sdiodev->get_level = 1;
+			aicwf_netif_ctrl(sdiodev, sdiodev->interval_t1/*TMR_INTERVAL_1*/);
+			//mdelay(1);
+		} else if (sdiodev->set_level == 2) {
+			sdiodev->get_level = 2;
+			aicwf_netif_ctrl(sdiodev, sdiodev->interval_t2/*TMR_INTERVAL_2*/);
+			//mdelay(2);
+		}
+		return;
+	} else {
+		if (sdiodev->cur_temp > (TEMP_THD_1 - 8)) {
+			//if ((sdiodev->cur_temp > TEMP_THD_1 && sdiodev->cur_temp <= TEMP_THD_2) || (sdiodev->cur_stat == 1)) {
+			if (update_state(sdiodev->cur_temp, sdiodev->cur_stat) == 1) {
+				sdiodev->get_level = 1;
+				sdiodev->cur_stat = 1;
+				aicwf_netif_ctrl(sdiodev, sdiodev->interval_t1/*TMR_INTERVAL_1*/);
+				//mdelay(1);
+				//break;
+			//} else if ((sdiodev->cur_temp > TEMP_THD_2) || (sdiodev->cur_stat == 2)) {
+			} else if (update_state(sdiodev->cur_temp, sdiodev->cur_stat) == 2) {
+				sdiodev->get_level = 2;
+				sdiodev->cur_stat = 2;
+				aicwf_netif_ctrl(sdiodev, sdiodev->interval_t2/*TMR_INTERVAL_2*/);
+				//mdelay(2);
+				//break;
+			}
+			return;
+		}
+
+		if (sdiodev->cur_stat) {
+			AICWFDBG(LOGINFO, "reset cur_stat");
+			sdiodev->cur_stat = 0;
+		}
+
+		return;
+	}
+}
+
+void aicwf_netif_worker(struct work_struct *work)
+{
+	struct aic_sdio_dev *sdiodev = container_of(work, struct aic_sdio_dev, netif_work);
+	unsigned long flags;
+	struct rwnx_vif *rwnx_vif;
+	spin_lock_irqsave(&sdiodev->tx_flow_lock, flags);
+	list_for_each_entry(rwnx_vif, &sdiodev->rwnx_hw->vifs, list) {
+		if (!rwnx_vif || !rwnx_vif->ndev || !rwnx_vif->up)
+			continue;
+		netif_tx_wake_all_queues(rwnx_vif->ndev);//netif_wake_queue(rwnx_vif->ndev);
+	}
+	spin_unlock_irqrestore(&sdiodev->tx_flow_lock, flags);
+	sdiodev->net_stop = false;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+static void aicwf_netif_timer(ulong data)
+#else
+static void aicwf_netif_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+		struct aic_sdio_dev *sdiodev = (struct aic_sdio_dev *) data;
+#else
+		struct aic_sdio_dev *sdiodev = from_timer(sdiodev, t, netif_timer);
+#endif
+
+	if (!work_pending(&sdiodev->netif_work))
+		schedule_work(&sdiodev->netif_work);
+
+	return;
+}
+
+void aicwf_temp_ctrl_worker(struct work_struct *work)
+{
+	struct rwnx_hw *rwnx_hw;
+	struct mm_set_vendor_swconfig_cfm cfm;
+	struct aic_sdio_dev *sdiodev = container_of(work, struct aic_sdio_dev, tp_ctrl_work);
+	rwnx_hw = sdiodev->rwnx_hw;
+	//AICWFDBG(LOGINFO, "%s\n", __func__);
+
+	rwnx_hw->started_jiffies = jiffies;
+
+	rwnx_send_get_temp_req(rwnx_hw, &cfm);
+	sdiodev->cur_temp = cfm.temp_comp_get_cfm.degree;
+
+	mod_timer(&sdiodev->tp_ctrl_timer, jiffies + msecs_to_jiffies(TEMP_GET_INTERVAL));
+
+	return;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+static void aicwf_temp_ctrl_timer(ulong data)
+#else
+static void aicwf_temp_ctrl_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+	struct aic_sdio_dev *sdiodev = (struct aic_sdio_dev *) data;
+#else
+	struct aic_sdio_dev *sdiodev = from_timer(sdiodev, t, tp_ctrl_timer);
+#endif
+
+	if (!work_pending(&sdiodev->tp_ctrl_work))
+		schedule_work(&sdiodev->tp_ctrl_work);
+
+	return;
+}
+#endif
+
 int aicwf_sdio_flow_ctrl_msg(struct aic_sdio_dev *sdiodev)
 {
     int ret = -1;
@@ -539,13 +710,17 @@ static int aicwf_sdio_chipmatch(struct aic_sdio_dev *sdio_dev, u16_l vid, u16_l
 		sdio_dev->chipid = PRODUCT_ID_AIC8800D80;
 		AICWFDBG(LOGINFO, "%s USE AIC8800D80\r\n", __func__);
 		return 0;
+	}else if(vid == SDIO_VENDOR_ID_AIC8800D80X2 && did == SDIO_DEVICE_ID_AIC8800D80X2){
+		sdio_dev->chipid = PRODUCT_ID_AIC8800D80X2;
+		AICWFDBG(LOGINFO, "%s USE AIC8800D80X2\r\n", __func__);
+		return 0;
 	}else{
 		return -1;
 	}
 }
 
 
-extern int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level);
+extern int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level, u8 disable_filter);
 
 static int aicwf_sdio_probe(struct sdio_func *func,
 	const struct sdio_device_id *id)
@@ -602,8 +777,13 @@ static int aicwf_sdio_probe(struct sdio_func *func,
 	dev_set_drvdata(&func->dev, bus_if);
 	sdiodev->dev = &func->dev;
 
+	if (sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+		sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
+		sdiodev->func2 = func->card->sdio_func[1];
+	}
+
 	//sdio func init start
-	if (sdiodev->chipid != PRODUCT_ID_AIC8800D80) {
+	if (sdiodev->chipid != PRODUCT_ID_AIC8800D80 && sdiodev->chipid != PRODUCT_ID_AIC8800D80X2) {
 	    err = aicwf_sdio_func_init(sdiodev);
     } else {
         err = aicwf_sdiov3_func_init(sdiodev);
@@ -707,6 +887,38 @@ void aicwf_sdio_remove_(struct sdio_func *func){
     aicwf_sdio_remove(func);
 }
 
+#if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
+#ifdef CONFIG_SHUTDOWN_CALLBACK
+int rwnx_close_(struct net_device *dev);
+
+void aicwf_sdio_shutdown(struct device *dev)
+{
+    struct rwnx_vif *rwnx_vif, *tmp;
+    struct aicwf_bus *bus_if = dev_get_drvdata(dev);
+    struct aic_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+    
+    AICWFDBG(LOGINFO, "%s Enter", __func__);
+    list_for_each_entry_safe(rwnx_vif, tmp, &sdiodev->rwnx_hw->vifs, list) {
+            if (rwnx_vif->ndev && test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+                            AICWFDBG(LOGINFO, "%s rwnx_close by shutdown", __func__);
+                            rwnx_close_(rwnx_vif->ndev);
+
+            }else{
+                if(!rwnx_vif->ndev){
+                    AICWFDBG(LOGERROR, "%s rwnx_vif->ndev is NULL \r\n", __func__);
+                }
+                if(!test_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags)){
+                    AICWFDBG(LOGERROR, "%s rwnx_vif->drv_flags close\r\n", __func__);
+                }
+            }
+          
+    }
+    AICWFDBG(LOGINFO, "%s Exit", __func__);
+
+}
+#endif
+#endif
+
 static int aicwf_sdio_suspend(struct device *dev)
 {
 	int ret = 0;
@@ -731,6 +943,16 @@ static int aicwf_sdio_suspend(struct device *dev)
 		return ret;
 	}
 
+#ifdef CONFIG_TEMP_CONTROL
+	del_timer_sync(&sdiodev->tp_ctrl_timer);
+	cancel_work_sync(&sdiodev->tp_ctrl_work);
+
+	mod_timer(&sdiodev->tp_ctrl_timer, jiffies + msecs_to_jiffies(TEMP_GET_INTERVAL));
+
+	del_timer_sync(&sdiodev->netif_timer);
+	cancel_work_sync(&sdiodev->netif_work);
+#endif
+
 
 	while (sdiodev->state == SDIO_ACTIVE_ST) {
 		if (down_interruptible(&sdiodev->tx_priv->txctl_sema))
@@ -745,6 +967,15 @@ static int aicwf_sdio_suspend(struct device *dev)
 //	rwnx_enable_hostwake_irq();
 #endif
 
+#if defined(CONFIG_AUTO_POWERSAVE) && defined(CONFIG_SDIO_PWRCTRL)
+    if(sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
+        sdio_dbg("autops set\n");
+        ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 0x8);
+        if(ret) {
+            sdio_err("sdio set autops fail\n");
+        }
+    }
+#endif
 
 #if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
 	if(sdiodev->chipid == PRODUCT_ID_AIC8801){
@@ -772,11 +1003,16 @@ static int aicwf_sdio_resume(struct device *dev)
 	struct aicwf_bus *bus_if = dev_get_drvdata(dev);
 	struct aic_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
 	struct rwnx_vif *rwnx_vif, *tmp;
-#if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
+#if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2) || defined(CONFIG_AUTO_POWERSAVE)
 	int ret;
 #endif
 
 	sdio_dbg("%s enter \n", __func__);
+
+#ifdef CONFIG_TEMP_CONTROL
+	mod_timer(&sdiodev->tp_ctrl_timer, jiffies + msecs_to_jiffies(TEMP_GET_INTERVAL));
+#endif
+
 //#ifdef CONFIG_GPIO_WAKEUP
 //	rwnx_disable_hostwake_irq();
 //#endif
@@ -790,6 +1026,16 @@ static int aicwf_sdio_resume(struct device *dev)
 	aicwf_sdio_pwr_stctl(sdiodev, SDIO_ACTIVE_ST);
 	#endif
 
+#if defined(CONFIG_AUTO_POWERSAVE) && defined(CONFIG_SDIO_PWRCTRL)
+    if(sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
+        sdio_dbg("autops clear\n");
+        ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 0x8);
+        if(ret) {
+            sdio_err("sdio clear autops fail\n");
+        }
+    }
+#endif
+
 //	aicwf_sdio_hal_irqhandler(sdiodev->func);
 
 #if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
@@ -820,6 +1066,7 @@ static const struct sdio_device_id aicwf_sdmmc_ids[] = {
 	{SDIO_DEVICE(SDIO_VENDOR_ID_AIC8801, SDIO_DEVICE_ID_AIC8801)},
 	{SDIO_DEVICE(SDIO_VENDOR_ID_AIC8800DC, SDIO_DEVICE_ID_AIC8800DC)},
     {SDIO_DEVICE(SDIO_VENDOR_ID_AIC8800D80, SDIO_DEVICE_ID_AIC8800D80)},
+    {SDIO_DEVICE(SDIO_VENDOR_ID_AIC8800D80X2, SDIO_DEVICE_ID_AIC8800D80X2)},
 	{ },
 };
 
@@ -837,6 +1084,11 @@ static struct sdio_driver aicwf_sdio_driver = {
 	.id_table = aicwf_sdmmc_ids,
 	.drv = {
 		.pm = &aicwf_sdio_pm_ops,
+#if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
+#ifdef CONFIG_SHUTDOWN_CALLBACK
+		.shutdown = aicwf_sdio_shutdown,
+#endif
+#endif
 	},
 };
 #endif
@@ -906,6 +1158,19 @@ void aicwf_sdio_register(void)
 void aicwf_sdio_exit(void)
 {
 	if (g_rwnx_plat && g_rwnx_plat->enabled){
+#ifdef CONFIG_TEMP_CONTROL
+		if (timer_pending(&g_rwnx_plat->sdiodev->tp_ctrl_timer)) {
+			AICWFDBG(LOGINFO, "%s del tp_ctrl_timer\n", __func__);
+			del_timer_sync(&g_rwnx_plat->sdiodev->tp_ctrl_timer);
+		}
+		cancel_work_sync(&g_rwnx_plat->sdiodev->tp_ctrl_work);
+
+		if (timer_pending(&g_rwnx_plat->sdiodev->netif_timer)) {
+			AICWFDBG(LOGINFO, "%s del netif_timer\n", __func__);
+			del_timer_sync(&g_rwnx_plat->sdiodev->netif_timer);
+		}
+		cancel_work_sync(&g_rwnx_plat->sdiodev->netif_work);
+#endif
 		rwnx_platform_deinit(g_rwnx_plat->sdiodev->rwnx_hw);
 	}else{
 		AICWFDBG(LOGERROR, "%s g_rwnx_plat is not ready \r\n", __func__);
@@ -944,14 +1209,14 @@ int aicwf_sdio_wakeup(struct aic_sdio_dev *sdiodev)
 {
 	int ret = 0;
 	int read_retry;
-	int write_retry = 20;
+	int write_retry = 1;
     int wakeup_reg_val = 0;
 
     if (sdiodev->chipid == PRODUCT_ID_AIC8801 ||
         sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
         wakeup_reg_val = 1;
-    } else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    } else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         wakeup_reg_val = 0x11;
     }
 
@@ -966,13 +1231,13 @@ int aicwf_sdio_wakeup(struct aic_sdio_dev *sdiodev)
 				txrx_err("sdio wakeup fail\n");
 				ret = -1;
 			} else {
-				read_retry = 10;
+				read_retry = 50;
 				while (read_retry) {
 					u8 val;
-					ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.sleep_reg, &val);
+					ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.wakeup_reg, &val);
 					if (ret < 0)
 						txrx_err("sdio wakeup read fail\n");
-					else if (val & 0x10) {
+					else if ((val & 0x1) == 0) {
 						break;
 					}
 					read_retry--;
@@ -997,6 +1262,8 @@ int aicwf_sdio_sleep_allow(struct aic_sdio_dev *sdiodev)
 	int ret = 0;
 	struct aicwf_bus *bus_if = sdiodev->bus_if;
 	struct rwnx_hw *rwnx_hw = sdiodev->rwnx_hw;
+	u8 read_retry;
+	u8 val;
 
 	if (bus_if->state == BUS_DOWN_ST) {
 		ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.sleep_reg, 0x10);
@@ -1009,11 +1276,34 @@ int aicwf_sdio_sleep_allow(struct aic_sdio_dev *sdiodev)
 
 	sdio_info("sleep: %d, %d\n", sdiodev->state, scanning);
 	if (sdiodev->state == SDIO_ACTIVE_ST  && !scanning && !rwnx_hw->is_p2p_alive \
-				&& !rwnx_hw->is_p2p_connected) {
+		&& !rwnx_hw->is_p2p_connected && (int)(atomic_read(&sdiodev->tx_priv->tx_pktcnt) <= 0) \
+		&& (sdiodev->tx_priv->cmd_txstate == false) && (int)(atomic_read(&sdiodev->rx_priv->rx_cnt) == 0)) {
 		AICWFDBG(LOGSDPWRC, "%s s\n", __func__);
-		ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.sleep_reg, 0x10);
-		if (ret)
-			sdio_err("Write sleep fail!\n");
+		if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
+			if (aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 0x02) < 0) {
+				sdio_err("reg:%d write failed!\n", sdiodev->sdio_reg.wakeup_reg);
+			}
+		} else if (sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC || 
+				sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
+			if (aicwf_sdio_func2_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 0x2) < 0) {
+				sdio_err("reg:%d write failed!\n", sdiodev->sdio_reg.wakeup_reg);
+			}
+			read_retry = 100;
+			while (read_retry) {
+				val = 0;
+				if (aicwf_sdio_func2_readb(sdiodev, sdiodev->sdio_reg.wakeup_reg, &val) < 0){
+					sdio_err("reg %d read fail\n", sdiodev->sdio_reg.wakeup_reg);
+				}else if ((val & 0x2) == 0) {
+					break;
+				} else {
+					sdio_err("val:%d\n", val);
+				}
+				read_retry--;
+				if(read_retry < 90)
+					printk("warning: read cnt %d\n", read_retry);
+				udelay(500);
+			}
+		}
 		sdiodev->state = SDIO_SLEEP_ST;
 		aicwf_sdio_pwrctl_timer(sdiodev, 0);
         //rwnx_pm_relax(sdiodev);
@@ -1237,7 +1527,8 @@ static int aicwf_sdio_tx_msg(struct aic_sdio_dev *sdiodev)
 	} else
 		len = payload_len;
 
-	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		buffer_cnt = aicwf_sdio_flow_ctrl_msg(sdiodev);
 		while ((buffer_cnt <= 0 || (buffer_cnt > 0 && len > (buffer_cnt * BUFFER_SIZE))) && retry < 10) {
 			retry++;
@@ -1247,7 +1538,8 @@ static int aicwf_sdio_tx_msg(struct aic_sdio_dev *sdiodev)
 	}
 	down(&sdiodev->tx_priv->cmd_txsema);
 
-	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		if (buffer_cnt > 0 && len < (buffer_cnt * BUFFER_SIZE)) {
 			err = aicwf_sdio_send_pkt(sdiodev, payload, len);
 			if (err) {
@@ -1310,7 +1602,6 @@ static void aicwf_sdio_tx_process(struct aic_sdio_dev *sdiodev)
 			txrx_err("txctl up bus->txctl_sema fail\n");
 			return;
 		}
-
 		err = aicwf_sdio_tx_msg(sdiodev);
 		up(&sdiodev->tx_priv->txctl_sema);
 		if (waitqueue_active(&sdiodev->tx_priv->cmd_txdone_wait))
@@ -1337,6 +1628,11 @@ static void aicwf_sdio_tx_process(struct aic_sdio_dev *sdiodev)
 		if(sdiodev->bus_if->state == BUS_DOWN_ST) {
 			break;
 		}
+#ifdef CONFIG_TEMP_CONTROL
+		if (sdiodev->on_off)
+			aicwf_temp_ctrl(sdiodev);
+#endif
+
 	        if (sdiodev->tx_priv->fw_avail_bufcnt <= DATA_FLOW_CTRL_THRESH) {
         	    if (sdiodev->tx_priv->cmd_txstate)
                 	break;
@@ -1475,7 +1771,7 @@ int aicwf_sdio_send(struct aicwf_tx_priv *tx_priv, u8 txnow)
 		|| ((atomic_read(&tx_priv->aggr_count) != 0) && (aggr_len == 0))) {
 		if (aggr_len > 0)
 			aicwf_sdio_aggrbuf_reset(tx_priv);
-		goto done;
+		return 0;
 	}
 
 	if (atomic_read(&tx_priv->aggr_count) == (tx_priv->fw_avail_bufcnt - DATA_FLOW_CTRL_THRESH)) {
@@ -1483,15 +1779,16 @@ int aicwf_sdio_send(struct aicwf_tx_priv *tx_priv, u8 txnow)
 			tx_priv->fw_avail_bufcnt -= atomic_read(&tx_priv->aggr_count);
 			aicwf_sdio_aggr_send(tx_priv); //send and check the next pkt;
 		}
+		return 0;
 	} else {
 		spin_lock_bh(&sdiodev->tx_priv->txqlock);
 		pkt = aicwf_frame_dequeue(&sdiodev->tx_priv->txq);
 		if (pkt == NULL) {
 			sdio_err("txq no pkt\n");
 			spin_unlock_bh(&sdiodev->tx_priv->txqlock);
-			goto done;
+			return 0;
 		}
-		atomic_dec(&sdiodev->tx_priv->tx_pktcnt);
+		//atomic_dec(&sdiodev->tx_priv->tx_pktcnt);
 		spin_unlock_bh(&sdiodev->tx_priv->txqlock);
 
 #ifdef CONFIG_TX_NETIF_FLOWCTRL
@@ -1512,19 +1809,21 @@ int aicwf_sdio_send(struct aicwf_tx_priv *tx_priv, u8 txnow)
 		if (aicwf_sdio_aggr(tx_priv, pkt)) {
 			aicwf_sdio_aggrbuf_reset(tx_priv);
 			sdio_err("add aggr pkts failed!\n");
-			goto done;
+			atomic_dec(&sdiodev->tx_priv->tx_pktcnt);
+			return 0;
 		}
 
 		//when aggr finish or there is cmd to send, just send this aggr pkt to fw
-		if ((int)atomic_read(&sdiodev->tx_priv->tx_pktcnt) == 0 || txnow || (atomic_read(&tx_priv->aggr_count) == (tx_priv->fw_avail_bufcnt - DATA_FLOW_CTRL_THRESH))) {
+		if ((int)atomic_read(&sdiodev->tx_priv->tx_pktcnt) == 1 || txnow || (atomic_read(&tx_priv->aggr_count) == (tx_priv->fw_avail_bufcnt - DATA_FLOW_CTRL_THRESH))) {
 			tx_priv->fw_avail_bufcnt -= atomic_read(&tx_priv->aggr_count);
 			aicwf_sdio_aggr_send(tx_priv);
-		} else
-			goto done;
+			atomic_dec(&sdiodev->tx_priv->tx_pktcnt);
+			return 0;
+		} else {
+			atomic_dec(&sdiodev->tx_priv->tx_pktcnt);
+			return 0;
+		}
 	}
-
-done:
-	return 0;
 }
 
 int aicwf_sdio_aggr(struct aicwf_tx_priv *tx_priv, struct sk_buff *pkt)
@@ -1544,7 +1843,7 @@ int aicwf_sdio_aggr(struct aicwf_tx_priv *tx_priv, struct sk_buff *pkt)
         tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800DW)
         sdio_header[3] = 0; //reserved
-    else if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+    else if (tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || tx_priv->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
 	    sdio_header[3] = crc8_ponl_107(&sdio_header[0], 3); // crc8
 
 	memcpy(tx_priv->tail, (u8 *)&sdio_header, sizeof(sdio_header));
@@ -1627,7 +1926,7 @@ static int aicwf_sdio_bus_start(struct device *dev)
 #else
     set_irq_handler(aicwf_sdio_hal_irqhandler);  
 #endif
-    if(sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+    if(sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
         sdio_f0_writeb(sdiodev->func, 0x07, 0x04, &ret);
         if (ret) {
             sdio_err("set func0 int en fail %d\n", ret);
@@ -1664,6 +1963,27 @@ module_param_named(busrx_thread_prio, busrx_thread_prio, int, 0644);
 //module_param(busrx_thread_prio, int, 0);
 #endif
 
+
+static inline void aic_thread_wait_stop(void)
+{
+#if 1// PLATFORM_LINUX
+	#if 0
+	while (!kthread_should_stop()){
+        AICWFDBG(LOGINFO, "%s waiting for thread_stop notify \r\n", __func__);
+		msleep(100);
+    }
+	#else
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (!kthread_should_stop()) {
+        AICWFDBG(LOGINFO, "%s waiting for thread_stop notify \r\n", __func__);
+		schedule();
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+	__set_current_state(TASK_RUNNING);
+	#endif
+#endif
+}
+
 #ifdef CONFIG_OOB
 int rx_thread_wait_to = 1000;
 module_param_named(rx_thread_wait_to, rx_thread_wait_to, int, 0644);
@@ -1701,17 +2021,21 @@ int sdio_busirq_thread(void *data){
     
     
     while (1) {
+#if 0
             if (kthread_should_stop()) {
                 AICWFDBG(LOGERROR, "sdio busirq thread stop\n");
                 break;
             }
-
+#endif
             if(!wait_for_completion_timeout(&bus_if->busirq_trgg, msecs_to_jiffies(rx_thread_wait_to))){
                 AICWFDBG(LOGRXPOLL, "%s wait for completion timout \r\n", __func__);
             }
        
-            if (bus_if->state == BUS_DOWN_ST)
-                continue;
+            if (bus_if->state == BUS_DOWN_ST){
+                AICWFDBG(LOGERROR, "%s bus down thread exit \r\n", __func__);
+                break;
+            }
+                //continue;
 #if 1
 #ifdef CONFIG_SDIO_PWRCTRL
             while(atomic_read(&bus_if->bus_priv.sdio->is_bus_suspend) == 1){
@@ -1723,6 +2047,8 @@ int sdio_busirq_thread(void *data){
 #endif
             aicwf_sdio_hal_irqhandler(bus_if->bus_priv.sdio->func);
         }
+    
+    aic_thread_wait_stop();
 
     return 0;
 }
@@ -1772,14 +2098,16 @@ int sdio_bustx_thread(void *data)
     AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
 
 	while (1) {
+        #if 0
 		if (kthread_should_stop()) {
 			AICWFDBG(LOGERROR, "sdio bustx thread stop\n");
 			break;
 		}
-        
+        #endif
 	    if (!wait_for_completion_interruptible(&bus->bustx_trgg)) {
 			if (sdiodev->bus_if->state == BUS_DOWN_ST)
-				continue;
+				break;
+				//continue;
 
             rwnx_wakeup_lock(sdiodev->rwnx_hw->ws_tx);
 			if ((int)(atomic_read(&sdiodev->tx_priv->tx_pktcnt) > 0) || (sdiodev->tx_priv->cmd_txstate == true)){
@@ -1788,7 +2116,9 @@ int sdio_bustx_thread(void *data)
             rwnx_wakeup_unlock(sdiodev->rwnx_hw->ws_tx);
 		}
 	}
-
+    
+	aic_thread_wait_stop();
+	AICWFDBG(LOGINFO, "%s Exit\r\n", __func__);
 	return 0;
 }
 
@@ -1894,19 +2224,24 @@ int sdio_busrx_thread(void *data)
     AICWFDBG(LOGINFO, "%s the current pid is:%d\n", __func__, current->pid);
     
     while (1) {
+        #if 0
         if (kthread_should_stop()) {
             AICWFDBG(LOGERROR, "sdio busrx thread stop\n");
             break;
         }
+        #endif
         if (!wait_for_completion_interruptible(&bus_if->busrx_trgg)) {
 
             if (bus_if->state == BUS_DOWN_ST)
-                continue;
+				break;
+				//continue;
             rwnx_wakeup_lock(rx_priv->sdiodev->rwnx_hw->ws_rx);
             aicwf_process_rxframes(rx_priv);
             rwnx_wakeup_unlock(rx_priv->sdiodev->rwnx_hw->ws_rx);
         }
     }
+    aic_thread_wait_stop();
+	AICWFDBG(LOGINFO, "%s Exit\r\n", __func__);
     return 0;
 
 }
@@ -2012,6 +2347,12 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
 	#endif
 	int ret;
 
+
+    if ((sdiodev->rwnx_hw) == NULL) {
+		sdio_err("waiting for rwnx_hw->irq_enable is true\r\n");
+		return;
+	}
+
 	//AICWFDBG(LOGDEBUG, "fdrv %s enter \r\n", __func__);
     rwnx_wakeup_lock(sdiodev->rwnx_hw->ws_irqrx);
 
@@ -2060,7 +2401,7 @@ void aicwf_sdio_hal_irqhandler(struct sdio_func *func)
             complete(&bus_if->busrx_trgg);
         }
 
-    }else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    }else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         do {
             ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.misc_int_status_reg, &intstatus);
             if (!ret) {
@@ -2157,24 +2498,31 @@ static struct aicwf_bus_ops aicwf_sdio_bus_ops = {
 void aicwf_sdio_release(struct aic_sdio_dev *sdiodev)
 {
 	struct aicwf_bus *bus_if;
-#ifdef CONFIG_OOB
-    int ret;
-#endif
+    	int ret = 0;
 	AICWFDBG(LOGINFO, "%s Enter\n", __func__);
 
 	bus_if = dev_get_drvdata(sdiodev->dev);
 	bus_if->state = BUS_DOWN_ST;
 #ifdef CONFIG_OOB
-    if(sdiodev->oob_enable){
-    	sdio_claim_host(sdiodev->func);
-    	//disable sdio interrupt
-        ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
-    	if (ret < 0) {
-    		AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.intr_config_reg);
-    	}
-    	sdio_release_irq(sdiodev->func);
-    	sdio_release_host(sdiodev->func);
-    }
+	if(sdiodev->oob_enable){
+		sdio_claim_host(sdiodev->func);
+		//disable sdio interrupt
+		ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
+		if (ret < 0) {
+			AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.intr_config_reg);
+		}
+		sdio_release_irq(sdiodev->func);
+		sdio_release_host(sdiodev->func);
+	}
+#else
+	sdio_claim_host(sdiodev->func);
+	//disable sdio interrupt
+	ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.intr_config_reg, 0x0);
+	if (ret < 0) {
+		sdio_err("reg:%d write failed!\n", sdiodev->sdio_reg.intr_config_reg);
+	}
+	sdio_release_irq(sdiodev->func);
+	sdio_release_host(sdiodev->func);
 #endif
 	if (sdiodev->dev)
 		aicwf_bus_deinit(sdiodev->dev);
@@ -2216,7 +2564,7 @@ void aicwf_sdio_reg_init(struct aic_sdio_dev *sdiodev)
         sdiodev->sdio_reg.block_cnt_reg =          SDIOWIFI_BLOCK_CNT_REG;
         sdiodev->sdio_reg.rd_fifo_addr =           SDIOWIFI_RD_FIFO_ADDR;
         sdiodev->sdio_reg.wr_fifo_addr =           SDIOWIFI_WR_FIFO_ADDR;
-	} else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	} else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
         sdiodev->sdio_reg.bytemode_len_reg =       SDIOWIFI_BYTEMODE_LEN_REG_V3;
         sdiodev->sdio_reg.intr_config_reg =        SDIOWIFI_INTR_ENABLE_REG_V3;
         sdiodev->sdio_reg.sleep_reg =              SDIOWIFI_INTR_PENDING_REG_V3;
@@ -2236,7 +2584,7 @@ int aicwf_sdio_func_init(struct aic_sdio_dev *sdiodev)
 	u8 byte_mode_disable = 0x1;//1: no byte mode
 	int ret = 0;
 	struct aicbsp_feature_t feature;
-	u8 val = 0;
+	//u8 val = 0;
 
 	aicbsp_get_feature(&feature, NULL);
     aicwf_sdio_reg_init(sdiodev);
@@ -2276,6 +2624,41 @@ int aicwf_sdio_func_init(struct aic_sdio_dev *sdiodev)
 
 	sdio_release_host(sdiodev->func);
 
+	if (sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+			sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
+		sdio_claim_host(sdiodev->func2);
+		//set sdio blocksize
+		ret = sdio_set_block_size(sdiodev->func2, SDIOWIFI_FUNC_BLOCKSIZE);
+		if (ret < 0) {
+			AICWFDBG(LOGERROR, "set func2 blocksize fail %d\n", ret);
+			sdio_release_host(sdiodev->func2);
+			return ret;
+		}
+
+		//set sdio enable func
+		ret = sdio_enable_func(sdiodev->func2);
+		if (ret < 0) {
+			sdio_release_host(sdiodev->func2);
+			AICWFDBG(LOGERROR, "enable func2 fail %d.\n", ret);
+			return ret;
+		}
+
+		sdio_release_host(sdiodev->func2);
+
+		ret = aicwf_sdio_func2_writeb(sdiodev, sdiodev->sdio_reg.register_block, block_bit0);
+		if (ret < 0) {
+			AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.register_block);
+			return ret;
+		}
+
+		//1: no byte mode
+		ret = aicwf_sdio_func2_writeb(sdiodev, sdiodev->sdio_reg.bytemode_enable_reg, byte_mode_disable);
+		if (ret < 0) {
+			AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.bytemode_enable_reg);
+			return ret;
+		}
+	}
+
 	ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.register_block, block_bit0);
 	if (ret < 0) {
 		AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.register_block);
@@ -2289,13 +2672,13 @@ int aicwf_sdio_func_init(struct aic_sdio_dev *sdiodev)
 		return ret;
 	}
 
+#if 0
 	ret = aicwf_sdio_writeb(sdiodev, sdiodev->sdio_reg.wakeup_reg, 1);
 	if (ret < 0) {
         AICWFDBG(LOGERROR, "reg:%d write failed!\n", sdiodev->sdio_reg.wakeup_reg);
 		return ret;
 	}
 
-#if 1
 	mdelay(5);
 	ret = aicwf_sdio_readb(sdiodev, sdiodev->sdio_reg.sleep_reg, &val);
 	if (ret < 0) {
@@ -2308,6 +2691,8 @@ int aicwf_sdio_func_init(struct aic_sdio_dev *sdiodev)
 	}else{
 		AICWFDBG(LOGINFO, "sdio ready\n");
 	}
+#else
+	mdelay(10);
 #endif
 	return ret;
 }
@@ -2419,6 +2804,13 @@ void aicwf_sdio_func_deinit(struct aic_sdio_dev *sdiodev)
 	sdio_claim_host(sdiodev->func);
 	sdio_disable_func(sdiodev->func);
 	sdio_release_host(sdiodev->func);
+
+	if(sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+			sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+		sdio_claim_host(sdiodev->func2);
+		sdio_disable_func(sdiodev->func2);
+		sdio_release_host(sdiodev->func2);
+	}
 }
 
 void *aicwf_sdio_bus_init(struct aic_sdio_dev *sdiodev)
@@ -2485,6 +2877,31 @@ void *aicwf_sdio_bus_init(struct aic_sdio_dev *sdiodev)
 	spin_lock_init(&sdiodev->tx_flow_lock);
 #endif
 
+#ifdef CONFIG_TEMP_CONTROL
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+	init_timer(&sdiodev->tp_ctrl_timer);
+	sdiodev->tp_ctrl_timer.data = (ulong) sdiodev;
+	sdiodev->tp_ctrl_timer.function = aicwf_temp_ctrl_timer;
+	init_timer(&sdiodev->netif_timer);
+	sdiodev->netif_timer.data = (ulong) sdiodev;
+	sdiodev->netif_timer.function = aicwf_netif_timer;
+#else
+	timer_setup(&sdiodev->tp_ctrl_timer, aicwf_temp_ctrl_timer, 0);
+	timer_setup(&sdiodev->netif_timer, aicwf_netif_timer, 0);
+#endif
+	INIT_WORK(&sdiodev->tp_ctrl_work, aicwf_temp_ctrl_worker);
+	INIT_WORK(&sdiodev->netif_work, aicwf_netif_worker);
+	mod_timer(&sdiodev->tp_ctrl_timer, jiffies + msecs_to_jiffies(TEMP_GET_INTERVAL));
+	sdiodev->net_stop = false;;
+	sdiodev->on_off = true;
+	sdiodev->cur_temp = 0;
+	sdiodev->get_level = 0;
+	sdiodev->set_level = 0;
+	sdiodev->interval_t1 = TMR_INTERVAL_1;
+	sdiodev->interval_t2 = TMR_INTERVAL_2;
+	sdiodev->cur_stat = 0;
+#endif
+
 	ret = aicwf_bus_init(0, sdiodev->dev);
 	if (ret < 0) {
 		sdio_err("bus init fail\n");
@@ -2534,10 +2951,10 @@ void rwnx_set_wifi_suspend(char onoff){
 	int ret = 0;
 	if (onoff == '0') {
 		printk("%s resume \r\n", __func__);
-		rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 0);
+		rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 0, 1);
 	}else{
 		printk("%s suspend \r\n", __func__);
-		ret = rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1);
+		ret = rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1, 0);
 		if (!ret) {
 			aicwf_sdio_pwr_stctl(g_rwnx_plat->sdiodev, SDIO_SLEEP_ST);
 			ret = aicwf_sdio_writeb(g_rwnx_plat->sdiodev, SDIOWIFI_WAKEUP_REG, 2);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
index 4ca6de280e85..7e3e16fd405c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_sdio.h
@@ -62,6 +62,16 @@
 #define AICWF_SDIO_TX_HIGH_WATER         500
 #endif
 
+#ifdef CONFIG_TEMP_CONTROL
+#define TEMP_GET_INTERVAL                (60 * 1000)
+#define TEMP_THD_1                       80  //temperature 1 (℃)
+#define TEMP_THD_2                       95 //temperature 2 (℃)
+#define BUFFERING_V1                     8
+#define BUFFERING_V2                     13
+#define TMR_INTERVAL_1                   60  //timer_1 60ms
+#define TMR_INTERVAL_2                   180 //timer_2 130ms
+#endif
+
 typedef enum {
 	SDIO_TYPE_DATA         = 0X00,
 	SDIO_TYPE_CFG          = 0X10,
@@ -74,16 +84,19 @@ typedef enum {
 #define SDIO_VENDOR_ID_AIC8801                0x5449
 #define SDIO_VENDOR_ID_AIC8800DC              0xc8a1
 #define SDIO_VENDOR_ID_AIC8800D80             0xc8a1
+#define SDIO_VENDOR_ID_AIC8800D80X2           0xc8a1
 
 #define SDIO_DEVICE_ID_AIC8801				0x0145
 #define SDIO_DEVICE_ID_AIC8800DC			0xc08d
 #define SDIO_DEVICE_ID_AIC8800D80           0x0082
+#define SDIO_DEVICE_ID_AIC8800D80X2         0x2082
 
 enum AICWF_IC{
 	PRODUCT_ID_AIC8801	=	0,
 	PRODUCT_ID_AIC8800DC,
 	PRODUCT_ID_AIC8800DW,
-	PRODUCT_ID_AIC8800D80
+	PRODUCT_ID_AIC8800D80,
+	PRODUCT_ID_AIC8800D80X2
 };
 
 
@@ -107,6 +120,7 @@ struct aic_sdio_reg {
 struct aic_sdio_dev {
 	struct rwnx_hw *rwnx_hw;
 	struct sdio_func *func;
+	struct sdio_func *func2;
 	struct device *dev;
 	struct aicwf_bus *bus_if;
 	struct rwnx_cmd_mgr cmd_mgr;
@@ -134,9 +148,35 @@ struct aic_sdio_dev {
 	spinlock_t wslock;//AIDEN test
 	bool oob_enable;
     atomic_t is_bus_suspend;
+
+#ifdef CONFIG_TEMP_CONTROL
+	spinlock_t tx_flow_lock;
+	struct timer_list netif_timer;
+	struct timer_list tp_ctrl_timer;
+	struct work_struct tp_ctrl_work;
+	struct work_struct netif_work;
+	s8_l cur_temp;
+	bool net_stop;
+	bool on_off;	  //for command, 0 - off, 1 - on
+	int8_t get_level; //for command, 0 - 100%, 1 - 12%, 2 - 3%
+	int8_t set_level; //for command, 0 - driver auto, 1 - 12%, 2 - 3%
+	int interval_t1;
+	int interval_t2;
+	u8_l cur_stat;	  //0--normal temp, 1/2--buffering temp
+#endif
+
 };
+
+#ifdef CONFIG_TEMP_CONTROL
+void aicwf_netif_worker(struct work_struct *work);
+void aicwf_temp_ctrl_worker(struct work_struct *work);
+void aicwf_temp_ctrl(struct aic_sdio_dev *sdiodev);
+void aicwf_netif_ctrl(struct aic_sdio_dev *sdiodev, int val);
+#endif
 extern struct aicwf_rx_buff_list aic_rx_buff_list;
 int aicwf_sdio_writeb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 val);
+int aicwf_sdio_func2_readb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 *val);
+int aicwf_sdio_func2_writeb(struct aic_sdio_dev *sdiodev, uint regaddr, u8 val);
 void aicwf_sdio_hal_irqhandler(struct sdio_func *func);
 
 #if defined(CONFIG_SDIO_PWRCTRL)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
index fa30efd813a0..ca47b26cd28c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_tcp_ack.c
@@ -188,7 +188,7 @@ int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
 				case TCPOPT_WINDOW:
 					if (*ptr < 15)
 						*win_scale = (1 << (*ptr));
-					printk("%d\n",*win_scale);
+					//printk("%d\n",*win_scale);
 					break;
 				default:
 					drop = 2;
@@ -442,7 +442,7 @@ int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
 	struct tcp_ack_msg *ack;
 	int ret = 0;
 	struct msg_buf *drop_msg = NULL;
-	struct msg_buf * send_msg = NULL;
+	//struct msg_buf * send_msg = NULL;
 	//printk("",);
 	write_seqlock_bh(&ack_info->seqlock);
 
@@ -470,8 +470,8 @@ int tcp_ack_handle_new(struct msg_buf *new_msgbuf,
 				  (ack_info->drop_cnt >=
 				   atomic_read(&ack_m->max_drop_cnt)))){
 			ack_info->drop_cnt = 0;
-			send_msg = new_msgbuf;
-			ack_info->in_send_msg = send_msg;
+			//send_msg = new_msgbuf;
+			ack_info->in_send_msg = new_msgbuf;
 			del_timer(&ack_info->timer);
 		}else{
 			ret = 1;
@@ -550,9 +550,6 @@ int filter_send_tcp_ack(struct rwnx_hw *priv,
 	struct tcp_ack_info *ack_info;
 	struct tcp_ack_manage *ack_m = &priv->ack_m;
 
-	if (plen > MAX_TCP_ACK)
-		return 0;
-
 	tcp_ack_update(ack_m);
 	drop = tcp_check_ack(buf, &ack_msg, &win_scale);
 	//printk("drop:%d win_scale:%d",drop,win_scale);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
index 47613d7c6cca..c74fe222663e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/aicwf_txrxif.c
@@ -598,12 +598,10 @@ void aicwf_rx_deinit(struct aicwf_rx_priv *rx_priv)
 
 	AICWFDBG(LOGINFO, "%s\n", __func__);
 
-	spin_lock_bh(&rx_priv->stas_reord_lock);
 	list_for_each_entry_safe(reord_info, tmp,
 		&rx_priv->stas_reord_list, list) {
 		reord_deinit_sta(rx_priv, reord_info);
 	}
-	spin_unlock_bh(&rx_priv->stas_reord_lock);
 #endif
 
 #ifdef AICWF_SDIO_SUPPORT
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h b/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
index 17cb02526282..e2429283314b 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/hal_desc.h
@@ -33,6 +33,19 @@ extern const int chnl2bw[];
 /* conversion table from MACHW to NL80211 enum */
 extern const int bw2chnl[];
 
+/* Rate cntrl info */
+#define MCS_INDEX_TX_RCX_OFT    0
+#define MCS_INDEX_TX_RCX_MASK   (0x7F << MCS_INDEX_TX_RCX_OFT)
+#define BW_TX_RCX_OFT           7
+#define BW_TX_RCX_MASK          (0x3 << BW_TX_RCX_OFT)
+#define SHORT_GI_TX_RCX_OFT     9
+#define SHORT_GI_TX_RCX_MASK    (0x1 << SHORT_GI_TX_RCX_OFT)
+#define PRE_TYPE_TX_RCX_OFT     10
+#define PRE_TYPE_TX_RCX_MASK    (0x1 << PRE_TYPE_TX_RCX_OFT)
+#define FORMAT_MOD_TX_RCX_OFT   11
+#define FORMAT_MOD_TX_RCX_MASK  (0x7 << FORMAT_MOD_TX_RCX_OFT)
+
+
 /* Values for formatModTx */
 #define FORMATMOD_NON_HT          0
 #define FORMATMOD_NON_HT_DUP_OFDM 1
@@ -95,6 +108,23 @@ union rwnx_mcs_index {
 	u32 legacy : 7;
 };
 
+enum {
+    HW_RATE_1MBPS   = 0,
+    HW_RATE_2MBPS   = 1,
+    HW_RATE_5_5MBPS = 2,
+    HW_RATE_11MBPS  = 3,
+    HW_RATE_6MBPS   = 4,
+    HW_RATE_9MBPS   = 5,
+    HW_RATE_12MBPS  = 6,
+    HW_RATE_18MBPS  = 7,
+    HW_RATE_24MBPS  = 8,
+    HW_RATE_36MBPS  = 9,
+    HW_RATE_48MBPS  = 10,
+    HW_RATE_54MBPS  = 11,
+    HW_RATE_MAX
+};
+
+
 /* c.f RW-WLAN-nX-MAC-HW-UM */
 union rwnx_rate_ctrl_info {
 	struct {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
index 91a4e2913730..e8c280dfb9dd 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/lmac_msg.h
@@ -20,6 +20,8 @@
 // for MAC related elements (mac_addr, mac_ssid...)
 #include "lmac_mac.h"
 
+#define LMAC_MSG_MAX_LEN  1024
+
 /*
  ****************************************************************************************
  */
@@ -397,6 +399,14 @@ enum mm_msg_tag {
     MM_SET_TXPWR_LVL_ADJ_REQ,
     MM_SET_TXPWR_LVL_ADJ_CFM,
 
+	MM_RADAR_DETECT_IND,
+
+	MM_SET_APF_PROG_REQ,
+	MM_SET_APF_PROG_CFM,
+
+	MM_GET_APF_PROG_REQ,
+	MM_GET_APF_PROG_CFM,
+
     /// MAX number of messages
     MM_MAX,
 };
@@ -1263,6 +1273,20 @@ typedef struct
     s8_l pwrlvl_11ax_5g[12];
 } txpwr_lvl_conf_v3_t;
 
+typedef struct
+{
+    u8_l enable;
+    s8_l pwrlvl_11b_11ag_2g4[12];
+    s8_l pwrlvl_11n_11ac_2g4[10];
+    s8_l pwrlvl_11ax_2g4[12];
+    s8_l pwrlvl_11a_5g[8];
+    s8_l pwrlvl_11n_11ac_5g[10];
+    s8_l pwrlvl_11ax_5g[12];
+    s8_l pwrlvl_11a_6g[8];
+    s8_l pwrlvl_11n_11ac_6g[10];
+    s8_l pwrlvl_11ax_6g[12];
+} txpwr_lvl_conf_v4_t;
+
 typedef struct
 {
     u8_l enable;
@@ -1272,8 +1296,10 @@ typedef struct
 
 typedef struct
 {
-    u8_l loss_enable;
-    u8_l loss_value;
+	u8_l loss_enable_2g4;
+	s8_l loss_value_2g4;
+	u8_l loss_enable_5g;
+	s8_l loss_value_5g;
 } txpwr_loss_conf_t;
 
 struct mm_set_txpwr_lvl_req
@@ -1282,6 +1308,7 @@ struct mm_set_txpwr_lvl_req
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+	txpwr_lvl_conf_v4_t txpwr_lvl_v4;
   };
 };
 
@@ -1348,6 +1375,47 @@ typedef struct
     int8_t pwrofst2x_tbl_5g[3][6];
 } txpwr_ofst2x_conf_t;
 
+/*
+ * pwrofst2x_v2_tbl_2g4_ant0/1[3][3]:
+ * +---------------+----------+---------------+--------------+
+ * | ChGrp\RateTyp |  DSSS    | OFDM_HIGHRATE | OFDM_LOWRATE |
+ * +---------------+----------+---------------+--------------+
+ * | CH_1_4        |  [0][0]  |  [0][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * | CH_5_9        |  [1][0]  |  [1][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * | CH_10_13      |  [2][0]  |  [2][1]       |  Reserved    |
+ * +---------------+----------+---------------+--------------+
+ * pwrofst2x_v2_tbl_5g_ant0/1[6][3]:
+ * +-----------------+---------------+--------------+--------------+
+ * | ChGrp\RateTyp   | OFDM_HIGHRATE | OFDM_LOWRATE | OFDM_MIDRATE |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_42(36~50)    |  [0][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_58(51~64)    |  [1][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_106(98~114)  |  [2][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_122(115~130) |  [3][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_138(131~146) |  [4][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ * | CH_155(147~166) |  [5][0]       |  Reserved    |  Reserved    |
+ * +-----------------+---------------+--------------+--------------+
+ */
+
+typedef struct
+{
+    u8_l enable;
+    u8_l pwrofst_flags;
+    s8_l pwrofst2x_tbl_2g4_ant0[3][3];
+    s8_l pwrofst2x_tbl_2g4_ant1[3][3];
+    s8_l pwrofst2x_tbl_5g_ant0[6][3];
+    s8_l pwrofst2x_tbl_5g_ant1[6][3];
+    s8_l pwrofst2x_tbl_6g_ant0[15];
+    s8_l pwrofst2x_tbl_6g_ant1[15];
+} txpwr_ofst2x_conf_v2_t;
+
 typedef struct
 {
     u8_l enable;
@@ -1360,6 +1428,7 @@ struct mm_set_txpwr_ofst_req {
 	union {
 	  txpwr_ofst_conf_t txpwr_ofst;
 	  txpwr_ofst2x_conf_t txpwr_ofst2x;
+	  txpwr_ofst2x_conf_v2_t txpwr_ofst2x_v2;
 	};
 };
 
@@ -1869,6 +1938,10 @@ enum vendor_hwconfig_tag{
 	CCA_THRESHOLD_REQ,
 	BWMODE_REQ,
 	CHIP_TEMP_GET_REQ,
+	AP_PS_LEVEL_SET_REQ,
+	CUSTOMIZED_FREQ_REQ,
+	WAKEUP_INFO_REQ,
+	KEEPALIVE_PKT_REQ,
 };
 
 enum {
@@ -1896,7 +1969,8 @@ struct mm_set_channel_access_req
 	u8_l  long_nav_en;
 	u8_l  cfe_en;
 	u8_l  rc_retry_cnt[3];
-	s8_l ccademod_th;
+	s8_l  ccademod_th;
+	u8_l  remove_1m2m;
 };
 
 struct mm_set_mac_timescale_req
@@ -1938,6 +2012,12 @@ struct mm_get_chip_temp_cfm
     s8_l degree;
 };
 
+struct mm_set_ap_ps_level_req
+{
+    u32_l hwconfig_id;
+    u8 ap_ps_level;
+};
+
 struct mm_set_vendor_hwconfig_cfm
 {
     u32_l hwconfig_id;
@@ -1946,6 +2026,31 @@ struct mm_set_vendor_hwconfig_cfm
     };
 };
 
+struct mm_set_customized_freq_req
+{
+	u32_l hwconfig_id;
+	u16_l raw_freq[4];
+	u16_l map_freq[4];
+};
+
+struct mm_set_wakeup_info_req
+{
+	u32_l hwconfig_id;
+	u16_l offset;
+	u8_l  length;
+	u8_l  mask_and_patten[];
+
+};
+
+struct mm_set_keepalive_req
+{
+	u32_l hwconfig_id;
+	u16_l code;
+	u16_l length;
+	u32_l intv;
+	u8_l payload[];
+};
+
 struct mm_set_txop_req
 {
 	u16_l txop_bk;
@@ -1956,6 +2061,22 @@ struct mm_set_txop_req
 	u8_l  cfe_en;
 };
 
+#ifdef CONFIG_APF
+struct mm_set_apf_prog_req {
+	u32_l program_len;
+	u32_l offset;
+	u8_l program[LMAC_MSG_MAX_LEN];
+};
+
+struct mm_get_apf_prog_req {
+	u16_l offset;
+};
+
+struct mm_get_apf_prog_cfm {
+	u8_l program[LMAC_MSG_MAX_LEN];
+};
+#endif
+
 struct mm_get_fw_version_cfm
 {
     u8_l fw_version_len;
@@ -2173,6 +2294,7 @@ struct me_set_ps_mode_req {
 struct me_set_lp_level_req {
 	/// Low Power level
 	u8_l lp_level;
+	u8_l disable_filter;
 };
 
 
@@ -2417,13 +2539,13 @@ struct apm_stop_req {
 /// Structure containing the parameters of the @ref APM_START_CAC_REQ message.
 struct apm_start_cac_req {
 	/// Control channel on which we have to start the CAC
-	struct mac_chan_def chan;
+	struct mac_chan_op chan;
 	/// Center frequency of the first segment
-	u32_l center_freq1;
+	//u32_l center_freq1;
 	/// Center frequency of the second segment (only in 80+80 configuration)
-	u32_l center_freq2;
+	//u32_l center_freq2;
 	/// Width of channel
-	u8_l ch_width;
+	//u8_l ch_width;
 	/// Index of the VIF for which the CAC is started
 	u8_l vif_idx;
 };
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
index 0f8777066936..c984c03f2eaf 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/regdb.c
@@ -2891,6 +2891,7 @@ const struct ieee80211_regdomain *reg_regdb[] = {
 	&regdom_YT,
 	&regdom_ZA,
 	&regdom_ZW,
+	NULL,
 };
 
 int reg_regdb_size = ARRAY_SIZE(reg_regdb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
index 36f4686ed9a0..5e1f5c608364 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.c
@@ -46,8 +46,8 @@ static void cmd_complete(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
 	//RWNX_DBG(RWNX_FN_ENTRY_STR);
 	lockdep_assert_held(&cmd_mgr->lock);
 
-	list_del(&cmd->list);
-	cmd_mgr->queue_sz--;
+	//list_del(&cmd->list);
+	//cmd_mgr->queue_sz--;
 
 	cmd->flags |= RWNX_CMD_FLAG_DONE;
 	if (cmd->flags & RWNX_CMD_FLAG_NONBLOCK) {
@@ -119,12 +119,32 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
 	struct aic_usb_dev *usbdev = container_of(cmd_mgr, struct aic_usb_dev, cmd_mgr);
 #endif
 	bool defer_push = false;
+	u8_l empty = 0;
 
 	//RWNX_DBG(RWNX_FN_ENTRY_STR);
 #ifdef CREATE_TRACE_POINTS
 	trace_msg_send(cmd->id);
 #endif
-	spin_lock_bh(&cmd_mgr->lock);
+	if(cmd->e2a_msg != NULL) {
+		do {
+			if(cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED)
+				break;
+			spin_lock_bh(&cmd_mgr->lock);
+			empty = list_empty(&cmd_mgr->cmds);
+			if(!empty) {
+				spin_unlock_bh(&cmd_mgr->lock);
+				if(in_softirq()) {
+					printk("in_softirq:check cmdqueue empty\n");
+					mdelay(10);
+				} else {
+					printk("check cmdqueue empty\n");
+					msleep(50);
+				}
+			}
+		} while(!empty);//wait for cmd queue empty
+	} else {
+		spin_lock_bh(&cmd_mgr->lock);
+	}
 
 	if (cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED) {
 		printk(KERN_CRIT"cmd queue crashed\n");
@@ -232,6 +252,10 @@ static int cmd_mgr_queue(struct rwnx_cmd_mgr *cmd_mgr, struct rwnx_cmd *cmd)
 			}
 			spin_unlock_bh(&cmd_mgr->lock);
 		} else {
+			spin_lock_bh(&cmd_mgr->lock);
+			list_del(&cmd->list);
+			cmd_mgr->queue_sz--;
+			spin_unlock_bh(&cmd_mgr->lock);
 			rwnx_cmd_free(cmd);//kfree(cmd);
 			if (!list_empty(&cmd_mgr->cmds))
 				WAKE_CMD_WORK(cmd_mgr);
@@ -347,8 +371,13 @@ void cmd_mgr_task_process(struct work_struct *work)
 					cmd_complete(cmd_mgr, next);
 				}
 				spin_unlock_bh(&cmd_mgr->lock);
-			} else
+			} else {
+				spin_lock_bh(&cmd_mgr->lock);
+				list_del(&next->list);
+				cmd_mgr->queue_sz--;
+				spin_unlock_bh(&cmd_mgr->lock);
 				rwnx_cmd_free(next);//kfree(next);
+			}
 		}
 	}
 
@@ -517,7 +546,7 @@ void aicwf_set_cmd_tx(void *dev, struct lmac_msg *msg, uint len)
     if (sdiodev->chipid == PRODUCT_ID_AIC8801 || sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         sdiodev->chipid == PRODUCT_ID_AIC8800DW)
         buffer[3] = 0x0;
-    else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+    else if (sdiodev->chipid == PRODUCT_ID_AIC8800D80 || sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
 	    buffer[3] = crc8_ponl_107(&buffer[0], 3); // crc8
 	index += 4;
 	//there is a dummy word
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
index b757a65cf1ce..d1ba11994193 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_cmds.h
@@ -24,7 +24,7 @@
 #ifdef AICWF_USB_SUPPORT
 #define RWNX_80211_CMD_TIMEOUT_MS    2000//300
 #else
-#define RWNX_80211_CMD_TIMEOUT_MS    3000//500//300
+#define RWNX_80211_CMD_TIMEOUT_MS    6000//500//300
 #endif
 #endif
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
index 1a8010528abe..49f5cdd032a2 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_compat.h
@@ -260,17 +260,14 @@ enum ieee80211_radiotap_he_mu_bits {
 
 #define STA_TDLS_INITIATOR(sta) 0
 
-#define REGULATORY_IGNORE_STALE_KICKOFF 0
 #else
 #define STA_TDLS_INITIATOR(sta) sta->tdls_initiator
+#endif
 
 #ifndef REGULATORY_IGNORE_STALE_KICKOFF
 #define REGULATORY_IGNORE_STALE_KICKOFF 0
 #endif
 
-#endif
-
-
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
 #define cfg80211_rx_mgmt(wdev, freq, rssi, buf, len, flags)             \
 	cfg80211_rx_mgmt(wdev, freq, rssi, buf, len, flags, GFP_ATOMIC)
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
index 5a284080581c..a5c72f102835 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_debugfs.c
@@ -1248,6 +1248,12 @@ static ssize_t rwnx_dbgfs_regdbg_write(struct file *file,
     	if(oper== 0) {
 		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
         	printk("[0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+	} else if (oper == 1) {
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("before write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
+		ret = rwnx_send_dbg_mem_block_write_req(priv, addr, 4, &val);
+		ret = rwnx_send_dbg_mem_read_req(priv, addr, &mem_read_cfm);
+		printk("after write : [0x%x] = [0x%x]\n", mem_read_cfm.memaddr, mem_read_cfm.memdata);
     	}
 
 	return count;
@@ -1261,7 +1267,7 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 {
 	struct rwnx_hw *priv = file->private_data;
 	char buf[64];
-	int32_t addr[13];
+	int32_t addr[14];
     int32_t addr_out[12];
 	u32_l hwconfig_id;
 	size_t len = min_t(size_t,count,sizeof(buf)-1);
@@ -1295,8 +1301,8 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
 			    break;}
 			addr[12] = ~addr[12] + 1;
 			ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
-			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x\n",
-                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12]);
+			printk("CHANNEL_ACCESS_REQ edca:%x,%x,%x,%x, vif:%x, retry_cnt:%x, rts:%x, long_nav:%x, cfe:%x, rc_retry_cnt:%x:%x:%x ccademod_th %x, remove_1m2m %x\n",
+                                addr[0],  addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7], addr[8], addr[9], addr[10], addr[11], addr[12], addr[13]);
 			break;
 		    case 2:
 			if(ret != 7) {
@@ -1334,6 +1340,14 @@ static ssize_t rwnx_dbgfs_vendor_hwconfig_write(struct file *file,
                     printk("CHIP_TEMP_GET_REQ degree=%d\n", addr_out[0]);
                 }
             break;
+			case 6://AP_PS_LEVEL_SET_REQ
+				if (ret != 2) {
+					printk("param error != 2\n");
+				} else {
+					ret = rwnx_send_vendor_hwconfig_req(priv, hwconfig_id, addr, NULL);
+					printk("AP_PS_LEVEL_SET_REQ lvl=%d\n", addr[0]);
+				}
+			break;
             default:
 			printk("param error\n");
 			break;
@@ -2082,7 +2096,7 @@ static ssize_t rwnx_dbgfs_last_rx_read(struct file *file,
 		nss = last_rx->ht.mcs / 8;;
 		gi = last_rx->ht.short_gi;
 	} else {
-		BUG_ON((mcs = legrates_lut[last_rx->leg_rate]) == -1);
+		BUG_ON((mcs = legrates_lut[last_rx->leg_rate].idx) == -1);
 		nss = 0;
 		gi = 0;
 	}
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
index 4e966dee2fad..cf4934150ac6 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_defs.h
@@ -580,12 +580,22 @@ struct amsdu_subframe_hdr {
 
 
 /* rwnx driver status */
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state);
 
 enum rwnx_drv_connect_status { 
 	RWNX_DRV_STATUS_DISCONNECTED = 0,
 	RWNX_DRV_STATUS_DISCONNECTING, 
 	RWNX_DRV_STATUS_CONNECTING, 
-	RWNX_DRV_STATUS_CONNECTED, 
+	RWNX_DRV_STATUS_CONNECTED,
+	RWNX_DRV_STATUS_ROAMING,
+};
+
+static const char *const s_conn_state[] = {
+    "RWNX_DRV_STATUS_DISCONNECTED",
+    "RWNX_DRV_STATUS_DISCONNECTING",
+    "RWNX_DRV_STATUS_CONNECTING",
+    "RWNX_DRV_STATUS_CONNECTED",
+    "RWNX_DRV_STATUS_ROAMING",
 };
 
 
@@ -706,7 +716,12 @@ struct rwnx_hw {
 
 #ifdef CONFIG_SCHED_SCAN
     bool is_sched_scan;
-#endif//CONFIG_SCHED_SCAN 
+#endif//CONFIG_SCHED_SCAN
+#ifdef CONFIG_TEMP_CONTROL
+	unsigned long started_jiffies;
+	s8_l temp;
+#endif
+
 };
 
 u8 *rwnx_build_bcn(struct rwnx_bcn *bcn, struct cfg80211_beacon_data *new);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
index cf63ccb0d178..9d00bc477328 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.c
@@ -55,7 +55,7 @@
 #ifdef CONFIG_SDIO_BT
 #include "aic_btsdio.h"
 #endif
-
+#include "aic_priv_cmd.h"
 
 #define RW_DRV_DESCRIPTION  "RivieraWaves 11nac driver for Linux cfg80211"
 #define RW_DRV_COPYRIGHT    "Copyright(c) 2015-2017 RivieraWaves"
@@ -770,8 +770,12 @@ static void rwnx_csa_finish(struct work_struct *ws)
 		cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
 		#endif
 	} else {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+		wiphy_lock(rwnx_hw->wiphy);
+#else
 		mutex_lock(&vif->wdev.mtx);
 		__acquire(&vif->wdev.mtx);
+#endif
 		spin_lock_bh(&rwnx_hw->cb_lock);
 		rwnx_chanctx_unlink(vif);
 		rwnx_chanctx_link(vif, csa->ch_idx, &csa->chandef);
@@ -788,8 +792,12 @@ static void rwnx_csa_finish(struct work_struct *ws)
 #else
 		cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+		wiphy_unlock(rwnx_hw->wiphy);
+#else
 		mutex_unlock(&vif->wdev.mtx);
 		__release(&vif->wdev.mtx);
+#endif
 	}
 	rwnx_del_csa(vif);
 }
@@ -913,6 +921,17 @@ void netdev_br_init(struct net_device *netdev)
 }
 #endif /* CONFIG_BR_SUPPORT */
 
+void rwnx_set_conn_state(atomic_t *drv_conn_state, int state){
+
+    if((int)atomic_read(drv_conn_state) != state){
+        AICWFDBG(LOGDEBUG, "%s drv_conn_state:%p %s --> %s \r\n", __func__, 
+            drv_conn_state,
+            s_conn_state[(int)atomic_read(drv_conn_state)], 
+            s_conn_state[state]);
+        
+        atomic_set(drv_conn_state, state);
+    }
+}
 
 /*********************************************************************
  * netdev callbacks
@@ -947,6 +966,12 @@ static int rwnx_open(struct net_device *dev)
 		}
 	}
 
+#ifdef AICWF_LATENCY_MODE
+	if ((testmode == 0) && (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT)) {
+		rwnx_send_me_set_lp_level(rwnx_hw, 1, 1);
+	}
+#endif
+
 #ifdef CONFIG_GPIO_WAKEUP
 //close lp mode
 //	rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 0);
@@ -970,7 +995,8 @@ static int rwnx_open(struct net_device *dev)
 	   if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC||
 		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) && testmode == 0)){
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) && testmode == 0)){
 		 if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_STATION || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT) {
 			rwnx_send_coex_req(rwnx_hw, 0, 1);
 		}
@@ -986,7 +1012,7 @@ static int rwnx_open(struct net_device *dev)
 	#endif
 
 	set_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
-	atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+	rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
 	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__, (int)rwnx_vif->drv_flags);
 
 	if (RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT || RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_GO) {
@@ -1071,8 +1097,20 @@ static int rwnx_open(struct net_device *dev)
 			//Configure the monitor channel
 			error = rwnx_send_config_monitor_req(rwnx_hw, &rwnx_hw->chanctx_table[rwnx_vif->ch_index].chan_def, NULL);
 		}
+#if defined(CONFIG_RWNX_MON_XMIT)
+        rwnx_txq_unk_vif_init(rwnx_vif);
+#endif
+#if defined(CONFIG_RWNX_MON_RXFILTER)
+        rwnx_send_set_filter(rwnx_hw, (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS | FIF_PSPOLL | FIF_PROBE_REQ));
+#endif
 	}
 
+#if defined(CONFIG_RWNX_MON_XMIT)
+    netif_carrier_on(dev);
+	AICWFDBG(LOGINFO, "monitor xmit: netif_carrier_on\n");
+#endif
+
+
 	#ifdef CONFIG_BR_SUPPORT
 		 netdev_br_init(dev);
 	#endif /* CONFIG_BR_SUPPORT */
@@ -1207,7 +1245,7 @@ static int rwnx_close(struct net_device *dev)
 				RWNX_VIF_TYPE(rwnx_vif) == NL80211_IFTYPE_P2P_CLIENT){
 				test_counter = waiting_counter;
 				if(atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
-					atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
+					rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 					rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, 3);
 					while (atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING) {
 						AICWFDBG(LOGDEBUG, "%s wifi is disconnecting, waiting 100ms for state to stable\r\n", __func__);
@@ -1276,1481 +1314,16 @@ static int rwnx_close(struct net_device *dev)
 	clear_bit(RWNX_DEV_STARTED, &rwnx_vif->drv_flags);
 	AICWFDBG(LOGDEBUG, "%s rwnx_vif->drv_flags:%d\r\n", __func__, (int)rwnx_vif->drv_flags);
 
-#ifdef CONFIG_GPIO_WAKEUP
-	//open lp mode
-	//rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, 1);
-#if defined(CONFIG_SDIO_PWRCTRL)
-		aicwf_sdio_pwr_stctl(g_rwnx_plat->sdiodev, SDIO_SLEEP_ST);
-#endif
-		ret = aicwf_sdio_writeb(g_rwnx_plat->sdiodev, g_rwnx_plat->sdiodev->sdio_reg.wakeup_reg, 2);
-		if (ret < 0) {
-			sdio_err("reg:%d write failed!\n", g_rwnx_plat->sdiodev->sdio_reg.wakeup_reg);
-		}
-#endif//CONFIG_GPIO_WAKEUP
-
 	return 0;
 }
-
-#ifdef CONFIG_RFTEST
-enum {
-	SET_TX,
-	SET_TXSTOP,
-	SET_TXTONE,
-	SET_RX,
-	GET_RX_RESULT,
-	SET_RXSTOP,
-	SET_RXMETER,
-	SET_POWER,
-	SET_XTAL_CAP,
-	SET_XTAL_CAP_FINE,
-	GET_EFUSE,
-	SET_FREQ_CAL,
-	SET_FREQ_CAL_FINE,
-	GET_FREQ_CAL,
-	SET_MAC_ADDR,
-	GET_MAC_ADDR,
-	SET_BT_MAC_ADDR,
-	GET_BT_MAC_ADDR,
-	SET_VENDOR_INFO,
-	GET_VENDOR_INFO,
-	RDWR_PWRMM,
-	RDWR_PWRIDX,
-	RDWR_PWRLVL = RDWR_PWRIDX,
-	RDWR_PWROFST,
-	RDWR_DRVIBIT,
-	RDWR_EFUSE_PWROFST,
-	RDWR_EFUSE_DRVIBIT,
-	SET_PAPR,
-	SET_CAL_XTAL,
-	GET_CAL_XTAL_RES,
-	SET_COB_CAL,
-	GET_COB_CAL_RES,
-	RDWR_EFUSE_USRDATA,
-	SET_NOTCH,
-    RDWR_PWROFSTFINE,
-    RDWR_EFUSE_PWROFSTFINE,
-    RDWR_EFUSE_SDIOCFG,
-    RDWR_EFUSE_USBVIDPID,
-    SET_SRRC,
-    SET_FSS,
-    RDWR_EFUSE_HE_OFF,
-};
-
-typedef struct {
-	u8_l chan;
-	u8_l bw;
-	u8_l mode;
-	u8_l rate;
-	u16_l length;
-	u16_l tx_intv_us;
-} cmd_rf_settx_t;
-
-typedef struct {
-	u8_l val;
-} cmd_rf_setfreq_t;
-
-typedef struct {
-	u8_l chan;
-	u8_l bw;
-} cmd_rf_rx_t;
-
-typedef struct {
-	u8_l block;
-} cmd_rf_getefuse_t;
-typedef struct
-{
-    u8_l dutid;
-    u8_l chip_num;
-    u8_l dis_xtal;
-}cmd_rf_setcobcal_t;
-typedef struct
- {
-     u16_l dut_rcv_golden_num;
-     u8_l golden_rcv_dut_num;
-     s8_l rssi_static;
-     s8_l snr_static;
-     s8_l dut_rssi_static;
-     u16_l reserved;
- }cob_result_ptr_t;
-#endif
-
-#define CMD_MAXARGS 10
-
-#if 0
-#define isblank(c)      ((c) == ' ' || (c) == '\t')
-#define isascii(c)      (((unsigned char)(c)) <= 0x7F)
-
-static int isdigit(unsigned char c)
-{
-	return ((c >= '0') && (c <= '9'));
-}
-
-static int isxdigit(unsigned char c)
-{
-	if ((c >= '0') && (c <= '9'))
-		return 1;
-	if ((c >= 'a') && (c <= 'f'))
-		return 1;
-	if ((c >= 'A') && (c <= 'F'))
-		return 1;
-	return 0;
-}
-
-static int islower(unsigned char c)
-{
-	return ((c >= 'a') && (c <= 'z'));
-}
-
-static unsigned char toupper(unsigned char c)
-{
-	if (islower(c))
-		c -= 'a' - 'A';
-	return c;
-}
-#endif
-
-
-static int parse_line (char *line, char *argv[])
-{
-	int nargs = 0;
-
-	while (nargs < CMD_MAXARGS) {
-		/* skip any white space */
-		while ((*line == ' ') || (*line == '\t')) {
-			++line;
-		}
-
-		if (*line == '\0') {    /* end of line, no more args    */
-			argv[nargs] = 0;
-			return nargs;
-		}
-
-		/* Argument include space should be bracketed by quotation mark */
-		if (*line == '\"') {
-			/* Skip quotation mark */
-			line++;
-
-			/* Begin of argument string */
-			argv[nargs++] = line;
-
-			/* Until end of argument */
-			while (*line && (*line != '\"')) {
-				++line;
-			}
-		} else {
-			argv[nargs++] = line;    /* begin of argument string    */
-
-			/* find end of string */
-			while (*line && (*line != ' ') && (*line != '\t')) {
-				++line;
-			}
-		}
-
-		if (*line == '\0') {    /* end of line, no more args    */
-			argv[nargs] = 0;
-			return nargs;
-		}
-
-		*line++ = '\0';         /* terminate current arg     */
-	}
-
-	printk("** Too many args (max. %d) **\n", CMD_MAXARGS);
-
-	return nargs;
-}
-
-unsigned int command_strtoul(const char *cp, char **endp, unsigned int base)
-{
-	unsigned int result = 0, value, is_neg = 0;
-
-	if (*cp == '0') {
-		cp++;
-		if ((*cp == 'x') && isxdigit(cp[1])) {
-			base = 16;
-			cp++;
-		}
-		if (!base) {
-			base = 8;
-		}
-	}
-	if (!base) {
-		base = 10;
-	}
-	if (*cp == '-') {
-		is_neg = 1;
-		cp++;
-	}
-	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp - '0' : (islower(*cp) ? toupper(*cp) : *cp) - 'A' + 10) < base) {
-		result = result * base + value;
-		cp++;
-	}
-	if (is_neg)
-		result = (unsigned int)((int)result * (-1));
-
-	if (endp)
-		*endp = (char *)cp;
-	return result;
-}
-
-
-int handle_private_cmd(struct net_device *net, char *command, u32 cmd_len)
-{
-	int bytes_written = 0;
-	char *para = NULL;
-	char *cmd = NULL;
-	char *argv[CMD_MAXARGS + 1];
-	int argc;
-#ifdef CONFIG_RFTEST
-	struct dbg_rftest_cmd_cfm cfm;
-	u8_l mac_addr[6];
-	cmd_rf_settx_t settx_param;
-	cmd_rf_rx_t setrx_param;
-	int freq;
-	cmd_rf_getefuse_t getefuse_param;
-	cmd_rf_setfreq_t cmd_setfreq;
-	cmd_rf_setcobcal_t setcob_cal;
-	u8_l ana_pwr;
-	u8_l dig_pwr;
-	u8_l pwr;
-	u8_l xtal_cap;
-	u8_l xtal_cap_fine;
-	u8_l vendor_info;
-	cob_result_ptr_t *cob_result_ptr;
-
-#endif
-
-	u8_l state;
-
-#ifdef CONFIG_GPIO_WAKEUP
-	u8_l setsusp_mode;
-	int ret = 0;
-#endif
-
-	RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-	argc = parse_line(command, argv);
-	if (argc == 0) {
-		return -1;
-	}
-
-	do {
-#ifdef CONFIG_RFTEST
-		if (strcasecmp(argv[0], "GET_RX_RESULT") == 0) {
-			AICWFDBG(LOGINFO, "get_rx_result\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, GET_RX_RESULT, 0, NULL, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 8);
-			bytes_written = 8;
-		} else if (strcasecmp(argv[0], "SET_TX") == 0) {
-			AICWFDBG(LOGINFO, "set_tx\n");
-			if (argc < 6) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			settx_param.chan = command_strtoul(argv[1], NULL, 10);
-			settx_param.bw = command_strtoul(argv[2], NULL, 10);
-			settx_param.mode = command_strtoul(argv[3], NULL, 10);
-			settx_param.rate = command_strtoul(argv[4], NULL, 10);
-			settx_param.length = command_strtoul(argv[5], NULL, 10);
-			if (argc > 6) {
-				settx_param.tx_intv_us = command_strtoul(argv[6], NULL, 10);
-			} else {
-				settx_param.tx_intv_us = 10000; // set default val 10ms
-			}
-			AICWFDBG(LOGINFO, "txparam:%d,%d,%d,%d,%d,%d\n", settx_param.chan, settx_param.bw,
-				settx_param.mode, settx_param.rate, settx_param.length, settx_param.tx_intv_us);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_TX, sizeof(cmd_rf_settx_t), (u8_l *)&settx_param, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_TXSTOP") == 0) {
-			AICWFDBG(LOGINFO, "settx_stop\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_TXSTOP, 0, NULL, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_TXTONE") == 0) {
-			AICWFDBG(LOGINFO, "set_tx_tone,argc:%d\n", argc);
-			if ((argc == 2) || (argc == 3)) {
-				u8_l func, buf[2];
-				s8_l freq;
-				AICWFDBG(LOGINFO, "argv 1:%s\n", argv[1]);
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-				if (argc == 3) {
-					AICWFDBG(LOGINFO, "argv 2:%s\n", argv[2]);
-					freq = (u8_l)command_strtoul(argv[2], NULL, 10);
-				} else {
-					freq = 0;
-				}
-				buf[0] = func;
-				buf[1] = (u8_l)freq;
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_TXTONE, argc - 1, buf, NULL);
-	#endif
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-			}
-		} else if (strcasecmp(argv[0], "SET_RX") == 0) {
-			AICWFDBG(LOGINFO, "set_rx\n");
-			if (argc < 3) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			setrx_param.chan = command_strtoul(argv[1], NULL, 10);
-			setrx_param.bw = command_strtoul(argv[2], NULL, 10);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_RX, sizeof(cmd_rf_rx_t), (u8_l *)&setrx_param, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_RXSTOP") == 0) {
-			AICWFDBG(LOGINFO, "set_rxstop\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_RXSTOP, 0, NULL, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_RX_METER") == 0) {
-			AICWFDBG(LOGINFO, "set_rx_meter\n");
-			freq = (int)command_strtoul(argv[1], NULL, 10);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_RXMETER, sizeof(freq), (u8_l *)&freq, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_RXMETER, sizeof(freq), (u8_l *)&freq, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_FREQ_CAL") == 0) {
-			AICWFDBG(LOGINFO, "set_freq_cal\n");
-			if (argc < 2) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-			AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_FREQ_CAL, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "SET_FREQ_CAL_FINE") == 0) {
-			AICWFDBG(LOGINFO, "set_freq_cal_fine\n");
-			if (argc < 2) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			cmd_setfreq.val = command_strtoul(argv[1], NULL, 16);
-			AICWFDBG(LOGINFO, "param:%x\r\n", cmd_setfreq.val);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_FREQ_CAL_FINE, sizeof(cmd_rf_setfreq_t), (u8_l *)&cmd_setfreq, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "GET_EFUSE") == 0) {
-			AICWFDBG(LOGINFO, "get_efuse\n");
-			if (argc < 2) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			getefuse_param.block = command_strtoul(argv[1], NULL, 10);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_EFUSE, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, GET_EFUSE, sizeof(cmd_rf_getefuse_t), (u8_l *)&getefuse_param, &cfm);
-	#endif
-			AICWFDBG(LOGINFO, "get val=%x\r\n", cfm.rftest_result[0]);
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "SET_POWER") == 0) {
-			AICWFDBG(LOGINFO, "set_power\n");
-			if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) {
-				ana_pwr = command_strtoul(argv[1], NULL, 16);
-				dig_pwr = command_strtoul(argv[2], NULL, 16);
-				pwr = (ana_pwr << 4 | dig_pwr);
-				if (ana_pwr > 0xf || dig_pwr > 0xf) {
-					AICWFDBG(LOGERROR, "invalid param\r\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				ana_pwr = command_strtoul(argv[1], NULL, 10);
-				pwr = ana_pwr;
-				if (ana_pwr > 0x1e) {
-					AICWFDBG(LOGERROR, "invalid param\r\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			}
-			AICWFDBG(LOGINFO, "pwr =%x\r\n", pwr);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_POWER, sizeof(pwr), (u8_l *)&pwr, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "SET_XTAL_CAP") == 0) {
-			AICWFDBG(LOGINFO, "set_xtal_cap\n");
-			if (argc < 2) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			xtal_cap = command_strtoul(argv[1], NULL, 10);
-			AICWFDBG(LOGINFO, "xtal_cap =%x\r\n", xtal_cap);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_XTAL_CAP, sizeof(xtal_cap), (u8_l *)&xtal_cap, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "SET_XTAL_CAP_FINE") == 0) {
-			AICWFDBG(LOGINFO, "set_xtal_cap_fine\n");
-			if (argc < 2) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			xtal_cap_fine = command_strtoul(argv[1], NULL, 10);
-			AICWFDBG(LOGINFO, "xtal_cap_fine =%x\r\n", xtal_cap_fine);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_XTAL_CAP_FINE, sizeof(xtal_cap_fine), (u8_l *)&xtal_cap_fine, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "SET_MAC_ADDR") == 0) {
-			printk("set_mac_addr\n");
-			if (argc < 7) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-			mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-			mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-			mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-			mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-			mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-			AICWFDBG(LOGINFO, "set macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-	#endif
-		} else if (strcasecmp(argv[0], "GET_MAC_ADDR") == 0) {
-			u32_l addr0, addr1;
-			AICWFDBG(LOGINFO, "get mac addr\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, GET_MAC_ADDR, 0, NULL, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 8);
-			bytes_written = 8;
-			addr0 = cfm.rftest_result[0];
-			if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-				(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) {
-				int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-				addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-				AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-			} else {
-				addr1 = cfm.rftest_result[1];
-				AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-			}
-		} else if (strcasecmp(argv[0], "SET_BT_MAC_ADDR") == 0) {
-			AICWFDBG(LOGINFO, "set_bt_mac_addr\n");
-			if (argc < 7) {
-				AICWFDBG(LOGERROR, "wrong param\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			mac_addr[5] = command_strtoul(argv[1], NULL, 16);
-			mac_addr[4] = command_strtoul(argv[2], NULL, 16);
-			mac_addr[3] = command_strtoul(argv[3], NULL, 16);
-			mac_addr[2] = command_strtoul(argv[4], NULL, 16);
-			mac_addr[1] = command_strtoul(argv[5], NULL, 16);
-			mac_addr[0] = command_strtoul(argv[6], NULL, 16);
-			AICWFDBG(LOGINFO, "set bt macaddr:%x,%x,%x,%x,%x,%x\n", mac_addr[5], mac_addr[4], mac_addr[3], mac_addr[2], mac_addr[1], mac_addr[0]);
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_BT_MAC_ADDR, sizeof(mac_addr), (u8_l *)&mac_addr, NULL);
-		} else if (strcasecmp(argv[0], "GET_BT_MAC_ADDR")==0) {
-			u32_l addr0, addr1;
-			AICWFDBG(LOGINFO, "get bt mac addr\n");
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_BT_MAC_ADDR, 0, NULL, &cfm);
-			memcpy(command, &cfm.rftest_result[0], 8);
-			bytes_written = 8;
-			addr0 = cfm.rftest_result[0];
-			if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-				(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) {
-				int rem_cnt = (cfm.rftest_result[1] >> 16) & 0x00FF;
-				addr1 = cfm.rftest_result[1] & 0x0000FFFF;
-				 AICWFDBG(LOGINFO, "0x%x,0x%x (remain:%x)\n", addr0, addr1, rem_cnt);
-			} else {
-				addr1 = cfm.rftest_result[1];
-				AICWFDBG(LOGINFO, "0x%x,0x%x\n", addr0, addr1);
-			}
-		} else if (strcasecmp(argv[0], "SET_VENDOR_INFO") == 0) {
-			vendor_info = command_strtoul(argv[1], NULL, 16);
-			AICWFDBG(LOGINFO, "set vendor info:%x\n", vendor_info);
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, SET_VENDOR_INFO, 1, &vendor_info, &cfm);
-	#endif
-			if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-				(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) {
-				memcpy(command, &cfm.rftest_result[0], 2);
-				bytes_written = 2;
-			} else {
-				memcpy(command, &cfm.rftest_result[0], 1);
-				bytes_written = 1;
-			}
-			AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-		} else if (strcasecmp(argv[0], "GET_VENDOR_INFO") == 0) {
-			AICWFDBG(LOGINFO, "get vendor info\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
-	#endif
-	#ifdef AICWF_USB_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->usbdev->rwnx_hw, GET_VENDOR_INFO, 0, NULL, &cfm);
-	#endif
-			if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-				(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) {
-				memcpy(command, &cfm.rftest_result[0], 2);
-				bytes_written = 2;
-			} else {
-				memcpy(command, &cfm.rftest_result[0], 1);
-				bytes_written = 1;
-			}
-			AICWFDBG(LOGINFO, "0x%x\n", cfm.rftest_result[0]);
-		} else if (strcasecmp(argv[0], "GET_FREQ_CAL") == 0) {
-			unsigned int val;
-			AICWFDBG(LOGINFO, "get freq cal\n");
-	#ifdef AICWF_SDIO_SUPPORT
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_FREQ_CAL, 0, NULL, &cfm);
-	#endif
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-			val = cfm.rftest_result[0];
-			if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-				(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) {
-				AICWFDBG(LOGINFO, "cap=0x%x (remain:%x), cap_fine=%x (remain:%x)\n",
-						val & 0xff, (val >> 8) & 0xff, (val >> 16) & 0xff, (val >> 24) & 0xff);
-			} else {
-				AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", val & 0xff, (val >> 8) & 0xff);
-			}
-		}  else if (strcasecmp(argv[0], "RDWR_PWRMM") == 0) {
-			AICWFDBG(LOGINFO, "read/write txpwr manul mode\n");
-			if (argc <= 1) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRMM, 0, NULL, &cfm);
-	#endif
-			} else { // write
-				u8_l pwrmm = (u8_l)command_strtoul(argv[1], NULL, 16);
-				pwrmm = (pwrmm) ? 1 : 0;
-				AICWFDBG(LOGINFO, "set pwrmm = %x\r\n", pwrmm);
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRMM, sizeof(pwrmm), (u8_l *)&pwrmm, &cfm);
-	#endif
-			}
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-		} else if (strcasecmp(argv[0], "RDWR_PWRIDX") == 0) {
-			u8_l func = 0;
-			#ifdef AICWF_SDIO_SUPPORT
-			if (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8801) {
-				AICWFDBG(LOGERROR, "unsupported cmd\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			#endif
-			AICWFDBG(LOGINFO, "read/write txpwr index\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRIDX, 0, NULL, &cfm);
-	#endif
-			} else if (func <= 2) { // write 2.4g/5g pwr idx
-				if (argc > 3) {
-					u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-					u8_l pwridx = (u8_l)command_strtoul(argv[3], NULL, 10);
-					u8_l buf[3] = {func, type, pwridx};
-					AICWFDBG(LOGINFO, "set pwridx:[%x][%x]=%x\r\n", func, type, pwridx);
-					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRIDX, sizeof(buf), buf, &cfm);
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-			memcpy(command, &cfm.rftest_result[0], 9);
-			bytes_written = 9;
-		} else if (strcasecmp(argv[0], "RDWR_PWRLVL") == 0) {
-			u8_l func = 0;
-			#ifdef AICWF_SDIO_SUPPORT
-			if ((g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800DC)
-			&& (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800DW)
-			&& (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
-				AICWFDBG(LOGINFO, "unsupported cmd\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-			#endif
-			AICWFDBG(LOGINFO, "read/write txpwr level\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRLVL, 0, NULL, &cfm);
-			} else if (func <= 2) { // write 2.4g/5g pwr lvl
-				if (argc > 4) {
-					u8_l grp = (u8_l)command_strtoul(argv[2], NULL, 16);
-					u8_l idx, size;
-					u8_l buf[14] = {func, grp,};
-					if (argc > 12) { // set all grp
-						AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
-						"  [%x] =", (func == 1) ? "2.4g" : "5g", grp);
-						if (grp == 1) { // TXPWR_LVL_GRP_11N_11AC
-							size = 10;
-						} else {
-							size = 12;
-						}
-						for (idx = 0; idx < size; idx++) {
-							s8_l pwrlvl = (s8_l)command_strtoul(argv[3 + idx], NULL, 10);
-							buf[2 + idx] = (u8_l)pwrlvl;
-							if (idx && !(idx & 0x3)) {
-								AICWFDBG(LOGINFO, " ");
-							}
-							AICWFDBG(LOGINFO, " %2d", pwrlvl);
-						}
-						AICWFDBG(LOGINFO, "\n");
-						size += 2;
-					} else { // set grp[idx]
-						u8_l idx = (u8_l)command_strtoul(argv[3], NULL, 10);
-						s8_l pwrlvl = (s8_l)command_strtoul(argv[4], NULL, 10);
-						buf[2] = idx;
-						buf[3] = (u8_l)pwrlvl;
-						size = 4;
-						AICWFDBG(LOGINFO, "set pwrlvl %s:\n"
-						"  [%x][%d] = %d\n", (func == 1) ? "2.4g" : "5g", grp, idx, pwrlvl);
-					}
-					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWRLVL, size, buf, &cfm);
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-			if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
-				memcpy(command, &cfm.rftest_result[0], 6 * 12);
-				bytes_written = 6 * 12;
-			} else {
-				memcpy(command, &cfm.rftest_result[0], 3 * 12);
-				bytes_written = 3 * 12;
-			}
-		} else if (strcasecmp(argv[0], "RDWR_PWROFST") == 0) {
-			u8_l func = 0;
-            int res_len = 0;
-			AICWFDBG(LOGINFO, "read/write txpwr offset\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, 0, NULL, &cfm);
-	#endif
-			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if ((argc > 4) && (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80)) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
-                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
-                    printk("set pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
-                    #ifdef AICWF_SDIO_SUPPORT
-                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
-                    #endif
-                } else if ((argc > 3) && (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
-					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-					printk("set pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
-	#ifdef AICWF_SDIO_SUPPORT
-					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFST, sizeof(buf), buf, &cfm);
-	#endif
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-            if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 3 = 3 (2.4g)
-                res_len = 3;
-            } else if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
-                res_len = 3 * 3 + 3 * 6;
-            } else {
-                res_len = 3 + 4;
-            }
-			memcpy(command, &cfm.rftest_result[0], res_len);
-			bytes_written = res_len;
-        } else if (strcasecmp(argv[0], "RDWR_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 7);
-            bytes_written = 7;
-		} else if (strcasecmp(argv[0], "RDWR_DRVIBIT") == 0) {
-			u8_l func = 0;
-			AICWFDBG(LOGINFO, "read/write pa drv_ibit\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_DRVIBIT, 0, NULL, &cfm);
-	#endif
-			} else if (func == 1) { // write 2.4g pa drv_ibit
-				if (argc > 2) {
-					u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-					u8_l buf[2] = {func, ibit};
-					printk("set drvibit:[%x]=%x\r\n", func, ibit);
-	#ifdef AICWF_SDIO_SUPPORT
-					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_DRVIBIT, sizeof(buf), buf, &cfm);
-	#endif
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-			memcpy(command, &cfm.rftest_result[0], 16);
-			bytes_written = 16;
-		} else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFST") == 0) {
-			u8_l func = 0;
-            int res_len = 0;
-			AICWFDBG(LOGINFO, "read/write txpwr offset into efuse\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, 0, NULL, &cfm);
-	#endif
-			} else if (func <= 2) { // write 2.4g/5g pwr ofst
-				if ((argc > 4) && (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80)) {
-                    u8_l type = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    u8_l chgrp = (u8_l)command_strtoul(argv[3], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[4], NULL, 10);
-                    u8_l buf[4] = {func, type, chgrp, (u8_l)pwrofst};
-                    printk("set efuse pwrofst_%s:[%x][%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", type, chgrp, pwrofst);
-                    #ifdef AICWF_SDIO_SUPPORT
-                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
-                    #endif
-                } else if ((argc > 3) && (g_rwnx_plat->sdiodev->chipid != PRODUCT_ID_AIC8800D80)) {
-					u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-					s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-					u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-					printk("set efuse pwrofst_%s:[%x]=%d\r\n", (func == 1) ? "2.4g" : "5g", chgrp, pwrofst);
-	#ifdef AICWF_SDIO_SUPPORT
-					rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFST, sizeof(buf), buf, &cfm);
-	#endif
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-            if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                res_len = 3 * 2;
-            } else if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80) { // 3 * 2 (2.4g) + 3 * 6 (5g)
-                res_len = 3 * 3 + 3 * 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                res_len = 3 + 4;
-            }
-            memcpy(command, &cfm.rftest_result[0], res_len);
-            bytes_written = res_len;
-		} else if (strcasecmp(argv[0], "RDWR_EFUSE_DRVIBIT") == 0) {
-			u8_l func = 0;
-			AICWFDBG(LOGINFO, "read/write pa drv_ibit into efuse\n");
-			if (argc > 1) {
-				func = (u8_l)command_strtoul(argv[1], NULL, 16);
-			}
-			if (func == 0) { // read cur
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_DRVIBIT, 0, NULL, &cfm);
-	#endif
-			} else if (func == 1) { // write 2.4g pa drv_ibit
-				if (argc > 2) {
-				u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-				u8_l buf[2] = {func, ibit};
-				AICWFDBG(LOGINFO, "set efuse drvibit:[%x]=%x\r\n", func, ibit);
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_DRVIBIT, sizeof(buf), buf, &cfm);
-	#endif
-				} else {
-					AICWFDBG(LOGERROR, "wrong args\n");
-					bytes_written = -EINVAL;
-					break;
-				}
-			} else {
-				AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-				bytes_written = -EINVAL;
-				break;
-			}
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_PWROFSTFINE") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write txpwr offset fine into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFSTFINE, 0, NULL, &cfm);
-            } else if (func <= 2) { // write 2.4g/5g pwr ofst
-                if (argc > 3) {
-                    u8_l chgrp = (u8_l)command_strtoul(argv[2], NULL, 16);
-                    s8_l pwrofst = (u8_l)command_strtoul(argv[3], NULL, 10);
-                    u8_l buf[3] = {func, chgrp, (u8_l)pwrofst};
-                    AICWFDBG(LOGINFO, "set efuse pwrofstfine:[%x][%x]=%d\r\n", func, chgrp, pwrofst);
-                    rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_PWROFSTFINE, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            if ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-                (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW)) { // 6 = 3 (2.4g) * 2
-                memcpy(command, &cfm.rftest_result[0], 6);
-                bytes_written = 6;
-            } else { // 7 = 3(2.4g) + 4(5g)
-                memcpy(command, &cfm.rftest_result[0], 7);
-                bytes_written = 7;
-            }
-		} else if (strcasecmp(argv[0], "SET_PAPR") == 0) {
-			AICWFDBG(LOGINFO, "set papr\n");
-			if (argc > 1) {
-				u8_l func = (u8_l) command_strtoul(argv[1], NULL, 10);
-				AICWFDBG(LOGINFO, "papr %d\r\n", func);
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_PAPR, sizeof(func), &func, NULL);
-	#endif
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-		} else if (strcasecmp(argv[0], "SET_NOTCH") == 0) {
-			if (argc > 1) {
-				u8_l func = (u8_l) command_strtoul(argv[1], NULL, 10);
-				AICWFDBG(LOGINFO, "set notch %d\r\n", func);
-	#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_NOTCH, sizeof(func), &func, NULL);
-	#endif
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-		} else if (strcasecmp(argv[0], "SET_SRRC") == 0) {
-			if (argc > 1) {
-				u8_l func = (u8_l) command_strtoul(argv[1], NULL, 10);
-				AICWFDBG(LOGINFO, "set srrc %d\r\n", func);
-				#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_SRRC, sizeof(func), &func, NULL);
-				#endif
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-		} else if (strcasecmp(argv[0], "SET_FSS") == 0) {
-			if (argc > 1) {
-				u8_l func = (u8_l) command_strtoul(argv[1], NULL, 10);
-				AICWFDBG(LOGINFO, "set fss: %d\r\n", func);
-				#ifdef AICWF_SDIO_SUPPORT
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_FSS, sizeof(func), &func, NULL);
-				#endif
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-		} else if (strcasecmp(argv[0], "RDWR_EFUSE_HE_OFF") == 0) {
-			if (argc > 1) {
-				u8_l func = command_strtoul(argv[1], NULL, 10);
-				AICWFDBG(LOGINFO, "set he off: %d\n", func);
-				rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_HE_OFF, sizeof(func), (u8_l *)&func, &cfm);
-				AICWFDBG(LOGINFO, "he_off cfm: %d\n", cfm.rftest_result[0]);
-				memcpy(command, &cfm.rftest_result[0], 4);
-				bytes_written = 4;
-			} else {
-				AICWFDBG(LOGERROR, "wrong args\n");
-				bytes_written = -EINVAL;
-				break;
-			}
-		} else if (strcasecmp(argv[0], "SET_COB_CAL") == 0) {
-				   AICWFDBG(LOGINFO, "set_cob_cal\n");
-				   if (argc < 3) {
-					   AICWFDBG(LOGERROR, "wrong param\n");
-					   bytes_written = -EINVAL;
-					   break;
-				   }
-				   setcob_cal.dutid = command_strtoul(argv[1], NULL, 10);
-				   setcob_cal.chip_num = command_strtoul(argv[2], NULL, 10);
-				   setcob_cal.dis_xtal = command_strtoul(argv[3], NULL, 10);
-				   rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-		} else if (strcasecmp(argv[0], "GET_COB_CAL_RES")==0) {
-			AICWFDBG(LOGINFO, "get cob cal res\n");
-			rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-			memcpy(command, &cfm.rftest_result[0], 4);
-			bytes_written = 4;
-			AICWFDBG(LOGINFO, "cap=0x%x, cap_fine=0x%x\n", cfm.rftest_result[0] & 0x0000ffff, (cfm.rftest_result[0] >> 16) & 0x0000ffff);
-		} else if (strcasecmp(argv[0], "DO_COB_TEST") == 0) {
-             AICWFDBG(LOGINFO, "do_cob_test\n");
-             setcob_cal.dutid = 1;
-             setcob_cal.chip_num = 1;
-             setcob_cal.dis_xtal = 0;
-             if (argc > 1 ) {
-                 setcob_cal.dis_xtal = command_strtoul(argv[1], NULL, 10);
-             }
-             rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, SET_COB_CAL, sizeof(cmd_rf_setcobcal_t), (u8_l *)&setcob_cal, NULL);
-             msleep(2000);
-             rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, GET_COB_CAL_RES, 0, NULL, &cfm);
-             state = (cfm.rftest_result[0] >> 16) & 0x000000ff;
-             if (!state){
-                 AICWFDBG(LOGINFO, "cap= 0x%x, cap_fine= 0x%x, freq_ofst= %d Hz\n",
-                 cfm.rftest_result[0] & 0x000000ff, (cfm.rftest_result[0] >> 8) & 0x000000ff, cfm.rftest_result[1]);
-                 cob_result_ptr = (cob_result_ptr_t *) & (cfm.rftest_result[2]);
-                 AICWFDBG(LOGINFO, "golden_rcv_dut= %d , tx_rssi= %d dBm, snr = %d dB\ndut_rcv_godlden= %d , rx_rssi= %d dBm",
-                 cob_result_ptr->golden_rcv_dut_num, cob_result_ptr->rssi_static, cob_result_ptr->snr_static,
-                 cob_result_ptr->dut_rcv_golden_num, cob_result_ptr->dut_rssi_static);
-                 memcpy(command, &cfm.rftest_result, 16);
-                 bytes_written = 16;
-             } else {
-                 AICWFDBG(LOGERROR, "cob not idle\n");
-                 bytes_written = -EINVAL;
-                 break;
-             }
-        } else if (strcasecmp(argv[0], "RDWR_EFUSE_SDIOCFG") == 0) {
-            u8_l func = 0;
-            AICWFDBG(LOGINFO, "read/write sdiocfg_bit into efuse\n");
-            if (argc > 1) {
-                func = (u8_l)command_strtoul(argv[1], NULL, 16);
-            }
-            if (func == 0) { // read cur
-                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_SDIOCFG, 0, NULL, &cfm);
-            } else if (func == 1) { // write sdiocfg
-                if (argc > 2) {
-                u8_l ibit = (u8_l)command_strtoul(argv[2], NULL, 16);
-                u8_l buf[2] = {func, ibit};
-                AICWFDBG(LOGINFO, "set efuse sdiocfg:[%x]=%x\r\n", func, ibit);
-                rwnx_send_rftest_req(g_rwnx_plat->sdiodev->rwnx_hw, RDWR_EFUSE_SDIOCFG, sizeof(buf), buf, &cfm);
-                } else {
-                    AICWFDBG(LOGERROR, "wrong args\n");
-                    bytes_written = -EINVAL;
-                    break;
-                }
-            } else {
-                AICWFDBG(LOGERROR, "wrong func: %x\n", func);
-                bytes_written = -EINVAL;
-                break;
-            }
-            memcpy(command, &cfm.rftest_result[0], 4);
-            bytes_written = 4;
-		} else if (strcasecmp(argv[0], "SETSUSPENDMODE") == 0 && testmode == 0) {
-	#ifdef AICWF_SDIO_SUPPORT
-			#ifdef CONFIG_GPIO_WAKEUP
-			setsusp_mode = command_strtoul(argv[1], NULL, 10);
-			rwnx_send_me_set_lp_level(g_rwnx_plat->sdiodev->rwnx_hw, setsusp_mode);
-			if (setsusp_mode == 1) {
-				#if defined(CONFIG_SDIO_PWRCTRL)
-				aicwf_sdio_pwr_stctl(g_rwnx_plat->sdiodev, SDIO_SLEEP_ST);
-				#endif
-
-				ret = aicwf_sdio_writeb(g_rwnx_plat->sdiodev, SDIOWIFI_WAKEUP_REG, 2);
-				if (ret < 0) {
-					sdio_err("reg:%d write failed!\n", SDIOWIFI_WAKEUP_REG);
-				}
-			}
-			AICWFDBG(LOGINFO, "set suspend mode %d\n", setsusp_mode);
-			#endif//CONFIG_GPIO_WAKEUP
-	#endif
-		} else {
-			AICWFDBG(LOGERROR, "wrong cmd:%s in %s\n", cmd, __func__);
-			bytes_written = -EINVAL;
-		}
-#endif
-	} while (0);
-	kfree(cmd);
-	kfree(para);
-	return bytes_written;
-}
-
-//Android private command
-
-#define RWNX_COUNTRY_CODE_LEN 2
-#define CMD_SET_COUNTRY "COUNTRY"
-#define CMD_SET_VENDOR_EX_IE "SET_VENDOR_EX_IE"
-#define CMD_SET_AP_WPS_P2P_IE "SET_AP_WPS_P2P_IE"
-
-struct ieee80211_regdomain *getRegdomainFromRwnxDB(struct wiphy *wiphy, char *alpha2);
-struct ieee80211_regdomain *getRegdomainFromRwnxDBIndex(struct wiphy *wiphy, int index);
-extern int reg_regdb_size;
-
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-extern u8_l vendor_extension_data[256];
-extern int vendor_extension_len;
-
-void set_vendor_extension_ie(char *command){
-
-	char databyte[3]={0x00, 0x00, 0x00};
-	int skip = strlen(CMD_SET_VENDOR_EX_IE) + 1;
-	int command_index = skip;
-	int data_index = 0;
-
-	memset(vendor_extension_data, 0, 256);
-	vendor_extension_len = 0;
-	memcpy(databyte, command + command_index, 2);
-	vendor_extension_len = command_strtoul(databyte, NULL, 16);
-	printk("%s len:%d \r\n", __func__, vendor_extension_len);
-
-	//parser command and save data in vendor_extension_data
-	for(data_index = 0;data_index < vendor_extension_len; data_index++){
-		command_index = command_index + 3;
-		memcpy(databyte, command + command_index, 2);
-		vendor_extension_data[data_index] = command_strtoul(databyte, NULL, 16);
-	}
-
+    
+#if defined(CONFIG_PLATFORM_ROCKCHIP) || defined(CONFIG_PLATFORM_ROCKCHIP2)
+#ifdef CONFIG_SHUTDOWN_CALLBACK
+int rwnx_close_(struct net_device *dev){
+	return rwnx_close(dev);
 }
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-
-
-int android_priv_cmd(struct net_device *net, struct ifreq *ifr, int cmd)
-{
-#define PRIVATE_COMMAND_MAX_LEN 8192
-#define PRIVATE_COMMAND_DEF_LEN 4096
-
-	struct rwnx_vif *vif = netdev_priv(net);
-	int ret = 0;
-	char *command = NULL;
-	int bytes_written = 0;
-	android_wifi_priv_cmd priv_cmd;
-	int buf_size = 0;
-	int skip = 0;
-	char *country = NULL;
-	struct ieee80211_regdomain *regdomain;
-
-	RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-	///todo: add our lock
-	//net_os_wake_lock(net);
-
-
-/*	if (!capable(CAP_NET_ADMIN)) {
-		ret = -EPERM;
-		goto exit;
-	}*/
-	if (!ifr->ifr_data) {
-		ret = -EINVAL;
-		goto exit;
-	}
-
-#ifdef CONFIG_COMPAT
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
-	if (in_compat_syscall())
-#else
-	if (is_compat_task())
-#endif
-	{
-		compat_android_wifi_priv_cmd compat_priv_cmd;
-		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
-		ret = -EFAULT;
-			goto exit;
-		}
-		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
-		priv_cmd.used_len = compat_priv_cmd.used_len;
-		priv_cmd.total_len = compat_priv_cmd.total_len;
-	} else
-#endif /* CONFIG_COMPAT */
-	{
-		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
-		ret = -EFAULT;
-			goto exit;
-		}
-	}
-	if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
-		printk("%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
-		ret = -EINVAL;
-		goto exit;
-	}
-
-	buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
-	command = kmalloc((buf_size + 1), GFP_KERNEL);
-
-	if (!command) {
-		printk("%s: failed to allocate memory\n", __FUNCTION__);
-		ret = -ENOMEM;
-		goto exit;
-	}
-	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
-		ret = -EFAULT;
-		goto exit;
-	}
-	command[priv_cmd.total_len] = '\0';
-
-	/* outputs */
-	AICWFDBG(LOGINFO, "%s: Android private cmd \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
-	AICWFDBG(LOGINFO, "cmd = %d\n", cmd);
-	AICWFDBG(LOGINFO, "buf_size=%d\n", buf_size);
-
-#if 1//Handle Android command
-		if(!strncasecmp(command, CMD_SET_COUNTRY, strlen(CMD_SET_COUNTRY))) {
-			skip = strlen(CMD_SET_COUNTRY) + 1;
-			country = command + skip;
-			if (!country || strlen(country) < RWNX_COUNTRY_CODE_LEN) {
-				printk("%s: invalid country code\n", __func__);
-				ret = -EINVAL;
-				goto exit;
-			}
-#if 0
-			for(index = 0; index < reg_regdb_size; index++){
-				regdomain = getRegdomainFromRwnxDBIndex(vif->rwnx_hw->wiphy, index);
-				if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-					printk("regulatory_set_wiphy_regd fail \r\n");
-				}else{
-					printk("regulatory_set_wiphy_regd ok \r\n");
-				}
-			}
-#endif
-			AICWFDBG(LOGINFO, "%s country code:%c%c\n", __func__, toupper(country[0]), toupper(country[1]));
-			regdomain = getRegdomainFromRwnxDB(vif->rwnx_hw->wiphy, country);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-			if((ret = regulatory_set_wiphy_regd(vif->rwnx_hw->wiphy, regdomain))){
-				printk("regulatory_set_wiphy_regd fail \r\n");
-			}
-#else
-			wiphy_apply_custom_regulatory(vif->rwnx_hw->wiphy, regdomain);
 #endif
-		}
-#ifdef CONFIG_SET_VENDOR_EXTENSION_IE
-		else if(!strncasecmp(command, CMD_SET_VENDOR_EX_IE, strlen(CMD_SET_VENDOR_EX_IE))){
-			set_vendor_extension_ie(command);
-		}
-#endif//CONFIG_SET_VENDOR_EXTENSION_IE
-		else if(!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE, strlen(CMD_SET_AP_WPS_P2P_IE))){
-			ret = 0;
-			goto exit;
-		}
-#endif//Handle Android command
-
-	bytes_written = handle_private_cmd(net, command, priv_cmd.total_len);
-	if (bytes_written >= 0) {
-		if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
-			command[0] = '\0';
-		}
-		if (bytes_written >= priv_cmd.total_len) {
-			printk("%s: err. bytes_written:%d >= buf_size:%d \n",
-				__FUNCTION__, bytes_written, buf_size);
-			goto exit;
-		}
-		bytes_written++;
-		priv_cmd.used_len = bytes_written;
-		if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
-			printk("%s: failed to copy data to user buffer\n", __FUNCTION__);
-			ret = -EFAULT;
-		}
-	} else {
-		/* Propagate the error */
-		ret = bytes_written;
-	}
-
-exit:
-	///todo: add our unlock
-	//net_os_wake_unlock(net);
-	kfree(command);
-	return ret;
-}
-
-#ifdef CONFIG_MCU_MESSAGE
-#define CMD_GET_VERSION_STR "GET_VERSION"
-#define CMD_GET_SSID_STR    "GET_SSID"
-#define CMD_SET_SSID_STR    "SET_SSID"
-#define CMD_GET_PASS_STR    "GET_PASS"
-#define CMD_SET_PASS_STR    "SET_PASS"
-#define CMD_GET_VAR_STR     "GET_VAR"
-#define CMD_SET_VAR_STR     "SET_VAR"
-
-enum custmsg_cmd_tag
-{
-    CUST_CMD_GET_VERSION = 0,
-    CUST_CMD_GET_SSID,
-    CUST_CMD_SET_SSID,
-    CUST_CMD_GET_PASS,
-    CUST_CMD_SET_PASS,
-    CUST_CMD_GET_VAR,
-    CUST_CMD_SET_VAR,
-    CUST_CMD_MAX
-};
-
-int handle_custom_msg(char *command, u32 cmd_len)
-{
-    int bytes_read = 0, max_bytes_to_read = 0;
-    struct rwnx_hw *p_rwnx_hw = NULL;
-    u32 cmd, len = 0, flags = 0;
-    char *buf = NULL;
-    struct dbg_custom_msg_cfm *cust_msg_cfm;
-    printk("cmd,%s,%ld\n",command,strlen(command));
-    if (strncasecmp(command, CMD_GET_VERSION_STR, strlen(CMD_GET_VERSION_STR)) == 0) {
-        cmd = CUST_CMD_GET_VERSION;
-        max_bytes_to_read = 32; // max str len for version
-    } else if (strncasecmp(command, CMD_GET_SSID_STR, strlen(CMD_GET_SSID_STR)) == 0) {
-        cmd = CUST_CMD_GET_SSID;
-        max_bytes_to_read = 48; // max str len for ssid
-    } else if (strncasecmp(command, CMD_SET_SSID_STR, strlen(CMD_SET_SSID_STR)) == 0) {
-        cmd = CUST_CMD_SET_SSID;
-        len = cmd_len - (strlen(CMD_SET_SSID_STR) + 1);
-        buf = command + (strlen(CMD_SET_SSID_STR) + 1);
-        max_bytes_to_read = 0;
-    } else if (strncasecmp(command, CMD_GET_PASS_STR, strlen(CMD_GET_PASS_STR)) == 0) {
-        cmd = CUST_CMD_GET_PASS;
-        max_bytes_to_read = 64; // max str len for PASS
-    } else if (strncasecmp(command, CMD_SET_PASS_STR, strlen(CMD_SET_PASS_STR)) == 0) {
-        cmd = CUST_CMD_SET_PASS;
-        len = cmd_len - (strlen(CMD_SET_PASS_STR) + 1);
-        buf = command + (strlen(CMD_SET_PASS_STR) + 1);
-        max_bytes_to_read = 0;
-    } else if (strncasecmp(command, CMD_GET_VAR_STR, strlen(CMD_GET_VAR_STR)) == 0) {
-        cmd = CUST_CMD_GET_VAR;
-        max_bytes_to_read = 64; // max str len for VAR
-    } else if (strncasecmp(command, CMD_SET_VAR_STR, strlen(CMD_SET_VAR_STR)) == 0) {
-        cmd = CUST_CMD_SET_VAR;
-        len = cmd_len - (strlen(CMD_SET_VAR_STR) + 1);
-        buf = command + (strlen(CMD_SET_VAR_STR) + 1);
-        max_bytes_to_read = 0;
-    } else {
-        printk("invalid cmd: %s\r\n", command);
-        return -1;
-    }
-    if (len < 0) {
-        printk("invalid len: %d\r\n", len);
-        return -3;
-    }
-    #ifdef AICWF_SDIO_SUPPORT
-    p_rwnx_hw = g_rwnx_plat->sdiodev->rwnx_hw;
-    #endif
-    #ifdef AICWF_USB_SUPPORT
-    p_rwnx_hw = g_rwnx_plat->usbdev->rwnx_hw;
-    #endif
-    cust_msg_cfm = (struct dbg_custom_msg_cfm *)kmalloc((offsetof(struct dbg_custom_msg_cfm, buf) + max_bytes_to_read), GFP_KERNEL);
-    if (cust_msg_cfm == NULL) {
-        printk("msg cfm alloc fail\r\n");
-        return -2;
-    }
-    rwnx_send_dbg_custom_msg_req(p_rwnx_hw, cmd, buf, len, flags, cust_msg_cfm);
-    bytes_read = cust_msg_cfm->len;
-    printk("Custom msg cfm: cmd=%d, len=%d, status=%x\n", cust_msg_cfm->cmd, bytes_read, cust_msg_cfm->status);
-    if (bytes_read) {
-        memcpy(command, cust_msg_cfm->buf, bytes_read);
-        command[bytes_read] = '\0';
-    } else {
-        command[0] = '\0';
-    }
-    if (cust_msg_cfm->status) {
-        printk("cfm status: %x", cust_msg_cfm->status);
-    }
-    return bytes_read;
-}
-
-int devipc_cust_msg(struct net_device *net, struct ifreq *ifr, int cmd)
-{
-#ifdef PRIVATE_COMMAND_MAX_LEN
-#undef PRIVATE_COMMAND_MAX_LEN
-#undef PRIVATE_COMMAND_DEF_LEN
-#define PRIVATE_COMMAND_MAX_LEN 8192
-#define PRIVATE_COMMAND_DEF_LEN 4096
 #endif
-    int ret = 0;
-    char *command = NULL;
-    int bytes_written = 0;
-    android_wifi_priv_cmd priv_cmd;
-    int buf_size = 0;
-
-    RWNX_DBG(RWNX_FN_ENTRY_STR);
-
-    ///todo: add our lock
-    //net_os_wake_lock(net);
-
-
-/*    if (!capable(CAP_NET_ADMIN)) {
-        ret = -EPERM;
-        goto exit;
-    }*/
-    if (!ifr->ifr_data) {
-        ret = -EINVAL;
-        goto exit;
-    }
-
-#ifdef CONFIG_COMPAT
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
-    if (in_compat_syscall())
-#else
-    if (is_compat_task())
-#endif
-    {
-        compat_android_wifi_priv_cmd compat_priv_cmd;
-        if (copy_from_user(&compat_priv_cmd, ifr->ifr_data, sizeof(compat_android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-        priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
-        priv_cmd.used_len = compat_priv_cmd.used_len;
-        priv_cmd.total_len = compat_priv_cmd.total_len;
-    } else
-#endif /* CONFIG_COMPAT */
-    {
-        if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(android_wifi_priv_cmd))) {
-	    ret = -EFAULT;
-            goto exit;
-        }
-    }
-    if ((priv_cmd.total_len > PRIVATE_COMMAND_MAX_LEN) || (priv_cmd.total_len < 0)) {
-        printk("%s: buf length invalid:%d\n", __FUNCTION__, priv_cmd.total_len);
-        ret = -EINVAL;
-        goto exit;
-    }
-
-    buf_size = max(priv_cmd.total_len, PRIVATE_COMMAND_DEF_LEN);
-    command = kmalloc((buf_size + 1), GFP_KERNEL);
-
-    if (!command)
-    {
-        printk("%s: failed to allocate memory\n", __FUNCTION__);
-        ret = -ENOMEM;
-        goto exit;
-    }
-    if (copy_from_user(command, priv_cmd.buf, priv_cmd.used_len)) {
-        ret = -EFAULT;
-        goto exit;
-    }
-    command[priv_cmd.used_len] = '\0';
-
-    /* outputs */
-    printk("%s: Devipc custom msg \"%s\" on %s\n", __FUNCTION__, command, ifr->ifr_name);
-    printk("cmd = %x\n", cmd);
-    printk("buf_size=%d\n", buf_size);
-
-
-    bytes_written = handle_custom_msg(command, priv_cmd.used_len);
-    if (bytes_written >= 0) {
-        if ((bytes_written == 0) && (priv_cmd.total_len > 0)) {
-            command[0] = '\0';
-        }
-        if (bytes_written >= priv_cmd.total_len) {
-            printk("%s: err. bytes_written:%d >= buf_size:%d \n",
-                __FUNCTION__, bytes_written, buf_size);
-            goto exit;
-        }
-        bytes_written++;
-        priv_cmd.used_len = bytes_written;
-        if (copy_to_user(priv_cmd.buf, command, bytes_written)) {
-            printk("%s: failed to copy data to user buffer\n", __FUNCTION__);
-            ret = -EFAULT;
-        }
-    }
-    else {
-        /* Propagate the error */
-        ret = bytes_written;
-    }
-
-exit:
-    ///todo: add our unlock
-    //net_os_wake_unlock(net);
-    kfree(command);
-    return ret;
-}
-#endif
-
 
 #define IOCTL_HOSTAPD   (SIOCIWFIRSTPRIV+28)
 #define IOCTL_WPAS      (SIOCIWFIRSTPRIV+30)
@@ -2867,6 +1440,15 @@ static const struct net_device_ops rwnx_netdev_ops = {
 static const struct net_device_ops rwnx_netdev_monitor_ops = {
 	.ndo_open               = rwnx_open,
 	.ndo_stop               = rwnx_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+    .ndo_siocdevprivate     = rwnx_do_ioctl,
+#else
+    .ndo_do_ioctl           = rwnx_do_ioctl,
+#endif
+#ifdef CONFIG_RWNX_MON_XMIT
+    .ndo_start_xmit         = rwnx_start_monitor_if_xmit,
+    .ndo_select_queue       = rwnx_select_queue,
+#endif
 	.ndo_get_stats          = rwnx_get_stats,
 	.ndo_set_mac_address    = rwnx_set_mac_address,
 };
@@ -3063,7 +1645,7 @@ static struct rwnx_vif *rwnx_interface_add(struct rwnx_hw *rwnx_hw,
 	} else
 		vif->use_4addr = false;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
         if (cfg80211_register_netdevice(ndev))
 #else
         if (register_netdevice(ndev))
@@ -3336,7 +1918,7 @@ static int rwnx_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wde
 
 	if (dev->reg_state == NETREG_REGISTERED) {
         /* Will call rwnx_close if interface is UP */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
         cfg80211_unregister_netdevice(dev);
 #else
         unregister_netdevice(dev);
@@ -3487,6 +2069,18 @@ static int rwnx_cfg80211_change_iface(struct wiphy *wiphy,
 	    vif->rwnx_hw->vif_table[add_if_cfm.inst_nbr] = vif;
 	    spin_unlock_bh(&vif->rwnx_hw->cb_lock);
 	}
+    
+    if (type == NL80211_IFTYPE_MONITOR) {
+        vif->rwnx_hw->monitor_vif = vif->vif_index;
+    #if defined(CONFIG_RWNX_MON_XMIT)
+        rwnx_txq_unk_vif_init(vif);
+    #endif
+    #if defined(CONFIG_RWNX_MON_RXFILTER)
+        rwnx_send_set_filter(vif->rwnx_hw, (FIF_BCN_PRBRESP_PROMISC | FIF_OTHER_BSS | FIF_PSPOLL | FIF_PROBE_REQ));
+    #endif
+    } else {
+        vif->rwnx_hw->monitor_vif = RWNX_INVALID_VIF;
+    }
 
 	return 0;
 }
@@ -3792,6 +2386,7 @@ static int rwnx_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
 static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 								 struct cfg80211_connect_params *sme)
 {
+
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 	struct sm_connect_cfm sm_connect_cfm;
@@ -3802,13 +2397,8 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			(sme->crypto.ciphers_pairwise[0] == WLAN_CIPHER_SUITE_WEP104));
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
+    
 #if 1
-#if 0
-		if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED){
-			AICWFDBG(LOGERROR, "%s driver was connected return it \r\n", __func__);
-			return -EALREADY;
-		}
-#endif
 	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTED) {
 		AICWFDBG(LOGDEBUG, "%s this connection is roam \r\n", __func__);
 		rwnx_vif->sta.is_roam = true;
@@ -3819,38 +2409,42 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTING||
 		(int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_CONNECTING) {
 		AICWFDBG(LOGERROR, "%s driver is disconnecting or connecting ,return it \r\n", __func__);
-		return -EALREADY;
+		return 0;
 	}
 #endif
 
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTING);
-
-        if (is_wep) {
-                if(sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
-                        if(rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err) {
-                                if(rwnx_vif->last_auth_type == NL80211_AUTHTYPE_SHARED_KEY)
-                                        sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
-                                else
-                                        sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-                        } else {
-                                if((rwnx_vif->wep_enabled && !rwnx_vif->wep_auth_err))
-                                        sme->auth_type = rwnx_vif->last_auth_type;
-                                else
-                                sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-                }
-                printk("auto: use sme->auth_type = %d\r\n", sme->auth_type);
-                } else {
-                        if (rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err && (sme->auth_type == rwnx_vif->last_auth_type)) {
-                                if(sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
-                                        sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
-                                        printk("start connect, auth_type changed, shared --> open\n");
-                                } else if(sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
-                                        sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
-                                        printk("start connect, auth_type changed, open --> shared\n");
-                                }
-                        }
-                }
-        }
+    if(rwnx_vif->sta.is_roam){
+        rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_ROAMING);
+    }else{
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTING);
+    }
+    
+    if (is_wep) {
+            if(sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) {
+                    if(rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err) {
+                            if(rwnx_vif->last_auth_type == NL80211_AUTHTYPE_SHARED_KEY)
+                                    sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
+                            else
+                                    sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
+                    } else {
+                            if((rwnx_vif->wep_enabled && !rwnx_vif->wep_auth_err))
+                                    sme->auth_type = rwnx_vif->last_auth_type;
+                            else
+                            sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
+            }
+            printk("auto: use sme->auth_type = %d\r\n", sme->auth_type);
+            } else {
+                    if (rwnx_vif->wep_enabled && rwnx_vif->wep_auth_err && (sme->auth_type == rwnx_vif->last_auth_type)) {
+                            if(sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
+                                    sme->auth_type = NL80211_AUTHTYPE_OPEN_SYSTEM;
+                                    printk("start connect, auth_type changed, shared --> open\n");
+                            } else if(sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) {
+                                    sme->auth_type = NL80211_AUTHTYPE_SHARED_KEY;
+                                    printk("start connect, auth_type changed, open --> shared\n");
+                            }
+                    }
+            }
+    }
 
 	/* For SHARED-KEY authentication, must install key first */
 	if (sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY && sme->key) {
@@ -3905,6 +2499,7 @@ static int rwnx_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	}
 
 	return error;
+
 }
 
 /**
@@ -3916,25 +2511,17 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 {
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
+	int ret = 0;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
 	AICWFDBG(LOGINFO, "%s drv_vif_index:%d disconnect reason:%d \r\n",
 		__func__, rwnx_vif->drv_vif_index, reason_code);
-
-#if 0
-	while(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGERROR, "%s driver connecting waiting 100ms \r\n", __func__);
-		msleep(100);
-
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
-	}
-#endif
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING){
-		AICWFDBG(LOGINFO, "%s call cfg80211_connect_result reason:%d \r\n",
-			__func__, reason_code);
-		msleep(500);
+    
+	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTED) {
+		AICWFDBG(LOGERROR, "%s this\r\n",__func__);
+        WARN_ON(1);
+		return -EBUSY;
 	}
 
 	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING) {
@@ -3943,18 +2530,30 @@ static int rwnx_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		return -EBUSY;
 	}
 
-	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED){
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
+	if(atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTED||
+        atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_CONNECTING||
+        atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_ROAMING) {
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTING);
 		key_flag = true;
-		return(rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code));
-	}else{
+		ret = rwnx_send_sm_disconnect_req(rwnx_hw, rwnx_vif, reason_code);
+#ifdef AICWF_SDIO_SUPPORT
+		if (rwnx_hw->sdiodev->bus_if->state == BUS_DOWN_ST) {
+			AICWFDBG(LOGINFO, "%s bus is down %d\n", __func__, ret);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		}
+#endif
+		return ret;
+	} 
+#if 0
+    else {
 		cfg80211_connect_result(dev,  NULL, NULL, 0, NULL, 0,
 			reason_code?reason_code:WLAN_STATUS_UNSPECIFIED_FAILURE, GFP_ATOMIC);
-		atomic_set(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, RWNX_DRV_STATUS_DISCONNECTED);
 		rwnx_external_auth_disable(rwnx_vif);
 		return 0;
 	}
-
+#endif
+    return 0;
 }
 
 #ifdef CONFIG_SCHED_SCAN
@@ -4236,13 +2835,11 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
     struct aicwf_rx_priv *rx_priv;
 #endif
 
-    //RWNX_DBG(RWNX_FN_ENTRY_STR);
-    printk("%s: %pM\n", __func__, mac);
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
     if (params)
         mac = params->mac;
 #endif
+    printk("%s: %pM\n", __func__, mac);
 
 	do {
 		spin_lock_bh(&rwnx_hw->cb_lock);
@@ -4296,7 +2893,6 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
 				macaddr = cur->mac_addr;
 				printk("deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0],macaddr[1],macaddr[2], \
 									   macaddr[3],macaddr[4],macaddr[5]);
-				spin_lock_bh(&rx_priv->stas_reord_lock);
 				list_for_each_entry_safe(reord_info, reord_tmp,
 					&rx_priv->stas_reord_list, list) {
 					printk("reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0],reord_info->mac_addr[1],reord_info->mac_addr[2], \
@@ -4306,7 +2902,6 @@ static int rwnx_cfg80211_del_station_compat(struct wiphy *wiphy,
 						break;
 					}
 				}
-				spin_unlock_bh(&rx_priv->stas_reord_lock);
 			}
 #endif
 
@@ -4412,7 +3007,6 @@ void apm_staloss_work_process(struct work_struct *work)
 			macaddr = cur->mac_addr;
 			printk("deinit:macaddr:%x,%x,%x,%x,%x,%x\r\n", macaddr[0], macaddr[1], macaddr[2], \
 								   macaddr[3], macaddr[4], macaddr[5]);
-			spin_lock_bh(&rx_priv->stas_reord_lock);
 			list_for_each_entry_safe(reord_info, reord_tmp,
 				&rx_priv->stas_reord_list, list) {
 				printk("reord_mac:%x,%x,%x,%x,%x,%x\r\n", reord_info->mac_addr[0], reord_info->mac_addr[1], reord_info->mac_addr[2], \
@@ -4422,7 +3016,6 @@ void apm_staloss_work_process(struct work_struct *work)
 					break;
 				}
 			}
-			spin_unlock_bh(&rx_priv->stas_reord_lock);
 		}
 #endif
 
@@ -4689,6 +3282,7 @@ static int rwnx_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *dev,
 #if (defined CONFIG_HE_FOR_OLD_KERNEL) || (defined CONFIG_VHT_FOR_OLD_KERNEL)
 		rwnx_vif->ap.aic_index = 0;
 #endif
+		rwnx_vif->ap.csa = NULL;
 		sta = &rwnx_hw->sta_table[apm_start_cfm.bcmc_idx];
 		sta->valid = true;
 		sta->aid = 0;
@@ -4796,6 +3390,11 @@ static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	netif_tx_stop_all_queues(dev);
 	netif_carrier_off(dev);
 
+	/* delete any remaining STA*/
+	while (!list_empty(&rwnx_vif->ap.sta_list)) {
+		rwnx_cfg80211_del_station_compat(wiphy, dev, NULL);
+	}
+
 	if (rwnx_vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)
 		rwnx_hw->is_p2p_connected = 0;
 	rwnx_radar_cancel_cac(&rwnx_hw->radar);
@@ -4804,11 +3403,6 @@ static int rwnx_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)
 	rwnx_chanctx_unlink(rwnx_vif);
 	spin_unlock_bh(&rwnx_hw->cb_lock);
 
-	/* delete any remaining STA*/
-	while (!list_empty(&rwnx_vif->ap.sta_list)) {
-		rwnx_cfg80211_del_station_compat(wiphy, dev, NULL);
-	}
-
 	/* delete BC/MC STA */
 	sta = &rwnx_hw->sta_table[rwnx_vif->ap.bcmc_index];
 	rwnx_txq_vif_deinit(rwnx_hw, rwnx_vif);
@@ -4885,6 +3479,12 @@ static int rwnx_cfg80211_set_monitor_channel(struct wiphy *wiphy,
 	return 0;
 }
 
+int rwnx_cfg80211_set_monitor_channel_(struct wiphy *wiphy,
+                                             struct cfg80211_chan_def *chandef){
+    return rwnx_cfg80211_set_monitor_channel(wiphy, chandef);
+}
+
+
 /**
  * @probe_client: probe an associated client, must return a cookie that it
  *	later passes to cfg80211_probe_status().
@@ -4979,6 +3579,25 @@ static int rwnx_cfg80211_set_tx_power(struct wiphy *wiphy, struct wireless_dev *
 	return res;
 }
 
+static int rwnx_cfg80211_get_tx_power(struct wiphy *wiphy,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+ struct wireless_dev *wdev,
+#endif
+	int *mbm)
+{
+    #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
+    struct wireless_dev *wdev = NULL;
+    #endif
+    //struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
+    //struct rwnx_vif *vif;
+    s8 pwr = 0;
+    int res = 0;
+
+	*mbm = get_txpwr_max(pwr);
+
+    return res;
+}
+
 /**
  * @set_power_mgmt: set the power save to one of those two modes:
  *  Power-save off
@@ -5423,6 +4042,8 @@ int rwnx_cfg80211_start_radar_detection(struct wiphy *wiphy,
 	struct rwnx_vif *rwnx_vif = netdev_priv(dev);
 	struct apm_start_cac_cfm cfm;
 
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
 	#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
 	rwnx_radar_start_cac(&rwnx_hw->radar, cac_time_ms, rwnx_vif);
 	#endif
@@ -5542,11 +4163,6 @@ int rwnx_cfg80211_channel_switch (struct wiphy *wiphy,
 		goto end;
 	}
 
-	error = rwnx_send_bcn(rwnx_hw, buf, vif->vif_index, bcn_after->len);
-	if (error) {
-		goto end;
-	}
-
 	vif->ap.csa = csa;
 	csa->vif = vif;
 	csa->chandef = params->chandef;
@@ -5841,28 +4457,38 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	sinfo->tx_failed = cfm.txfailed;
 	rate_info = (union rwnx_rate_ctrl_info *)&cfm.rate_info;
 
-	AICWFDBG(LOGDEBUG, "%s ModTx:%d TxIndex:%d ModRx:%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n", __func__,
-		rate_info->formatModTx, rate_info->mcsIndexTx, rx_vect1->format_mod,
+	AICWFDBG(LOGDEBUG, "%s ModTx(%d):%d TxIndex:%d ModRx(%d):%d RxHTIndex:%d RxVHTIndex:%d RxHEIndex:%d RSSI:%d \r\n", __func__,
+		rate_info->bwTx,
+		rate_info->formatModTx,
+		rate_info->mcsIndexTx,
+		rx_vect1->ch_bw,
+		rx_vect1->format_mod,
 		rx_vect1->ht.mcs,
 		rx_vect1->vht.mcs,
 		rx_vect1->he.mcs,
 		(s8)cfm.rssi);
 
 
+
 	switch (rate_info->formatModTx) {
 	case FORMATMOD_NON_HT:
 	case FORMATMOD_NON_HT_DUP_OFDM:
 		sinfo->txrate.flags = 0;
 		sinfo->txrate.legacy = tx_legrates_lut_rate[rate_info->mcsIndexTx];
+		sinfo->txrate.nss = 1;
 		break;
 	case FORMATMOD_HT_MF:
 	case FORMATMOD_HT_GF:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 3) & 0x7) + 1;
+        if (rate_info->giAndPreTypeTx)
+            sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		break;
 	case FORMATMOD_VHT:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	case FORMATMOD_HE_MU:
@@ -5870,6 +4496,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_HE_ER:
 		sinfo->txrate.flags = RATE_INFO_FLAGS_HE_MCS;
 		sinfo->txrate.mcs = rate_info->mcsIndexTx;
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #else
 	case FORMATMOD_HE_MU:
@@ -5881,6 +4508,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
         }else{
 		    sinfo->txrate.mcs = rate_info->mcsIndexTx;
         }
+		sinfo->txrate.nss = ((rate_info->mcsIndexTx >> 4) & 0x7) + 1;
 		break;
 #endif
 	default:
@@ -5911,7 +4539,6 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	}
 #endif
 
-	sinfo->txrate.nss = 1;
 	sinfo->filled |= (BIT(NL80211_STA_INFO_TX_BITRATE) | BIT(NL80211_STA_INFO_TX_FAILED));
 
 	sinfo->inactive_time = jiffies_to_msecs(jiffies - vif->rwnx_hw->stats.last_tx);
@@ -5920,7 +4547,6 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	sinfo->tx_packets = vif->net_stats.tx_packets;
 	sinfo->rx_packets = vif->net_stats.rx_packets;
 	sinfo->signal = (s8)cfm.rssi;
-	sinfo->rxrate.nss = 1;
 
 	#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
 	switch (rx_vect1->ch_bw) {
@@ -5950,7 +4576,8 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 	case FORMATMOD_NON_HT:
 	case FORMATMOD_NON_HT_DUP_OFDM:
 		sinfo->rxrate.flags = 0;
-		sinfo->rxrate.legacy = legrates_lut_rate[legrates_lut[rx_vect1->leg_rate]];
+		sinfo->rxrate.legacy = legrates_lut[rx_vect1->leg_rate].rate;
+		sinfo->rxrate.nss = 1;
 		break;
 	case FORMATMOD_HT_MF:
 	case FORMATMOD_HT_GF:
@@ -5958,12 +4585,14 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 		if (rx_vect1->ht.short_gi)
 			sinfo->rxrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		sinfo->rxrate.mcs = rx_vect1->ht.mcs;
+		sinfo->rxrate.nss = rx_vect1->ht.num_extn_ss + 1;
 		break;
 	case FORMATMOD_VHT:
 		sinfo->rxrate.flags = RATE_INFO_FLAGS_VHT_MCS;
 		if (rx_vect1->vht.short_gi)
 			sinfo->rxrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
 		sinfo->rxrate.mcs = rx_vect1->vht.mcs;
+		sinfo->rxrate.nss = rx_vect1->vht.nss + 1;
 		break;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	case FORMATMOD_HE_MU:
@@ -5974,6 +4603,7 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
 		sinfo->rxrate.mcs = rx_vect1->he.mcs;
 		sinfo->rxrate.he_gi = rx_vect1->he.gi_type;
 		sinfo->rxrate.he_dcm = rx_vect1->he.dcm;
+		sinfo->rxrate.nss = rx_vect1->he.nss + 1;
 		break;
 #else
 	//kernel not support he
@@ -5986,6 +4616,8 @@ static int rwnx_fill_station_info(struct rwnx_sta *sta, struct rwnx_vif *vif,
         }else{
             sinfo->rxrate.mcs = rx_vect1->he.mcs;
         }
+		sinfo->rxrate.mcs = (rx_vect1->he.mcs > 9 ? 9 : rx_vect1->he.mcs);
+		sinfo->rxrate.nss = rx_vect1->he.nss + 1;
 		break;
 #endif
 	default:
@@ -6551,7 +5183,7 @@ static struct cfg80211_ops rwnx_cfg80211_ops = {
 	.set_wiphy_params = rwnx_cfg80211_set_wiphy_params,
 	.set_txq_params = rwnx_cfg80211_set_txq_params,
 	.set_tx_power = rwnx_cfg80211_set_tx_power,
-//    .get_tx_power = rwnx_cfg80211_get_tx_power,
+    .get_tx_power = rwnx_cfg80211_get_tx_power,
 	.set_power_mgmt = rwnx_cfg80211_set_power_mgmt,
 	.get_station = rwnx_cfg80211_get_station,
 	.remain_on_channel = rwnx_cfg80211_remain_on_channel,
@@ -6613,11 +5245,17 @@ static void rwnx_reg_notifier(struct wiphy *wiphy,
 	struct rwnx_hw *rwnx_hw = wiphy_priv(wiphy);
 
 	// For now trust all initiator
+#ifdef CONFIG_RADAR_OR_IR_DETECT
+	if(request->dfs_region != 0)
+		rwnx_radar_set_domain(&rwnx_hw->radar, request->dfs_region);
+#else
 	rwnx_radar_set_domain(&rwnx_hw->radar, request->dfs_region);
+#endif
 	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC||
 		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) && testmode == 0)){
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) && testmode == 0)){
     		rwnx_send_me_chan_config_req(rwnx_hw);
 		}
 }
@@ -6697,7 +5335,7 @@ int rwnx_ic_system_init(struct rwnx_hw *rwnx_hw){
 	AICWFDBG(LOGINFO, "FDRV chip_id=%x, chip_sub_id=%x!!\n", chip_id, chip_sub_id);
 
 #ifdef CONFIG_OOB
-    if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         u32 memdata_temp = 0x00000006;
         int ret;
         ret = rwnx_send_dbg_mem_block_write_req(rwnx_hw, 0x40504084, 4, &memdata_temp);
@@ -6750,7 +5388,7 @@ int rwnx_ic_rf_init(struct rwnx_hw *rwnx_hw){
 			return -1;
 
 
-	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 		if ((ret = aicwf_set_rf_config_8800d80(rwnx_hw, &cfm)))
 			return -1;
 	}
@@ -6810,7 +5448,27 @@ int rwnx_get_custom_mac_addr(u8_l *mac_addr_efuse){
 }
 #endif
 
+#ifdef CONFIG_FOR_IPCAM
+void aic_ipc_setting(struct rwnx_vif *rwnx_vif){
+    struct rwnx_hw *rwnx_hw = rwnx_vif->rwnx_hw;
+	uint32_t hw_edca = 1;
+	uint32_t hw_cca = 3;
+	int32_t param[14];
+	int32_t cca[5]= {0x10, 0, 0, 0, 0};
+
+	param[0] = 0xFA522; param[1] = 0xFA522; param[2] = 0xFA522; param[3] = 0xFA522;
+	param[4] = rwnx_vif->vif_index;
+	param[5] = 0x1e; param[6] = 0; param[7] = 0; param[8] =0;param[9] = 0x2;param[10] = 0x2;param[11] = 0x7;param[12] = 0;param[13] = 1;
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_edca, param, NULL);
+	rwnx_send_vendor_hwconfig_req(rwnx_hw, hw_cca, cca, NULL);
+}
+#endif
+
 extern void *aicwf_prealloc_txq_alloc(size_t size);
+#ifdef CONFIG_POWER_LIMIT
+extern char default_ccode[];
+extern char country_code[];
+#endif
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 {
 	struct rwnx_hw *rwnx_hw;
@@ -6838,6 +5496,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	aicbsp_get_feature(&feature, fw_path);
 
 	get_random_bytes(&dflt_mac[4], 2);
+#ifdef CONFIG_POWER_LIMIT
+	memcpy(country_code, default_ccode, 4);
+#endif
 
 	/* create a new wiphy for use with cfg80211 */
     AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__, (int)sizeof(struct rwnx_hw));
@@ -7112,11 +5773,16 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	rwnx_enable_mesh(rwnx_hw);
 	rwnx_radar_detection_init(&rwnx_hw->radar);
 
+#ifdef CONFIG_RADAR_OR_IR_DETECT
+	rwnx_radar_set_domain(&rwnx_hw->radar, NL80211_DFS_FCC);
+#endif
+
 	/* Set parameters to firmware */
 	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC||
 		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW ||
-		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) && testmode == 0)){
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		 rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) && testmode == 0)){
 		rwnx_send_me_config_req(rwnx_hw);
 	}
 
@@ -7141,7 +5807,8 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 ||
 		((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
 		rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW ||
-		rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) && testmode == 0)) {
+		rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 ||
+		rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) && testmode == 0)) {
     	rwnx_send_me_chan_config_req(rwnx_hw);
 	}
 
@@ -7160,6 +5827,12 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	vif = rwnx_interface_add(rwnx_hw, "wlan%d", NET_NAME_UNKNOWN,
 								NL80211_IFTYPE_STATION, NULL);
 
+#ifdef CONFIG_RWNX_MON_DATA
+    /* Add an initial station interface */
+    vif = rwnx_interface_add(rwnx_hw, "wlan%d", 1,
+                                    NL80211_IFTYPE_MONITOR, NULL);
+#endif
+
 	rtnl_unlock();
 
 	if (!vif) {
@@ -7206,6 +5879,9 @@ int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data)
 	atomic_set(&rwnx_hw->p2p_alive_timer_count, 0);
 #endif
 
+#ifdef CONFIG_FOR_IPCAM
+	aic_ipc_setting(vif);
+#endif
 
 	return 0;
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
index 684ab081ff34..dfa89034706a 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_main.h
@@ -13,20 +13,6 @@
 
 #include "rwnx_defs.h"
 
-typedef struct _android_wifi_priv_cmd {
-	char *buf;
-	int used_len;
-	int total_len;
-} android_wifi_priv_cmd;
-
-#ifdef CONFIG_COMPAT
-typedef struct _compat_android_wifi_priv_cmd {
-	compat_caddr_t buf;
-	int used_len;
-	int total_len;
-} compat_android_wifi_priv_cmd;
-#endif /* CONFIG_COMPAT */
-
 int rwnx_cfg80211_init(struct rwnx_plat *rwnx_plat, void **platform_data);
 void rwnx_cfg80211_deinit(struct rwnx_hw *rwnx_hw);
 extern int testmode;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
index 4aa6eba9c51b..4a9a29853437 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_mod_params.c
@@ -44,8 +44,8 @@ struct rwnx_mod_params rwnx_mod_params = {
 	COMMON_PARAM(sgi, true, true)
 	COMMON_PARAM(sgi80, false, false)
 	COMMON_PARAM(use_2040, 1, 1)
-	COMMON_PARAM(nss, 1, 1)
-	COMMON_PARAM(amsdu_rx_max, 2, 2)
+	COMMON_PARAM(nss, 2, 2)
+	COMMON_PARAM(amsdu_rx_max, 1, 1)
 	COMMON_PARAM(bfmee, true, true)
 	COMMON_PARAM(bfmer, false, false)
 	COMMON_PARAM(mesh, true, true)
@@ -269,6 +269,7 @@ static const int mcs_map_to_rate[4][3] = {
 #define MAX_VHT_RATE(map, nss, bw) (mcs_map_to_rate[bw][map] * (nss))
 
 extern struct ieee80211_regdomain *reg_regdb[];
+extern int reg_regdb_size;
 
 char ccode_channels[200];
 int index_for_channel_list = 0;
@@ -705,6 +706,9 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
         return;
     }
 
+	if(rwnx_hw->sdiodev->chipid <= PRODUCT_ID_AIC8800D80)
+		nss = 1;
+
 	rwnx_hw->vht_cap_2G.vht_supported = true;
 		if (rwnx_hw->mod_params->sgi80)
 			rwnx_hw->vht_cap_2G.cap |= IEEE80211_VHT_CAP_SHORT_GI_80;
@@ -769,7 +773,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+			//mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
 		}
 		for (; i < 8; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -781,8 +785,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-							IEEE80211_VHT_MCS_SUPPORT_0_8);
+			//mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+			//				IEEE80211_VHT_MCS_SUPPORT_0_8);
 		}
 		for (; i < 8; i++) {
 			rwnx_hw->vht_cap_2G.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -864,7 +868,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+	        //mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
 	    }
 	    for (; i < 8; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -876,8 +880,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	    for (i = 0; i < nss; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-	        mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-	                        IEEE80211_VHT_MCS_SUPPORT_0_8);
+	        //mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+	         //               IEEE80211_VHT_MCS_SUPPORT_0_8);
 	    }
 	    for (; i < 8; i++) {
 	        rwnx_hw->vht_cap_5G.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -891,6 +895,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	        rwnx_hw->vht_cap_5G.cap &= ~IEEE80211_VHT_CAP_SHORT_GI_80;
 	    }
 
+		rwnx_hw->vht_cap_5G.cap |= IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK;
 	} 
 #endif//USE_5G
 	return;
@@ -908,7 +913,9 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	if (!rwnx_hw->mod_params->vht_on) {
 		return;
 	}
-    
+
+	if(rwnx_hw->sdiodev->chipid <= PRODUCT_ID_AIC8800D80)
+		nss = 1;
 
 	band_2GHz->vht_cap.vht_supported = true;
 	if (rwnx_hw->mod_params->sgi80)
@@ -974,7 +981,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	for (i = 0; i < nss; i++) {
 		band_2GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 		band_2GHz->vht_cap.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-		mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+		//mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
 	}
 	for (; i < 8; i++) {
 		band_2GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -986,8 +993,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	for (i = 0; i < nss; i++) {
 		band_2GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 		band_2GHz->vht_cap.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-		mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-						IEEE80211_VHT_MCS_SUPPORT_0_8);
+		//mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+		//				IEEE80211_VHT_MCS_SUPPORT_0_8);
 	}
 	for (; i < 8; i++) {
 		band_2GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -1066,7 +1073,7 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			band_5GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			band_5GHz->vht_cap.vht_mcs.rx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
+			//mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_7;
 		}
 		for (; i < 8; i++) {
 			band_5GHz->vht_cap.vht_mcs.rx_mcs_map |= cpu_to_le16(
@@ -1078,8 +1085,8 @@ static void rwnx_set_vht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		for (i = 0; i < nss; i++) {
 			band_5GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(mcs_map << (i*2));
 			band_5GHz->vht_cap.vht_mcs.tx_highest = MAX_VHT_RATE(mcs_map, nss, bw_max);
-			mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
-							IEEE80211_VHT_MCS_SUPPORT_0_8);
+			//mcs_map = min_t(int, rwnx_hw->mod_params->mcs_map,
+			//				IEEE80211_VHT_MCS_SUPPORT_0_8);
 		}
 		for (; i < 8; i++) {
 			band_5GHz->vht_cap.vht_mcs.tx_mcs_map |= cpu_to_le16(
@@ -1109,6 +1116,9 @@ static void rwnx_set_ht_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		return;
 	}
 
+	if(rwnx_hw->sdiodev->chipid <= PRODUCT_ID_AIC8800D80)
+		nss = 1;
+
 	if (rwnx_hw->mod_params->stbc_on)
 		band_2GHz->ht_cap.cap |= 1 << IEEE80211_HT_CAP_RX_STBC_SHIFT;
 	if (rwnx_hw->mod_params->ldpc_on)
@@ -1157,6 +1167,9 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	int nss = rwnx_hw->mod_params->nss;
 	int mcs_map;
 
+	if(rwnx_hw->sdiodev->chipid <= PRODUCT_ID_AIC8800D80)
+		nss = 1;
+
 	he_cap = (struct ieee80211_sta_he_cap *) &rwnx_he_capa.he_cap;
 	he_cap->has_he = true;
 	he_cap->he_cap_elem.mac_cap_info[2] |= IEEE80211_HE_MAC_CAP2_ALL_ACK;
@@ -1168,7 +1181,13 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	if (rwnx_hw->mod_params->use_80) {
 		he_cap->ppe_thres[0] |= 0x20;
 		he_cap->ppe_thres[2] |= 0xc0;
-		he_cap->ppe_thres[3] |= 0x07;
+		he_cap->ppe_thres[3] |= 0x01;
+	}
+	if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
 	}
 	//if (rwnx_hw->mod_params->use_80)
 	{
@@ -1217,7 +1236,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	he_cap->he_cap_elem.phy_cap_info[8] |= IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G;
 	he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 										   IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
-	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
 	    mcs_map = rwnx_hw->mod_params->he_mcs_map;
     else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
         rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW)
@@ -1228,7 +1247,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 		he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
 		he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-		mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+		//mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
 		}
 	for (; i < 8; i++) {
 		__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1242,8 +1261,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 		he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
 		he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-		mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-						IEEE80211_HE_MCS_SUPPORT_0_7);
+		//mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+		//				IEEE80211_HE_MCS_SUPPORT_0_7);
 	}
 	for (; i < 8; i++) {
 		__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1262,6 +1281,10 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	int nss = rwnx_hw->mod_params->nss;
 	struct ieee80211_sta_he_cap *he_cap;
 	int mcs_map;
+
+	if(rwnx_hw->sdiodev->chipid <= PRODUCT_ID_AIC8800D80)
+		nss = 1;
+
 	if (!rwnx_hw->mod_params->he_on) {
 		band_2GHz->iftype_data = NULL;
 		band_2GHz->n_iftype_data = 0;
@@ -1282,7 +1305,13 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	if (rwnx_hw->mod_params->use_80) {
 	    he_cap->ppe_thres[0] |= 0x20;
 	    he_cap->ppe_thres[2] |= 0xc0;
-	    he_cap->ppe_thres[3] |= 0x07;
+	    he_cap->ppe_thres[3] |= 0x01;
+	}
+	if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
 	}
 	//if (rwnx_hw->mod_params->use_80)
 	{
@@ -1352,7 +1381,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 					IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 	#endif
-	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+	if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
 	    mcs_map = rwnx_hw->mod_params->he_mcs_map;
     }
     else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
@@ -1365,7 +1394,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 		he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
 		he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-		mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+		//mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
 		}
 	for (; i < 8; i++) {
 		__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1379,8 +1408,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 		he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
 		he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-		mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-						IEEE80211_HE_MCS_SUPPORT_0_7);
+		//mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+		//				IEEE80211_HE_MCS_SUPPORT_0_7);
 	}
 	for (; i < 8; i++) {
 		__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1398,10 +1427,16 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 							IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;
 			he_cap->ppe_thres[0] |= 0x10;
 		}
-	        if (rwnx_hw->mod_params->use_80) {
+	    if (rwnx_hw->mod_params->use_80) {
 		    he_cap->ppe_thres[0] |= 0x20;
 		    he_cap->ppe_thres[2] |= 0xc0;
-	            he_cap->ppe_thres[3] |= 0x07;
+	        he_cap->ppe_thres[3] |= 0x01;
+		}
+		if (nss == 2) {
+		he_cap->ppe_thres[0] |= 0x01;
+		he_cap->ppe_thres[3] |= 0x70;
+		he_cap->ppe_thres[4] |= 0x1c;
+		he_cap->ppe_thres[5] |= 0x07;
 		}
 		//if (rwnx_hw->mod_params->use_80)
 		{
@@ -1468,7 +1503,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 		he_cap->he_cap_elem.phy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |
 											   IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;
 		#endif
-		if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80)
+		if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2)
             mcs_map = rwnx_hw->mod_params->he_mcs_map;
         else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8801 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
             rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW)
@@ -1479,7 +1514,7 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 			he_cap->he_mcs_nss_supp.rx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 			he_cap->he_mcs_nss_supp.rx_mcs_160 |= unsup_for_ss;
 			he_cap->he_mcs_nss_supp.rx_mcs_80p80 |= unsup_for_ss;
-			mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
+			//mcs_map = IEEE80211_HE_MCS_SUPPORT_0_7;
 		}
 		for (; i < 8; i++) {
 			__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1493,8 +1528,8 @@ static void rwnx_set_he_capa(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 			he_cap->he_mcs_nss_supp.tx_mcs_80 |= cpu_to_le16(mcs_map << (i*2));
 			he_cap->he_mcs_nss_supp.tx_mcs_160 |= unsup_for_ss;
 			he_cap->he_mcs_nss_supp.tx_mcs_80p80 |= unsup_for_ss;
-			mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
-							IEEE80211_HE_MCS_SUPPORT_0_7);
+			//mcs_map = min_t(int, rwnx_hw->mod_params->he_mcs_map,
+			//				IEEE80211_HE_MCS_SUPPORT_0_7);
 		}
 		for (; i < 8; i++) {
 			__le16 unsup_for_ss = cpu_to_le16(IEEE80211_HE_MCS_NOT_SUPPORTED << (i*2));
@@ -1689,16 +1724,16 @@ int rwnx_handle_dynparams(struct rwnx_hw *rwnx_hw, struct wiphy *wiphy)
 	}
 #endif
 
-    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         rwnx_hw->mod_params->sgi80 = true;
         rwnx_hw->mod_params->use_80 = true;
     }
 
-    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         rwnx_hw->mod_params->use_80 = true;    
     }
     
-    if (rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80 &&
+    if (rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80 && rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80X2 &&
         rwnx_hw->mod_params->he_mcs_map == IEEE80211_HE_MCS_SUPPORT_0_11) {
         AICWFDBG(LOGINFO,"%s unsupport mcs11 change to mcs9", __func__);
         rwnx_hw->mod_params->he_mcs_map = IEEE80211_HE_MCS_SUPPORT_0_9;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
index 9eeccbd91f2c..62da71b0588f 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_rx.c
@@ -278,6 +278,7 @@ static inline int rwnx_rx_p2p_vif_ps_change_ind(struct rwnx_hw *rwnx_hw,
 	if (ps_state == MM_PS_MODE_OFF) {
 		// Start TX queues for provided VIF
 		rwnx_txq_vif_start(vif_entry, RWNX_TXQ_STOP_VIF_PS, rwnx_hw);
+        tasklet_schedule(&rwnx_hw->task);
 	} else {
 		// Stop TX queues for provided VIF
 		rwnx_txq_vif_stop(vif_entry, RWNX_TXQ_STOP_VIF_PS, rwnx_hw);
@@ -370,6 +371,40 @@ static inline int rwnx_rx_pktloss_notify_ind(struct rwnx_hw *rwnx_hw,
 	return 0;
 }
 
+static inline int rwnx_radar_detect_ind(struct rwnx_hw *rwnx_hw,
+                                                struct rwnx_cmd *cmd,
+                                                struct ipc_e2a_msg *msg)
+{
+    struct radar_pulse_array_desc *pulses = (struct radar_pulse_array_desc *)msg->param;
+       int i;
+
+    //RWNX_DBG(RWNX_FN_ENTRY_STR);
+    //printk("%s\n", __func__);
+
+    if(pulses->cnt == 0) {
+               printk("cnt error\n");
+               return -1;
+    }
+
+       if(rwnx_radar_detection_is_enable(&rwnx_hw->radar, pulses->idx)) {
+               for(i=0; i<pulses->cnt; i++) {
+                       struct rwnx_radar_pulses *p = &rwnx_hw->radar.pulses[pulses->idx];
+
+                       p->buffer[p->index] = pulses->pulse[i];
+                       p->index = (p->index + 1)%RWNX_RADAR_PULSE_MAX;
+                       if(p->count < RWNX_RADAR_PULSE_MAX)
+                               p->count++;
+                       //printk("pulse=%x\n", pulses->pulse[i]);
+               }
+
+               if(!work_pending(&rwnx_hw->radar.detection_work))
+                       schedule_work(&rwnx_hw->radar.detection_work);
+    } else
+               printk("not enable\n");
+
+    return 0;
+}
+
 static inline int rwnx_apm_staloss_ind(struct rwnx_hw *rwnx_hw,
                                                 struct rwnx_cmd *cmd,
                                                 struct ipc_e2a_msg *msg)
@@ -729,9 +764,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 	const u8 *extcap_ie;
 	const struct ieee_types_extcap *extcap;
 	struct ieee80211_channel *chan;
-	struct cfg80211_bss *bss = NULL;
+	//struct cfg80211_bss *bss = NULL;
     struct wireless_dev *wdev = NULL;
-    int retry_counter = 10;
+    //int retry_counter = 10;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 	wdev = dev->ieee80211_ptr;
@@ -793,6 +828,13 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 			rwnx_vif->tdls_chsw_prohibited = extcap->ext_capab[4] & WLAN_EXT_CAPA5_TDLS_CH_SW_PROHIBITED;
 		}
 
+#ifdef CONFIG_RADAR_OR_IR_DETECT
+               if (chan->flags & IEEE80211_CHAN_RADAR)
+                       rwnx_radar_detection_enable(&rwnx_hw->radar,
+                                                                                       RWNX_RADAR_DETECT_REPORT,
+                                                                                       RWNX_RADAR_RIU);
+#endif
+
 		if (rwnx_vif->wep_enabled)
 			rwnx_vif->wep_auth_err = false;
 
@@ -838,9 +880,9 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
 			rwnx_vif->wep_auth_err = true;
 			AICWFDBG(LOGINFO, "con ind wep_auth_err %d\n", rwnx_vif->wep_auth_err);
 		}
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}else{
-		atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+		rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 	}
 
     AICWFDBG(LOGINFO, "%s ind->roamed:%d ind->status_code:%d rwnx_vif->drv_conn_state:%d\r\n", 
@@ -849,94 +891,31 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
         ind->status_code,
         (int)atomic_read(&rwnx_vif->drv_conn_state));
 
-	do {
-		bss = cfg80211_get_bss(wdev->wiphy, NULL, rwnx_vif->sta.bssid,
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-							wdev->u.client.ssid, wdev->u.client.ssid_len,
-#else
-							wdev->ssid, wdev->ssid_len,
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-							wdev->conn_bss_type,
-							IEEE80211_PRIVACY_ANY);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-							IEEE80211_BSS_TYPE_ESS,
-							IEEE80211_PRIVACY_ANY);
-#else
-                            WLAN_CAPABILITY_ESS,
-                            WLAN_CAPABILITY_PRIVACY);
-#endif
-
-
-		if (!bss) {
-			printk("%s bss is NULL \r\n", __func__);
-
-			printk("%s bss ssid(%d):%s conn_bss_type:%d bss2 ssid(%d):%s conn_bss_type:%d\r\n", 
-				__func__, 
-				(int)rwnx_vif->sta.ssid_len,
-				rwnx_vif->sta.ssid,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-				IEEE80211_BSS_TYPE_ESS,
-#else
-				WLAN_CAPABILITY_ESS,
-#endif
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-				(int)wdev->u.client.ssid_len,
-				wdev->u.client.ssid, 
-#else
-				(int)wdev->ssid_len,
-				wdev->ssid,
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-				wdev->conn_bss_type
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-                IEEE80211_BSS_TYPE_ESS
-#else
-                WLAN_CAPABILITY_ESS
-#endif
-				);
-
-
-			printk("%s rwnx_vif->sta.bssid %02x %02x %02x %02x %02x %02x \r\n", __func__, 
-				rwnx_vif->sta.bssid[0], rwnx_vif->sta.bssid[1], rwnx_vif->sta.bssid[2],
-				rwnx_vif->sta.bssid[3], rwnx_vif->sta.bssid[4], rwnx_vif->sta.bssid[5]);
-
-#if LINUX_VERSION_CODE >= HIGH_KERNEL_VERSION
-			wdev->u.client.ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->u.client.ssid, rwnx_vif->sta.ssid, wdev->u.client.ssid_len);
-#else
-			wdev->ssid_len = (int)rwnx_vif->sta.ssid_len;
-			memcpy(wdev->ssid, rwnx_vif->sta.ssid, wdev->ssid_len);
-#endif
-			msleep(100);
-			retry_counter--;
-			if(retry_counter == 0){
-				printk("%s bss recover fail \r\n", __func__);
-				break;
-			}
-		}
-	} while (!bss);
+    if(ind->status_code == 0 && (int)atomic_read(&rwnx_vif->drv_conn_state) == RWNX_DRV_STATUS_DISCONNECTING){
+        AICWFDBG(LOGINFO, "%s the disconnection has been requested, return it\r\n", __func__);
+        goto exit;
+    }
 
 	if (!ind->roamed){//not roaming
-		cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
-								ind->assoc_req_ie_len, rsp_ie,
-								ind->assoc_rsp_ie_len, ind->status_code,
-								GFP_ATOMIC);
+        cfg80211_connect_result(dev, (const u8 *)ind->bssid.array, req_ie,
+                            ind->assoc_req_ie_len, rsp_ie,
+                            ind->assoc_rsp_ie_len, ind->status_code,
+                            GFP_ATOMIC);
 		if (ind->status_code == 0) {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+            AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", 
+                __func__, 
+                (int)atomic_read(&rwnx_vif->drv_conn_state));
 		} else {
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
 		}
-		AICWFDBG(LOGINFO, "%s cfg80211_connect_result pass, rwnx_vif->drv_conn_state:%d\r\n", 
-			__func__, 
-			(int)atomic_read(&rwnx_vif->drv_conn_state));
+
     }else {//roaming
         if(ind->status_code != 0){
             AICWFDBG(LOGINFO, "%s roaming fail to notify disconnect \r\n", __func__);
 			cfg80211_disconnected(dev, 0, NULL, 0,1, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
 			rwnx_external_auth_disable(rwnx_vif);
         }else{        
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
@@ -956,7 +935,6 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     		info.resp_ie = rsp_ie;
     		info.resp_ie_len = ind->assoc_rsp_ie_len;
     		cfg80211_roamed(dev, &info, GFP_ATOMIC);
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
 #else
     		chan = ieee80211_get_channel(rwnx_hw->wiphy, ind->center_freq);
     		cfg80211_roamed(dev
@@ -969,13 +947,20 @@ static inline int rwnx_rx_sm_connect_ind(struct rwnx_hw *rwnx_hw,
     			, rsp_ie
     			, ind->assoc_rsp_ie_len
     			, GFP_ATOMIC);
+            
 #endif /*LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)*/
-			atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
+			rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_CONNECTED);
     	}
-        }
-	netif_tx_start_all_queues(dev);
-	netif_carrier_on(dev);
+        rwnx_vif->sta.is_roam = false;
+	}
 
+	if (ind->status_code == 0) {
+		netif_tx_start_all_queues(dev);
+		netif_carrier_on(dev);
+	}
+    
+exit:
+    rwnx_vif->sta.is_roam = false;
 	return 0;
 }
 
@@ -1023,12 +1008,14 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 	struct aicwf_rx_priv *rx_priv;
 #endif
 
-	RWNX_DBG(RWNX_FN_ENTRY_STR);
+	//RWNX_DBG(RWNX_FN_ENTRY_STR);
+	AICWFDBG(LOGINFO, "%s reason code:%d \r\n", __func__, ind->reason_code);
+
 	if((int)atomic_read(&rwnx_vif->drv_conn_state) == (int)RWNX_DRV_STATUS_DISCONNECTED){
 		AICWFDBG(LOGINFO, "%s, is already disconnected, drop disconnect ind", __func__);
 		return 0;
 	}
-
+    
 	dhcped = 0;
 
 	if(!rwnx_vif)
@@ -1041,6 +1028,10 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 		AICWFDBG(LOGINFO, "%s roaming no rwnx_cfg80211_unlink_bss \r\n", __func__);
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	rwnx_dbgfs_unregister_rc_stat(rwnx_hw, rwnx_vif->sta.ap);
+#endif
+
 	#ifdef CONFIG_BR_SUPPORT
 		struct rwnx_vif *vif = netdev_priv(dev);
 			 /* clear bridge database */
@@ -1102,7 +1093,10 @@ static inline int rwnx_rx_sm_disconnect_ind(struct rwnx_hw *rwnx_hw,
 	rwnx_chanctx_unlink(rwnx_vif);
 	
 	//msleep(200);
-	atomic_set(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+    if (rwnx_vif->sta.is_roam == false) {
+	    rwnx_set_conn_state(&rwnx_vif->drv_conn_state, (int)RWNX_DRV_STATUS_DISCONNECTED);
+    }
+    
 	return 0;
 }
 
@@ -1139,13 +1133,6 @@ static inline int rwnx_rx_sm_external_auth_required_ind(struct rwnx_hw *rwnx_hw,
 	}
 	AICWFDBG(LOGINFO, "%s wdev->conn_owner_nlportid:%d \r\n", __func__, (int)wdev->conn_owner_nlportid);
 
-	if (wdev->conn_owner_nlportid != 0) {
-		rwnx_vif->sta.conn_owner_nlportid = wdev->conn_owner_nlportid;
-	} else {
-		AICWFDBG(LOGINFO, "%s try to recover conn_owner_nlportid\r\n", __func__);
-		wdev->conn_owner_nlportid = rwnx_vif->sta.conn_owner_nlportid;
-	}
-
 	if ((ind->vif_idx > NX_VIRT_DEV_MAX) || !rwnx_vif->up ||
 		(RWNX_VIF_TYPE(rwnx_vif) != NL80211_IFTYPE_STATION) ||
 		(ret = cfg80211_external_auth_request(dev, &params, GFP_ATOMIC))) {
@@ -1453,7 +1440,8 @@ static msg_cb_fct mm_hdlrs[MSG_I(MM_MAX)] = {
 	[MSG_I(MM_P2P_NOA_UPD_IND)]        = rwnx_rx_p2p_noa_upd_ind,
 	[MSG_I(MM_RSSI_STATUS_IND)]        = rwnx_rx_rssi_status_ind,
 	[MSG_I(MM_PKTLOSS_IND)]            = rwnx_rx_pktloss_notify_ind,
-    [MSG_I(MM_APM_STALOSS_IND)]        = rwnx_apm_staloss_ind,
+	[MSG_I(MM_APM_STALOSS_IND)]        = rwnx_apm_staloss_ind,
+	[MSG_I(MM_RADAR_DETECT_IND)]       = rwnx_radar_detect_ind,
 };
 
 static msg_cb_fct scan_hdlrs[MSG_I(SCANU_MAX)] = {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
index 0d5007a756ff..8b368ca6984f 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.c
@@ -67,7 +67,7 @@ const int chnl2bw[] = {
 	[PHY_CHNL_BW_80P80]   = NL80211_CHAN_WIDTH_80P80,
 };
 
-#define RWNX_CMD_ARRAY_SIZE 20
+#define RWNX_CMD_ARRAY_SIZE 40
 #define RWNX_CMD_HIGH_WATER_SIZE RWNX_CMD_ARRAY_SIZE/2
 
 struct rwnx_cmd cmd_array[RWNX_CMD_ARRAY_SIZE];
@@ -125,7 +125,7 @@ static inline bool is_non_blocking_msg(int id)
 static inline u8_l get_chan_flags(uint32_t flags)
 {
 	u8_l chan_flags = 0;
-#ifdef RADAR_OR_IR_DETECT
+#ifdef CONFIG_RADAR_OR_IR_DETECT
 	#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0)
 	if (flags & IEEE80211_CHAN_PASSIVE_SCAN)
 	#else
@@ -304,7 +304,6 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
 	struct rwnx_cmd *cmd;
 	bool nonblock;
 	int ret = 0;
-	u8_l empty = 0;
 
 	//RWNX_DBG(RWNX_FN_ENTRY_STR);
     AICWFDBG(LOGTRACE, "%s (%d)%s reqcfm:%d in_irq:%d in_softirq:%d in_atomic:%d\r\n",
@@ -366,6 +365,7 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
 	if (reqcfm)
 		cmd->flags |= RWNX_CMD_FLAG_REQ_CFM;
 
+#if 0
 	if (cfm != NULL) {
 		do {
 			if(rwnx_hw->cmd_mgr->state == RWNX_CMD_MGR_STATE_CRASHED)
@@ -385,7 +385,7 @@ static int rwnx_send_msg(struct rwnx_hw *rwnx_hw, const void *msg_params,
              		}
 		} while	(!empty);//wait for cmd queue empty
 	}
-
+#endif
 	if (reqcfm) {
 		cmd->flags &= ~RWNX_CMD_FLAG_WAIT_ACK; // we don't need ack any more
 		ret = rwnx_hw->cmd_mgr->queue(rwnx_hw->cmd_mgr, cmd);
@@ -1046,7 +1046,7 @@ int rwnx_send_rf_calib_req(struct rwnx_hw *rwnx_hw, struct mm_set_rf_calib_cfm *
     } else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW) {
         rf_calib_req->cal_cfg_24g = 0x0f8f;
         rf_calib_req->cal_cfg_5g = 0;
-    } else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    } else if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
     	rf_calib_req->cal_cfg_24g = 0x0f8f;
     	rf_calib_req->cal_cfg_5g = 0x0f0f;
     }
@@ -1141,6 +1141,37 @@ int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_v
 	return error;
 }
 
+#ifdef CONFIG_TEMP_COMP
+
+int rwnx_send_get_temp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm)
+{
+	struct mm_set_vendor_swconfig_req *req;
+	int ret;
+
+	RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+	/* Build the TEMP_COMP_GET_REQ message */
+	req = rwnx_msg_zalloc(MM_SET_VENDOR_SWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_vendor_swconfig_req));
+	if (!req) {
+		AICWFDBG(LOGINFO, "%s msg_alloc fail\n", __func__);
+		return -ENOMEM;
+	}
+	req->swconfig_id = TEMP_COMP_GET_REQ;
+
+	ret = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_SWCONFIG_CFM, cfm);
+	if (!ret)
+		AICWFDBG(LOGINFO, "status=%d, temp=%d\n", cfm->temp_comp_get_cfm.status, cfm->temp_comp_get_cfm.degree);
+	else {
+		AICWFDBG(LOGINFO, "%s msg_fail\n", __func__);
+		return ret;
+	}
+	//rwnx_hw->started_jiffies = jiffies;
+	rwnx_hw->temp = cfm->temp_comp_get_cfm.degree;
+
+	return ret;
+}
+
+
 int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm)
 {
 	struct mm_set_vendor_swconfig_req *req;
@@ -1166,6 +1197,7 @@ int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_sw
 	}
 	return ret;
 }
+#endif
 
 int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out)
 {
@@ -1174,8 +1206,11 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 	struct mm_set_mac_timescale_req *req2;
 	struct mm_set_cca_threshold_req *req3;
 	struct mm_set_bwmode_req *req4;
+	struct mm_set_ap_ps_level_req *req5 = NULL;
+	struct mm_set_customized_freq_req *req6;
 
 	int error = 0;
+	int i;
 
 	switch (hwconfig_id)
 	{
@@ -1214,8 +1249,9 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
 		req1->rc_retry_cnt[1] = param[10];
 		req1->rc_retry_cnt[2] = param[11];
 		req1->ccademod_th = param[12];
-		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d\n",
-			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th);
+		req1->remove_1m2m = param[13];
+		printk("set_channel_access_req:edca[]= %x %x %x %x\nvif_idx: %x, retry_cnt: %x, rts_en: %x, long_nav_en: %x, cfe_en: %x, rc_retry_cnt: %x:%x:%x, ccademod_th = %d remove_1m2m = %x\n",
+			req1->edca[0], req1->edca[1], req1->edca[2], req1->edca[3], req1->vif_idx, req1->retry_cnt, req1->rts_en, req1->long_nav_en, req1->cfe_en, req1->rc_retry_cnt[0],req1->rc_retry_cnt[1], req1->rc_retry_cnt[2], req1->ccademod_th, req1->remove_1m2m);
 		/* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req1, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
@@ -1265,29 +1301,68 @@ int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id,
                 /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
 		error = rwnx_send_msg(rwnx_hw, req4, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
 		break;
-        case CHIP_TEMP_GET_REQ:
-        if ((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
-            (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW))
-        {
-            struct mm_get_chip_temp_req *req;
-            struct mm_set_vendor_hwconfig_cfm cfm = {0,};
-            /* Build the CHIP_TEMP_GET_REQ message */
-            req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
-            if (!req)
+	case CHIP_TEMP_GET_REQ:
+                if ((rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DC) ||
+                (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800DW))
+                {
+                struct mm_get_chip_temp_req *req;
+                struct mm_set_vendor_hwconfig_cfm cfm = {0,};
+                /* Build the CHIP_TEMP_GET_REQ message */
+                req = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_chip_temp_req));
+                if (!req)
+                        return -ENOMEM;
+                req->hwconfig_id = hwconfig_id;
+                /* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
+                error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
+                if (!error) {
+                        if (param_out) {
+                                param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
+                        }
+                        printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
+                } else {
+                        printk("get_chip_temp err=%d\n", error);
+                        }
+                }
+		break;
+        case AP_PS_LEVEL_SET_REQ:
+                /*
+                    AP_PS_CLK_1 = 1,  // 3:7 -> active 3, doze 7
+                    AP_PS_CLK_2,      // 5:5 -> active 5, doze 5
+                    AP_PS_CLK_3,      // 7:3 -> active 7, doze 3
+                    AP_PS_CLK_4,      // 8:2 -> active 8, doze 2
+                    AP_PS_CLK_5,      // 9:1 -> active 9, doze 1
+                */
+                /* Build the MM_SET_VENDOR_HWCONFIG_REQ message */
+                req5 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID,
+                                      sizeof(struct mm_set_ap_ps_level_req));
+                if (!req5) {
                 return -ENOMEM;
-            req->hwconfig_id = hwconfig_id;
-            /* Send the MM_SET_VENDOR_HWCONFIG_REQ  message to UMAC FW */
-            error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_VENDOR_HWCONFIG_CFM, &cfm);
-            if (!error) {
-                if (param_out) {
-                    param_out[0] = (int32_t)cfm.chip_temp_cfm.degree;
                 }
-                printk("get_chip_temp degree=%d\n", cfm.chip_temp_cfm.degree);
-            } else {
-                printk("get_chip_temp err=%d\n", error);
-            }
-        }
-        break;
+                req5->hwconfig_id = hwconfig_id;
+                req5->ap_ps_level = param[0];
+
+                /* Send the MM_GET_MAC_ADDR_REQ  message to UMAC FW */
+                error = rwnx_send_msg(rwnx_hw, req5, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+                if(!error)
+                        printk("set ap_ps_level=%d \n",param[0]);
+                break;
+
+        case CUSTOMIZED_FREQ_REQ:
+                /* Build the CUSTOMIZED_FREQ_REQ message */
+                req6 = rwnx_msg_zalloc(MM_SET_VENDOR_HWCONFIG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_customized_freq_req));
+                if (!req6)
+                    return -ENOMEM;
+                req5->hwconfig_id = hwconfig_id;
+                for (i = 0; i < 4; i++) {
+                    req6->raw_freq[i] = param [i];
+                    req6->map_freq[i] = param [i + 4];
+                }
+                printk("customized_freq_req: raw_freq[ %d %d %d %d ], map_freq[ %d %d %d %d]\n",
+                        param[0], param[1], param[2], param[3], param[4], param[5], param[6], param[7]);
+                /* Send the MM_SET_VENDOR_HWCONFIG_CFM  message to UMAC FW */
+                error = rwnx_send_msg(rwnx_hw, req5, 1, MM_SET_VENDOR_HWCONFIG_CFM, NULL);
+
+ 		break;
 	    default:
 		return -ENOMEM;
 	}
@@ -1565,30 +1640,37 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
         return -ENOMEM;
     }
 
-    txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
-    txpwr_loss = &txpwr_loss_tmp;
-    txpwr_loss->loss_enable = 0;
+	txpwr_lvl_v3 = &txpwr_lvl_v3_tmp;
+	txpwr_loss = &txpwr_loss_tmp;
+	txpwr_loss->loss_enable_2g4 = 0;
+	txpwr_loss->loss_enable_5g = 0;
 
     get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_v3);
     get_userconfig_txpwr_loss(txpwr_loss);
 
-    if (txpwr_loss->loss_enable == 1) {
-        AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n", __func__, txpwr_loss->loss_value);
+	if (txpwr_loss->loss_enable_2g4 == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+				 txpwr_loss->loss_value_2g4);
+
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11ax_2g4[i] -= txpwr_loss->loss_value_2g4;
+	}
 
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11b_11ag_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 9; i++)
-            txpwr_lvl_v3->pwrlvl_11n_11ac_2g4[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11ax_2g4[i] += txpwr_loss->loss_value;
+	if (txpwr_loss->loss_enable_5g == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
 
 		for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11a_5g[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 9; i++)
-            txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] += txpwr_loss->loss_value;
-        for (i = 0; i <= 11; i++)
-            txpwr_lvl_v3->pwrlvl_11ax_5g[i] += txpwr_loss->loss_value;
-    }
+			txpwr_lvl_v3->pwrlvl_11a_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v3->pwrlvl_11n_11ac_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v3->pwrlvl_11ax_5g[i] -= txpwr_loss->loss_value_5g;
+	}
 
     if (txpwr_lvl_v3->enable == 0) {
         rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
@@ -1674,6 +1756,139 @@ int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw)
     }
 }
 
+int rwnx_send_txpwr_lvl_v4_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_lvl_req *txpwr_lvl_req;
+    txpwr_lvl_conf_v4_t txpwr_lvl_v4_tmp;
+    txpwr_lvl_conf_v4_t *txpwr_lvl_v4;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+    txpwr_loss_conf_t *txpwr_loss;
+    int error;
+	int i;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_LVL_REQ message */
+    txpwr_lvl_req = rwnx_msg_zalloc(MM_SET_TXPWR_IDX_LVL_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_lvl_req));
+
+    if (!txpwr_lvl_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_lvl_v4 = &txpwr_lvl_v4_tmp;
+    txpwr_loss = &txpwr_loss_tmp;
+	txpwr_loss->loss_enable_2g4 = 0;
+	txpwr_loss->loss_enable_5g = 0;
+
+    get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_v4);
+    get_userconfig_txpwr_loss(txpwr_loss);
+
+	if (txpwr_loss->loss_enable_2g4 == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+				 txpwr_loss->loss_value_2g4);
+
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[i] -= txpwr_loss->loss_value_2g4;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11ax_2g4[i] -= txpwr_loss->loss_value_2g4;
+	}
+
+	if (txpwr_loss->loss_enable_5g == 1) {
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+
+		for (i = 0; i <= 7; i++)
+			txpwr_lvl_v4->pwrlvl_11a_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 9; i++)
+			txpwr_lvl_v4->pwrlvl_11n_11ac_5g[i] -= txpwr_loss->loss_value_5g;
+		for (i = 0; i <= 11; i++)
+			txpwr_lvl_v4->pwrlvl_11ax_5g[i] -= txpwr_loss->loss_value_5g;
+	}
+
+
+    if (txpwr_lvl_v4->enable == 0) {
+        rwnx_msg_free(rwnx_hw, txpwr_lvl_req);
+        return 0;
+    } else {
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n",               __func__, txpwr_lvl_v4->enable);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_1m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_2m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_5m5_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_11m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_6m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_9m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_12m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_18m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_24m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_36m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_48m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_54m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[11]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[11]);
+
+        AICWFDBG(LOGINFO, "%s:lvl_11a_6m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_9m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_12m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_18m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_24m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_36m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_48m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11a_54m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[0]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[1]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[2]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[3]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[4]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[5]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[6]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[7]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[8]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[9]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[10]);
+        AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[11]);
+
+        txpwr_lvl_req->txpwr_lvl_v4  = *txpwr_lvl_v4;
+
+        /* Send the MM_SET_TXPWR_LVL_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_lvl_req, 1, MM_SET_TXPWR_IDX_LVL_CFM, NULL);
+
+        return (error);
+    }
+}
+
 int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw)
 {
     struct mm_set_txpwr_lvl_adj_req *txpwr_lvl_adj_req;
@@ -1832,7 +2047,7 @@ int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
             txpwr_ofst2x->pwrofst2x_tbl_5g[type][ch_grp] = 0;
         }
     }
-    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
         get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x);
     }
     if (txpwr_ofst2x->enable){
@@ -1865,6 +2080,137 @@ int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw)
     return (error);
 }
 
+int rwnx_send_txpwr_ofst2x_v2_req(struct rwnx_hw *rwnx_hw)
+{
+    struct mm_set_txpwr_ofst_req *txpwr_ofst_req;
+    txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2;
+    int error = 0;
+    int type, ch_grp;
+
+    RWNX_DBG(RWNX_FN_ENTRY_STR);
+
+    /* Build the MM_SET_TXPWR_OFST_REQ message */
+    txpwr_ofst_req = rwnx_msg_zalloc(MM_SET_TXPWR_OFST_REQ, TASK_MM, DRV_TASK_ID,
+                                  sizeof(struct mm_set_txpwr_ofst_req));
+
+    if (!txpwr_ofst_req) {
+        return -ENOMEM;
+    }
+
+    txpwr_ofst2x_v2 = &txpwr_ofst_req->txpwr_ofst2x_v2;
+    txpwr_ofst2x_v2->enable = 0;
+
+	get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_v2);
+
+    if (txpwr_ofst2x_v2->enable){
+        AICWFDBG(LOGINFO, "%s:enable:%d\r\n", __func__, txpwr_ofst2x_v2->enable);
+        AICWFDBG(LOGINFO, "pwrofst2x 2.4g(ant0/ant1): [0]:11b, [1]:ofdm_highrate\n"
+            "  chan=" "\t1-4" "\t5-9" "\t10-13");
+        for (type = 0; type < 2; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant1[ch_grp][type]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\npwrofst2x 5g(ant0/ant1): [0]:ofdm_highrate\n"
+            "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+        for (type = 0; type < 1; type++) {
+            AICWFDBG(LOGINFO, "\n  [%d] =", type);
+            for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+                AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant1[ch_grp][type]);
+            }
+        }
+        AICWFDBG(LOGINFO, "\n");
+
+        /* Send the MM_SET_TXPWR_OFST_REQ message to UMAC FW */
+        error = rwnx_send_msg(rwnx_hw, txpwr_ofst_req, 1, MM_SET_TXPWR_OFST_CFM, NULL);
+    }else{
+        AICWFDBG(LOGINFO, "%s:Do not use txpwr_ofst2x_v2\r\n", __func__);
+        rwnx_msg_free(rwnx_hw, txpwr_ofst_req);
+    }
+
+    return (error);
+}
+
+#ifdef CONFIG_APF
+int rwnx_send_set_apf_prog_req(struct rwnx_hw *rwnx_hw, u8_l *program, u32_l program_len)
+{
+	struct mm_set_apf_prog_req *req;
+	int error = 0;
+	int buffer_len, buffer_start = 0, buffer_end, page;
+
+	/* current only 8800d80 support apf */
+	if (rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80) {
+		return 0;
+	}
+
+	if (!program)
+		return -ENOMEM;
+
+	for (page = 0; buffer_start < program_len; page++) {
+		buffer_end = buffer_start + LMAC_MSG_MAX_LEN;
+		if (buffer_end > program_len)
+			buffer_end = program_len;
+		buffer_len = buffer_end - buffer_start;
+
+		/* Build the MM_SET_TXOP_REQ message */
+		req = rwnx_msg_zalloc(MM_SET_APF_PROG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_set_apf_prog_req));
+		if (!req)
+			return -ENOMEM;
+
+		req->program_len = buffer_len;
+		req->offset = page;
+		memcpy(req->program, program + buffer_start, buffer_len);
+		buffer_start = buffer_end;
+
+		/* Send the MM_SET_TXOP_REQ  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req, 1, MM_SET_APF_PROG_CFM, NULL);
+		if (error)
+			break;
+	}
+	return error;
+}
+
+int rwnx_send_get_apf_prog_req(struct rwnx_hw *rwnx_hw, u8_l *program, u32_l program_len)
+{
+	struct mm_get_apf_prog_req *req;
+	int error = 0;
+	struct mm_get_apf_prog_cfm cfm;
+	int buffer_len, buffer_start = 0, buffer_end, page;
+
+	/* current only 8800d80 support apf */
+	if (rwnx_hw->sdiodev->chipid != PRODUCT_ID_AIC8800D80) {
+		return 0;
+	}
+
+	if (!program)
+		return -ENOMEM;
+
+	for (page = 0; buffer_start < program_len; page++) {
+		buffer_end = buffer_start + LMAC_MSG_MAX_LEN;
+		if (buffer_end > program_len)
+			buffer_end = program_len;
+		buffer_len = buffer_end - buffer_start;
+
+		/* Build the MM_SET_TXOP_REQ message */
+		req = rwnx_msg_zalloc(MM_GET_APF_PROG_REQ, TASK_MM, DRV_TASK_ID, sizeof(struct mm_get_apf_prog_req));
+		if (!req)
+			return -ENOMEM;
+
+		req->offset = page;
+		/* Send the MM_GET_APF_PROG_REQ  message to UMAC FW */
+		error = rwnx_send_msg(rwnx_hw, req, 1, MM_GET_APF_PROG_CFM, &cfm);
+		if (error)
+			break;
+
+		memcpy(program + buffer_start, cfm.program, buffer_len);
+		buffer_start = buffer_end;
+	}
+
+	return error;
+}
+#endif
+
 /******************************************************************************
  *    Control messages handling functions (FULLMAC only)
  *****************************************************************************/
@@ -1895,7 +2241,7 @@ int rwnx_send_me_config_req(struct rwnx_hw *rwnx_hw)
 	uint8_t *ht_mcs;
 	int i;
 
-    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80) {
+    if (rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2) {
         rwnx_hw->mod_params->use_80 = true;
     }
 
@@ -2004,6 +2350,11 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
 	struct me_chan_config_req *req;
 	struct wiphy *wiphy = rwnx_hw->wiphy;
 	int i;
+#ifdef CONFIG_POWER_LIMIT
+	int8_t max_pwr;
+	txpwr_loss_conf_t txpwr_loss_tmp;
+	txpwr_loss_conf_t *txpwr_loss;
+#endif
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
@@ -2013,6 +2364,18 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
 	if (!req)
 		return -ENOMEM;
 
+#ifdef CONFIG_POWER_LIMIT
+	txpwr_loss = &txpwr_loss_tmp;
+	get_userconfig_txpwr_loss(txpwr_loss);
+
+	if (txpwr_loss->loss_enable_2g4 == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_2g4: %d\r\n", __func__,
+					txpwr_loss->loss_value_2g4);
+	if (txpwr_loss->loss_enable_5g == 1)
+		AICWFDBG(LOGINFO, "%s:loss_value_5g: %d\r\n", __func__,
+				 txpwr_loss->loss_value_5g);
+#endif
+
 	req->chan2G4_cnt =  0;
 	if (wiphy->bands[NL80211_BAND_2GHZ] != NULL) {
 		struct ieee80211_supported_band *b = wiphy->bands[NL80211_BAND_2GHZ];
@@ -2024,6 +2387,15 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
 			req->chan2G4[req->chan2G4_cnt].band = NL80211_BAND_2GHZ;
 			req->chan2G4[req->chan2G4_cnt].freq = b->channels[i].center_freq;
 			req->chan2G4[req->chan2G4_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+#ifdef CONFIG_POWER_LIMIT
+			{
+				max_pwr = get_powerlimit_by_freq(PHY_BAND_2G4, req->chan2G4[req->chan2G4_cnt].freq);
+				if (txpwr_loss->loss_enable_2g4 == 1)
+					max_pwr -= txpwr_loss->loss_value_2g4;
+				if (req->chan2G4[req->chan2G4_cnt].tx_power > max_pwr)
+					req->chan2G4[req->chan2G4_cnt].tx_power = max_pwr;
+			}
+#endif
 			req->chan2G4_cnt++;
 			if (req->chan2G4_cnt == MAC_DOMAINCHANNEL_24G_MAX)
 				break;
@@ -2041,6 +2413,15 @@ int rwnx_send_me_chan_config_req(struct rwnx_hw *rwnx_hw)
 			req->chan5G[req->chan5G_cnt].band = NL80211_BAND_5GHZ;
 			req->chan5G[req->chan5G_cnt].freq = b->channels[i].center_freq;
 			req->chan5G[req->chan5G_cnt].tx_power = chan_to_fw_pwr(b->channels[i].max_power);
+#ifdef CONFIG_POWER_LIMIT
+			{
+				max_pwr = get_powerlimit_by_freq( PHY_BAND_5G, req->chan5G[req->chan5G_cnt].freq);
+				if (txpwr_loss->loss_enable_5g == 1)
+					max_pwr -= txpwr_loss->loss_value_5g;
+				if (req->chan5G[req->chan5G_cnt].tx_power > max_pwr)
+					req->chan5G[req->chan5G_cnt].tx_power = max_pwr;
+			}
+#endif
 			req->chan5G_cnt++;
 			if (req->chan5G_cnt == MAC_DOMAINCHANNEL_5G_MAX)
 				break;
@@ -2071,6 +2452,13 @@ int rwnx_send_me_set_control_port_req(struct rwnx_hw *rwnx_hw, bool opened, u8 s
 	return rwnx_send_msg(rwnx_hw, req, 1, ME_SET_CONTROL_PORT_CFM, NULL);
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0))
+struct ieee80211_he_cap_elem_4_19 {
+	u8 mac_cap_info[6];
+	u8 phy_cap_info[11];
+} __packed;
+#endif
+
 int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *params,
 						 const u8 *mac, u8 inst_nbr, struct me_sta_add_cfm *cfm)
 {
@@ -2137,20 +2525,24 @@ int rwnx_send_me_sta_add(struct rwnx_hw *rwnx_hw, struct station_parameters *par
     }
 #elif defined(CONFIG_VHT_FOR_OLD_KERNEL)
     if (sta->vht) {
-        const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
+        //const struct ieee80211_vht_cap *vht_capa = rwnx_vht_capa;
 
         req->flags |= STA_VHT_CAPA;
-        req->vht_cap.vht_capa_info = cpu_to_le32(vht_capa->vht_cap_info);
-        req->vht_cap.rx_highest = cpu_to_le16(vht_capa->supp_mcs.rx_highest);
-        req->vht_cap.rx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.rx_mcs_map);
-        req->vht_cap.tx_highest = cpu_to_le16(vht_capa->supp_mcs.tx_highest);
-        req->vht_cap.tx_mcs_map = cpu_to_le16(vht_capa->supp_mcs.tx_mcs_map);
+        req->vht_cap.vht_capa_info = cpu_to_le32(rwnx_vht_capa->cap);
+        req->vht_cap.rx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_highest);
+        req->vht_cap.rx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.rx_mcs_map);
+        req->vht_cap.tx_highest = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_highest);
+        req->vht_cap.tx_mcs_map = cpu_to_le16(rwnx_vht_capa->vht_mcs.tx_mcs_map);
     }
 #endif
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 19, 0)
 	if (link_sta_params->he_capa) {
+		#if LINUX_VERSION_CODE <  KERNEL_VERSION(4, 20, 0)
+			const struct ieee80211_he_cap_elem_4_19 *he_capa = (const struct ieee80211_he_cap_elem_4_19 *) link_sta_params->he_capa;
+		#else
 		const struct ieee80211_he_cap_elem *he_capa = link_sta_params->he_capa;
+		#endif
 		struct ieee80211_he_mcs_nss_supp *mcs_nss_supp =
 								(struct ieee80211_he_mcs_nss_supp *)(he_capa + 1);
 
@@ -2326,12 +2718,13 @@ int rwnx_send_me_set_ps_mode(struct rwnx_hw *rwnx_hw, u8 ps_mode)
 	return rwnx_send_msg(rwnx_hw, req, 1, ME_SET_PS_MODE_CFM, NULL);
 }
 
-int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level)
+int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level, u8 disable_filter)
 {
 	struct me_set_lp_level_req *req;
 
 	RWNX_DBG(RWNX_FN_ENTRY_STR);
 
+	printk("%s %d %d \n", __func__, lp_level, disable_filter);
 	/* Build the ME_SET_LP_LEVEL_REQ message */
 	req = rwnx_msg_zalloc(ME_SET_LP_LEVEL_REQ, TASK_ME, DRV_TASK_ID,
 						  sizeof(struct me_set_lp_level_req));
@@ -2340,7 +2733,7 @@ int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level)
 
 	/* Set parameters for the ME_SET_LP_LEVEL_REQ message */
 	req->lp_level = lp_level;
-
+	req->disable_filter = disable_filter;
 	/* Send the ME_SET_LP_LEVEL_REQ message to FW */
 	return rwnx_send_msg(rwnx_hw, req, 1, ME_SET_LP_LEVEL_CFM, NULL);
 }
@@ -2725,7 +3118,7 @@ int rwnx_send_scanu_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *rwnx_vif,
         req->duration = 0;
 #endif
 
-#ifdef RADAR_OR_IR_DETECT
+#ifdef CONFIG_RADAR_OR_IR_DETECT
 	if (req->ssid_cnt == 0)
 		chan_flags |= CHAN_NO_IR;
 #endif
@@ -2860,11 +3253,12 @@ int rwnx_send_apm_start_cac_req(struct rwnx_hw *rwnx_hw, struct rwnx_vif *vif,
 	/* Set parameters for the APM_START_CAC_REQ message */
 	req->vif_idx = vif->vif_index;
 	req->chan.band = chandef->chan->band;
-	req->chan.freq = chandef->chan->center_freq;
-	req->chan.flags = 0;
-	req->center_freq1 = chandef->center_freq1;
-	req->center_freq2 = chandef->center_freq2;
-	req->ch_width = bw2chnl[chandef->width];
+        req->chan.type = bw2chnl[chandef->width];
+        req->chan.prim20_freq = chandef->chan->center_freq;
+        req->chan.center1_freq = chandef->center_freq1;
+        req->chan.center2_freq = chandef->center_freq2;
+        req->chan.tx_power = 20;
+        req->chan.flags = get_chan_flags(chandef->chan->flags);
 
 	/* Send the APM_START_CAC_REQ message to LMAC FW */
 	return rwnx_send_msg(rwnx_hw, req, 1, APM_START_CAC_CFM, cfm);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
index 836f43b91335..95f4862221e4 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_msg_tx.h
@@ -80,7 +80,7 @@ int rwnx_send_me_rc_set_rate(struct rwnx_hw *rwnx_hw,
 							 u8 sta_idx,
 							 u16 rate_idx);
 int rwnx_send_me_set_ps_mode(struct rwnx_hw *rwnx_hw, u8 ps_mode);
-int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level);
+int rwnx_send_me_set_lp_level(struct rwnx_hw *rwnx_hw, u8 lp_level, u8 disable_filter);
 int rwnx_send_sm_connect_req(struct rwnx_hw *rwnx_hw,
 							 struct rwnx_vif *rwnx_vif,
 							 struct cfg80211_connect_params *sme,
@@ -167,6 +167,7 @@ int rwnx_send_get_sta_info_req(struct rwnx_hw *rwnx_hw, u8_l sta_idx, struct mm_
 int rwnx_send_set_stack_start_req(struct rwnx_hw *rwnx_hw, u8_l on, u8_l efuse_valid, u8_l set_vendor_info,
 					u8_l fwtrace_redir_en, struct mm_set_stack_start_cfm *cfm);
 int rwnx_send_txop_req(struct rwnx_hw *rwnx_hw, uint16_t *txop, u8_l long_nav_en, u8_l cfe_en);
+int rwnx_send_get_temp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
 int rwnx_send_set_temp_comp_req(struct rwnx_hw *rwnx_hw, struct mm_set_vendor_swconfig_cfm *cfm);
 int rwnx_send_vendor_hwconfig_req(struct rwnx_hw *rwnx_hw, uint32_t hwconfig_id, int32_t *param, int32_t *param_out);
 int rwnx_send_vendor_swconfig_req(struct rwnx_hw *rwnx_hw, uint32_t swconfig_id, int32_t *param_in, int32_t *param_out);
@@ -175,9 +176,15 @@ int rwnx_send_get_fw_version_req(struct rwnx_hw *rwnx_hw, struct mm_get_fw_versi
 int rwnx_send_txpwr_idx_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_ofst2x_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_ofst2x_v2_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_v3_req(struct rwnx_hw *rwnx_hw);
+int rwnx_send_txpwr_lvl_v4_req(struct rwnx_hw *rwnx_hw);
 int rwnx_send_txpwr_lvl_adj_req(struct rwnx_hw *rwnx_hw);
+#ifdef CONFIG_APF
+int rwnx_send_set_apf_prog_req(struct rwnx_hw *rwnx_hw, u8_l *program, u32_l program_len);
+int rwnx_send_get_apf_prog_req(struct rwnx_hw *rwnx_hw, u8_l *program, u32_l program_len);
+#endif
 
 #ifdef CONFIG_SDIO_BT
 int rwnx_sdio_bt_send_req(struct rwnx_hw *rwnx_hw,uint32_t len, struct sk_buff *skb);
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
index a422ed13bd2b..07682f4e18cc 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.c
@@ -55,10 +55,12 @@ typedef struct
     txpwr_lvl_conf_t txpwr_lvl;
     txpwr_lvl_conf_v2_t txpwr_lvl_v2;
     txpwr_lvl_conf_v3_t txpwr_lvl_v3;
+	txpwr_lvl_conf_v4_t txpwr_lvl_v4;
     txpwr_lvl_adj_conf_t txpwr_lvl_adj;
 	txpwr_loss_conf_t txpwr_loss;
     txpwr_ofst_conf_t txpwr_ofst;
 	txpwr_ofst2x_conf_t txpwr_ofst2x;
+	txpwr_ofst2x_conf_v2_t txpwr_ofst2x_v2;
     xtal_cap_conf_t xtal_cap;
 } userconfig_info_t;
 
@@ -107,10 +109,33 @@ userconfig_info_t userconfig_info = {
         .pwrlvl_11ax_5g =
             //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
             { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15,   14,   14},
+    },
+    .txpwr_lvl_v4 = {
+        .enable             = 1,
+        .pwrlvl_11b_11ag_2g4 =
+            //1M,   2M,   5M5,  11M,  6M,   9M,   12M,  18M,  24M,  36M,  48M,  54M
+            { 20,   20,   20,   20,   20,   20,   20,   20,   18,   18,   16,   16},
+        .pwrlvl_11n_11ac_2g4 =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   16},
+        .pwrlvl_11ax_2g4 =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   16,   15,   15},
+        .pwrlvl_11a_5g =
+            //6M,   9M,   12M,  18M,  24M,  36M,  48M,  54M
+            { 20,   20,   20,   20,   18,   18,   16,   16},
+        .pwrlvl_11n_11ac_5g =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15},
+        .pwrlvl_11ax_5g =
+            //MCS0, MCS1, MCS2, MCS3, MCS4, MCS5, MCS6, MCS7, MCS8, MCS9, MCS10,MCS11
+            { 20,   20,   20,   20,   18,   18,   16,   16,   16,   15,   14,   14},
     },
 	.txpwr_loss = {
-		.loss_enable	  = 1,
-		.loss_value 	  = 0,
+		.loss_enable_2g4 = 0,
+		.loss_value_2g4 = 0,
+		.loss_enable_5g = 0,
+		.loss_value_5g = 0,
 	},
     .txpwr_ofst = {
         .enable       = 1,
@@ -137,6 +162,42 @@ userconfig_info_t userconfig_info = {
             {   0,    0,    0,    0,    0,    0   }, // ofdm_midrate
         },
     },
+    .txpwr_ofst2x_v2 = {
+        .enable        = 0,
+        .pwrofst_flags = 0,
+        .pwrofst2x_tbl_2g4_ant0 =
+        { // 11b, ofdm_highrate, ofdm_lowrate
+            {   0,    0,    0   }, // ch1-4
+            {   0,    0,    0   }, // ch5-9
+            {   0,    0,    0   }, // ch10-13
+        },
+        .pwrofst2x_tbl_2g4_ant1 =
+        { // 11b, ofdm_highrate, ofdm_lowrate
+            {   0,    0,    0   }, // ch1-4
+            {   0,    0,    0   }, // ch5-9
+            {   0,    0,    0   }, // ch10-13
+        },
+        .pwrofst2x_tbl_5g_ant0 =
+        { // ofdm_highrate, ofdm_lowrate, ofdm_midrate
+            {   0,    0,    0   }, // ch42
+            {   0,    0,    0   }, // ch58
+            {   0,    0,    0   }, // ch106
+            {   0,    0,    0   }, // ch122
+            {   0,    0,    0   }, // ch138
+            {   0,    0,    0   }, // ch155
+        },
+        .pwrofst2x_tbl_5g_ant1 =
+        { // ofdm_highrate, ofdm_lowrate, ofdm_midrate
+            {   0,    0,    0   }, // ch42
+            {   0,    0,    0   }, // ch58
+            {   0,    0,    0   }, // ch106
+            {   0,    0,    0   }, // ch122
+            {   0,    0,    0   }, // ch138
+            {   0,    0,    0   }, // ch155
+        },
+        .pwrofst2x_tbl_6g_ant0 = {   0,   }, // ofdm_highrate: 6e_ch7 ~ 6e_ch229
+        .pwrofst2x_tbl_6g_ant1 = {   0,   }, // ofdm_highrate: 6e_ch7 ~ 6e_ch229
+    },
     .xtal_cap = {
         .enable        = 0,
         .xtal_cap      = 24,
@@ -144,6 +205,29 @@ userconfig_info_t userconfig_info = {
     },
 };
 
+#ifdef CONFIG_POWER_LIMIT
+#define POWER_LIMIT_INVALID_VAL     POWER_LEVEL_INVALID_VAL
+
+#define POWER_LIMIT_CC_MATCHED_BIT  (0x1U << 0)
+
+typedef struct
+{
+    u8_l ch_cnt_2g4;
+    u8_l ch_cnt_5g;
+    u8_l ch_num_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    u8_l ch_num_5g[MAC_DOMAINCHANNEL_5G_MAX];
+    s8_l max_pwr_2g4[MAC_DOMAINCHANNEL_24G_MAX];
+    s8_l max_pwr_5g[MAC_DOMAINCHANNEL_5G_MAX];
+} txpwr_lmt_info_t;
+
+typedef struct
+{
+    u32_l flags;
+    txpwr_lmt_info_t txpwr_lmt;
+} powerlimit_info_t;
+
+powerlimit_info_t powerlimit_info = {0,};
+#endif
 
 #ifdef CONFIG_RWNX_TL4
 /**
@@ -605,6 +689,30 @@ void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x)
     AICWFDBG(LOGINFO, "\n");
 }
 
+void get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2)
+{
+    int type, ch_grp;
+    *txpwr_ofst2x_v2 = userconfig_info.txpwr_ofst2x_v2;
+    AICWFDBG(LOGINFO, "%s:enable      :%d\r\n", __func__, txpwr_ofst2x_v2->enable);
+    AICWFDBG(LOGINFO, "pwrofst2x 2.4g(ant0/ant1): [0]:11b, [1]:ofdm_highrate\n"
+        "  chan=" "\t1-4" "\t5-9" "\t10-13");
+    for (type = 0; type < 2; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 3; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_2g4_ant1[ch_grp][type]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\npwrofst2x 5g: [0]:ofdm_highrate\n"
+        "  chan=" "\t36-50" "\t51-64" "\t98-114" "\t115-130" "\t131-146" "\t147-166");
+    for (type = 0; type < 1; type++) {
+        AICWFDBG(LOGINFO, "\n  [%d] =", type);
+        for (ch_grp = 0; ch_grp < 6; ch_grp++) {
+            AICWFDBG(LOGINFO, "\t%d/%d", txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant0[ch_grp][type], txpwr_ofst2x_v2->pwrofst2x_tbl_5g_ant1[ch_grp][type]);
+        }
+    }
+    AICWFDBG(LOGINFO, "\n");
+}
+
 void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx)
 {
 	memcpy(txpwr_idx, &(nvram_info.txpwr_idx), sizeof(txpwr_idx_conf_t));
@@ -630,6 +738,101 @@ void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap)
     AICWFDBG(LOGINFO, "%s:xtal_cap_fine:%d\r\n", __func__, xtal_cap->xtal_cap_fine);
 }
 
+s8_l get_txpwr_max(s8_l power)
+{
+	int i=0;
+
+	if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		for (i = 0; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11b_11ag_2g4[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11b_11ag_2g4[i];
+		}
+	    for (i = 0; i <= 9; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_2g4[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_2g4[i];
+	    }
+	    for (i = 0; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_2g4[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_2g4[i];
+	    }
+		for (i = 4; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11a_5g[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11a_5g[i];
+		}
+	    for (i = 0; i <= 9; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_5g[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_5g[i];
+	    }
+		for (i = 0; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[i])
+				power = userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[i];
+		}
+
+		if ((userconfig_info.txpwr_loss.loss_enable_2g4 == 1) ||
+			(userconfig_info.txpwr_loss.loss_enable_5g == 1)) {
+			if (userconfig_info.txpwr_loss.loss_value_2g4 <
+				userconfig_info.txpwr_loss.loss_value_5g)
+				power += userconfig_info.txpwr_loss.loss_value_5g;
+			else
+				power += userconfig_info.txpwr_loss.loss_value_2g4;
+		}
+
+	}else if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+		for (i = 0; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v2.pwrlvl_11b_11ag_2g4[i])
+				power = userconfig_info.txpwr_lvl_v2.pwrlvl_11b_11ag_2g4[i];
+		}
+	    for (i = 0; i <= 9; i++){
+			if(power < userconfig_info.txpwr_lvl_v2.pwrlvl_11n_11ac_2g4[i])
+				power = userconfig_info.txpwr_lvl_v2.pwrlvl_11n_11ac_2g4[i];
+	    }
+	    for (i = 0; i <= 11; i++){
+			if(power < userconfig_info.txpwr_lvl_v2.pwrlvl_11ax_2g4[i])
+				power = userconfig_info.txpwr_lvl_v2.pwrlvl_11ax_2g4[i];
+	    }
+	}
+
+	printk("%s:txpwr_max:%d \r\n",__func__,power);
+	return power;
+}
+
+
+void set_txpwr_loss_ofst(s8_l value)
+{
+	int i=0;
+	if (g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80 || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		for (i = 0; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11b_11ag_2g4[i] += value;
+		}
+	    for (i = 0; i <= 9; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_2g4[i] += value;
+	    }
+	    for (i = 0; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_2g4[i] += value;
+	    }
+		for (i = 4; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11a_5g[i] += value;
+		}
+	    for (i = 0; i <= 9; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11n_11ac_5g[i] += value;
+	    }
+		for (i = 0; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v3.pwrlvl_11ax_5g[i] += value;
+		}
+	}else if(g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC || g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW){
+		for (i = 0; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v2.pwrlvl_11b_11ag_2g4[i] += value;
+		}
+	    for (i = 0; i <= 9; i++){
+			userconfig_info.txpwr_lvl_v2.pwrlvl_11n_11ac_2g4[i] += value;
+	    }
+	    for (i = 0; i <= 11; i++){
+			userconfig_info.txpwr_lvl_v2.pwrlvl_11ax_2g4[i] += value;
+	    }
+	}
+	printk("%s:value:%d\r\n", __func__, value);
+}
+
 
 #define MATCH_NODE(type, node, cfg_key) {cfg_key, offsetof(type, node)}
 
@@ -732,6 +935,32 @@ static int parse_key_val(const char *str, const char *key, char *val)
 	return 0;
 }
 
+int rwnx_atoi2(char *value, int c_len)
+{
+    int len = 0;
+    int i = 0;
+    int result = 0;
+    int flag = 1;
+
+    if (value[0] == '-') {
+        flag = -1;
+        value++;
+    }
+    len = c_len;
+
+    for (i = 0;i < len ;i++) {
+        result = result * 10;
+        if (value[i] >= 48 && value[i] <= 57) {
+            result += value[i] - 48;
+        } else {
+            result = 0;
+            break;
+        }
+    }
+
+    return result * flag;
+}
+
 
 int rwnx_atoi(char *value)
 {
@@ -1049,22 +1278,26 @@ void rwnx_plat_nvram_set_value_v3(char *command, char *value)
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[1] = rwnx_atoi(value);
     } else if (!strcmp(command, "lvl_adj_2g4_chan_10_13")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[2] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_42")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_42")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[0] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_58")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_58")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[1] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_106")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_106")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[2] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_122")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_122")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[3] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_138")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_138")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[4] = rwnx_atoi(value);
-    } else if (!strcmp(command, "ofst_5g_ofdm_highrate_chan_155")) {
+    } else if (!strcmp(command, "lvl_adj_5g_chan_155")) {
         userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[5] = rwnx_atoi(value);
-    } else if (!strcmp(command, "loss_enable")) {
-        userconfig_info.txpwr_loss.loss_enable = rwnx_atoi(value);
-    } else if (!strcmp(command, "loss_value")) {
-        userconfig_info.txpwr_loss.loss_value = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_2g4")) {
+        userconfig_info.txpwr_loss.loss_enable_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_2g4")) {
+        userconfig_info.txpwr_loss.loss_value_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_5g")) {
+        userconfig_info.txpwr_loss.loss_enable_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_5g")) {
+        userconfig_info.txpwr_loss.loss_value_5g = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_enable")) {
         userconfig_info.txpwr_ofst.enable = rwnx_atoi(value);
 		userconfig_info.txpwr_ofst2x.enable = rwnx_atoi(value);
@@ -1099,7 +1332,7 @@ void rwnx_plat_nvram_set_value_v3(char *command, char *value)
     } else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_5_9")) {
         userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][1] = rwnx_atoi(value);
 	} else if (!strcmp(command, "ofst_2g4_ofdm_lowrate_chan_10_13")) {
-        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][0] = rwnx_atoi(value);
+        userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_2g4[2][2] = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_42")) {
         userconfig_info.txpwr_ofst2x.pwrofst2x_tbl_5g[0][0] = rwnx_atoi(value);
     } else if (!strcmp(command, "ofst_5g_ofdm_lowrate_chan_58")) {
@@ -1334,6 +1567,294 @@ void rwnx_plat_userconfig_parsing(struct rwnx_hw *rwnx_hw, char *buffer, int siz
 	vfree(data);
 }
 
+void rwnx_plat_nvram_set_value_8800d80x2(char *command, char *value)
+{
+    //TODO send command
+    AICWFDBG(LOGINFO, "%s:command=%s value=%s\n", __func__, command, value);
+    if (!strcmp(command, "enable")) {
+        userconfig_info.txpwr_lvl_v4.enable = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_1m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_2m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_5m5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_11m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_6m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_9m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_12m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_18m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_24m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_36m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_48m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11b_11ag_54m_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11b_11ag_2g4[11] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs0_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs1_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs2_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs3_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs4_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs6_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs7_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs8_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs9_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs0_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs1_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs2_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs3_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs4_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs5_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs6_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs7_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs8_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs9_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs10_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs11_2g4")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_2g4[11] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_6m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_9m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_12m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_18m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_24m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_36m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_48m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11a_54m_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11a_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs0_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs1_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs2_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs3_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs4_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs5_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs6_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs7_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs8_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11n_11ac_mcs9_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11n_11ac_5g[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs0_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs1_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs2_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs3_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs4_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs5_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs6_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[6] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs7_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[7] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs8_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[8] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs9_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[9] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs10_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[10] = rwnx_atoi(value);
+    } else if (!strcmp(command,     "lvl_11ax_mcs11_5g")) {
+        userconfig_info.txpwr_lvl_v4.pwrlvl_11ax_5g[11] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_enable")) {
+        userconfig_info.txpwr_lvl_adj.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_1_4")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_5_9")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_2g4_chan_10_13")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_2g4[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_42")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_58")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_106")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[2] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_122")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[3] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_138")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[4] = rwnx_atoi(value);
+    } else if (!strcmp(command, "lvl_adj_5g_chan_155")) {
+        userconfig_info.txpwr_lvl_adj.pwrlvl_adj_tbl_5g[5] = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_2g4")) {
+        userconfig_info.txpwr_loss.loss_enable_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_2g4")) {
+        userconfig_info.txpwr_loss.loss_value_2g4 = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_enable_5g")) {
+        userconfig_info.txpwr_loss.loss_enable_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "loss_value_5g")) {
+        userconfig_info.txpwr_loss.loss_value_5g = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_enable")) {
+		userconfig_info.txpwr_ofst2x_v2.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant0_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant0[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_11b_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_1_4")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[0][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_5_9")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[1][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_2g4_ant1_ofdm_highrate_chan_10_13")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_2g4_ant1[2][1] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[3][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[4][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant0_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant0[5][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_42")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[0][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_58")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[1][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_106")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[2][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_122")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[3][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_138")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[4][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "ofst_5g_ant1_ofdm_highrate_chan_155")) {
+        userconfig_info.txpwr_ofst2x_v2.pwrofst2x_tbl_5g_ant1[5][0] = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_enable")) {
+        userconfig_info.xtal_cap.enable = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_cap")) {
+        userconfig_info.xtal_cap.xtal_cap = rwnx_atoi(value);
+    } else if (!strcmp(command, "xtal_cap_fine")) {
+        userconfig_info.xtal_cap.xtal_cap_fine = rwnx_atoi(value);
+    } else {
+        AICWFDBG(LOGERROR, "invalid cmd: %s\n", command);
+    }
+}
+
+void rwnx_plat_userconfig_parsing_8800d80x2(char *buffer, int size)
+{
+    int i = 0;
+    int parse_state = 0;
+    char command[64];
+    char value[100];
+    int char_counter = 0;
+
+    memset(command, 0, 64);
+    memset(value, 0, 100);
+
+    for (i = 0; i < size; i++) {
+        //Send command or print nvram log when char is \r or \n
+        if (buffer[i] == 0x0a || buffer[i] == 0x0d) {
+            if (command[0] != 0 && value[0] != 0) {
+                if (parse_state == PRINT) {
+                    AICWFDBG(LOGINFO, "%s:%s\r\n", __func__, value);
+                } else if (parse_state == GET_VALUE) {
+                    rwnx_plat_nvram_set_value_8800d80x2(command, value);
+                }
+            }
+            //Reset command value and char_counter
+            memset(command, 0, 64);
+            memset(value, 0, 100);
+            char_counter = 0;
+            parse_state = INIT;
+            continue;
+        }
+
+        //Switch parser state
+        if (parse_state == INIT) {
+            if (buffer[i] == '#') {
+                parse_state = PRINT;
+                continue;
+            } else if (buffer[i] == 0x0a || buffer[i] == 0x0d) {
+                parse_state = INIT;
+                continue;
+            } else {
+                parse_state = CMD;
+            }
+        }
+
+        //Fill data to command and value
+        if (parse_state == PRINT) {
+            command[0] = 0x01;
+            value[char_counter] = buffer[i];
+            char_counter++;
+        } else if (parse_state == CMD) {
+            if (command[0] != 0 && buffer[i] == '=') {
+                parse_state = GET_VALUE;
+                char_counter = 0;
+                continue;
+            }
+            command[char_counter] = buffer[i];
+            char_counter++;
+        } else if (parse_state == GET_VALUE) {
+            if(buffer[i] != 0x2D && (buffer[i] < 0x30 || buffer[i] > 0x39)) {
+                continue;
+            }
+            value[char_counter] = buffer[i];
+            char_counter++;
+        }
+    }
+}
+
 static int aic_load_firmware(u32 ** fw_buf, char *fw_path,const char *name, struct device *device)
 {
 #ifdef CONFIG_USE_FW_REQUEST
@@ -1896,6 +2417,78 @@ void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3)
     AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v3->pwrlvl_11ax_5g[11]);
 }
 
+void get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_conf_v4_t *txpwr_lvl_v4)
+{
+    *txpwr_lvl_v4 = userconfig_info.txpwr_lvl_v4;
+
+    AICWFDBG(LOGINFO, "%s:enable:%d\r\n",               __func__, txpwr_lvl_v4->enable);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_1m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_2m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_5m5_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_11m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_6m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_9m_2g4:%d\r\n",  __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_12m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_18m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_24m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_36m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_48m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11b_11ag_54m_2g4:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11b_11ag_2g4[11]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_2g4:%d\r\n",__func__, txpwr_lvl_v4->pwrlvl_11n_11ac_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_2g4:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_2g4:%d\r\n",   __func__, txpwr_lvl_v4->pwrlvl_11ax_2g4[11]);
+
+    AICWFDBG(LOGINFO, "%s:lvl_11a_6m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_9m_5g:%d\r\n",        __func__, txpwr_lvl_v4->pwrlvl_11a_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_12m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_18m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_24m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_36m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_48m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11a_54m_5g:%d\r\n",       __func__, txpwr_lvl_v4->pwrlvl_11a_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs0_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs1_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs2_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs3_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs4_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs5_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs6_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs7_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs8_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11n_11ac_mcs9_5g:%d\r\n", __func__, txpwr_lvl_v4->pwrlvl_11n_11ac_5g[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs0_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[0]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs1_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[1]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs2_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[2]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs3_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[3]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs4_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[4]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs5_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[5]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs6_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[6]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs7_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[7]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs8_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[8]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs9_5g:%d\r\n",     __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[9]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs10_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[10]);
+    AICWFDBG(LOGINFO, "%s:lvl_11ax_mcs11_5g:%d\r\n",    __func__, txpwr_lvl_v4->pwrlvl_11ax_5g[11]);
+}
+
 void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj)
 {
     *txpwr_lvl_adj = userconfig_info.txpwr_lvl_adj;
@@ -1913,6 +2506,405 @@ void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj)
     AICWFDBG(LOGINFO, "%s:lvl_adj_5g_chan_155:%d\r\n",      __func__, txpwr_lvl_adj->pwrlvl_adj_tbl_5g[5]);
 }
 
+#ifdef CONFIG_POWER_LIMIT
+#define GetLineFromBuffer(buffer)   strsep(&buffer, "\n")
+
+int isAllSpaceOrTab(uint8_t *data, uint8_t size)
+{
+    uint8_t cnt = 0, NumOfSpaceAndTab = 0;
+    while (size > cnt) {
+        if (data[cnt] == ' ' || data[cnt] == '\t' || data[cnt] == '\0')
+            ++NumOfSpaceAndTab;
+        ++cnt;
+    }
+    return size == NumOfSpaceAndTab;
+}
+
+int IsCommentString(char *szStr)
+{
+    if (*szStr == '#' && *(szStr + 1) == ' ')
+        return 1;
+    else
+        return 0;
+}
+
+int ParseQualifiedString(char *In, u32 *Start, char *Out, char LeftQualifier, char RightQualifier)
+{
+    u32 i = 0, j = 0;
+    char c = In[(*Start)++];
+    if (c != LeftQualifier)
+        return 0;
+    i = (*Start);
+    c = In[(*Start)++];
+    while (c != RightQualifier && c != '\0')
+        c = In[(*Start)++];
+    if (c == '\0')
+        return 0;
+    j = (*Start) - 2;
+    strncpy((char *)Out, (const char *)(In + i), j - i + 1);
+    return 1;
+}
+
+int GetU1ByteIntegerFromStringInDecimal(char *Str, u8 *pInt)
+{
+    u16 i = 0;
+    *pInt = 0;
+    while (Str[i] != '\0') {
+        if (Str[i] >= '0' && Str[i] <= '9') {
+            *pInt *= 10;
+            *pInt += (Str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    return 1;
+}
+int GetS1ByteIntegerFromStringInDecimal(char *str, s8 *val)
+{
+    u8 negative = 0;
+    u16 i = 0;
+    *val = 0;
+    while (str[i] != '\0') {
+        if (i == 0 && (str[i] == '+' || str[i] == '-')) {
+            if (str[i] == '-')
+                negative = 1;
+        } else if (str[i] >= '0' && str[i] <= '9') {
+            *val *= 10;
+            *val += (str[i] - '0');
+        } else
+            return 0;
+        ++i;
+    }
+    if (negative)
+        *val = -*val;
+    return 1;
+}
+
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc)
+{
+#define LD_STAGE_EXC_MAPPING    0
+#define LD_STAGE_TAB_DEFINE     1
+#define LD_STAGE_TAB_START      2
+#define LD_STAGE_COLUMN_DEFINE  3
+#define LD_STAGE_CH_ROW         4
+
+    uint8_t loadingStage = LD_STAGE_EXC_MAPPING;
+    uint32_t i = 0, forCnt = 0;
+    uint32_t i_cc;
+    char *szLine, *ptmp;
+    char band[10], colNumBuf[10];
+    uint8_t colNum = 0, colNum_cc = 255, band_cc = 0;
+    bool sp_cc = false;
+    // clear powerlimit info at first
+    memset((void *)&powerlimit_info, 0, sizeof(powerlimit_info_t));
+    ptmp = buffer;
+    for (szLine = GetLineFromBuffer(ptmp); szLine != NULL; szLine = GetLineFromBuffer(ptmp)) {
+        if (isAllSpaceOrTab(szLine, sizeof(*szLine)))
+            continue;
+        if (IsCommentString(szLine))
+            continue;
+
+        if (loadingStage == LD_STAGE_EXC_MAPPING) {
+            if (szLine[0] == '#' || szLine[1] == '#') {
+                loadingStage = LD_STAGE_TAB_DEFINE;
+            } else {
+                continue;
+            }
+        }
+
+        if (loadingStage == LD_STAGE_TAB_DEFINE) {
+            /* read "##	2.4G" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            szLine[--i] = ' '; /* return the space in front of the regulation info */
+
+            /* Parse the label of the table */
+            memset((void *)band, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, band, ' ', ',')) {
+                AICWFDBG(LOGERROR, "Fail to parse band!\n");
+                goto exit;
+            }
+            if (strncmp(band, "2.4G", 4) == 0) {
+                band_cc = PHY_BAND_2G4;
+            } else if (strncmp(band, "5G", 2) == 0) {
+                band_cc = PHY_BAND_5G;
+            }
+            memset((void *) colNumBuf, 0, 10);
+            if (!ParseQualifiedString(szLine, &i, colNumBuf, '#', '#')) {
+                AICWFDBG(LOGERROR, "Fail to parse column number!\n");
+                goto exit;
+            }
+            if (!GetU1ByteIntegerFromStringInDecimal(colNumBuf, &colNum)) {
+                AICWFDBG(LOGERROR, "Column number \"%s\" is not unsigned decimal\n", colNumBuf);
+                goto exit;
+            }
+            if (colNum == 0) {
+                AICWFDBG(LOGERROR, "Column number is 0\n");
+                goto exit;
+            }
+
+            AICWFDBG(LOGINFO, "band=%s(%d)\n", band, band_cc);
+            loadingStage = LD_STAGE_TAB_START;
+        } else if (loadingStage == LD_STAGE_TAB_START) {
+            /* read "##	START" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            if (strncmp((u8 *)(szLine + i), "START", 5)) {
+                AICWFDBG(LOGERROR, "Missing \"##   START\" label\n");
+                goto exit;
+            }
+
+            loadingStage = LD_STAGE_COLUMN_DEFINE;
+        } else if (loadingStage == LD_STAGE_COLUMN_DEFINE) {
+            /* read "##	CN	US" */
+            if (szLine[0] != '#' || szLine[1] != '#')
+                continue;
+
+            /* skip the space */
+            i = 2;
+            while (szLine[i] == ' ' || szLine[i] == '\t')
+                ++i;
+
+            for (forCnt = 0; forCnt < colNum; forCnt++) {
+                /* skip the space */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    i++;
+                i_cc = i;
+
+                while (szLine[i] != ' ' && szLine[i] != '\t' && szLine[i] != '\0')
+                    i++;
+
+                if ((i - i_cc) != 2) {
+                    AICWFDBG(LOGERROR, "CC len err\n");
+                    goto exit;
+                } else if ((szLine[i_cc] == cc[0]) && (szLine[i_cc + 1] == cc[1])) {
+                    AICWFDBG(LOGINFO, "CC matched: %s, col=%d\n", cc, forCnt);
+                    colNum_cc = forCnt;
+                    powerlimit_info.flags |= POWER_LIMIT_CC_MATCHED_BIT;
+                    sp_cc = true;
+                    break;
+                }
+            }
+
+            if (!sp_cc) {
+                colNum_cc = colNum - 1;
+                AICWFDBG(LOGDEBUG, "use 00: %s, colNum_cc=%d\n", cc, colNum_cc);
+                powerlimit_info.flags |= POWER_LIMIT_CC_MATCHED_BIT;
+            }
+
+            loadingStage = LD_STAGE_CH_ROW;
+        } else if (loadingStage == LD_STAGE_CH_ROW) {
+            char channel[10] = {0}, powerLimit[10] = {0};
+            u8 channel_num, powerLimit_val, cnt = 0;
+
+            /* the table ends */
+            if (szLine[0] == '#' && szLine[1] == '#') {
+                i = 2;
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                if (strncmp((u8 *)(szLine + i), "END", 3) == 0) {
+                    loadingStage = LD_STAGE_TAB_DEFINE;
+                    colNum = 0;
+                    continue;
+                } else {
+                    AICWFDBG(LOGERROR, "Missing \"##   END\" label\n");
+                    goto exit;
+                }
+            }
+
+            if ((szLine[0] != 'c' && szLine[0] != 'C') ||
+                (szLine[1] != 'h' && szLine[1] != 'H')
+            ) {
+                AICWFDBG(LOGERROR, "Wrong channel prefix: '%c','%c'(%d,%d)\n", szLine[0], szLine[1], szLine[0], szLine[1]);
+                continue;
+            }
+            i = 2;/* move to the  location behind 'h' */
+
+            /* load the channel number */
+            cnt = 0;
+            while (szLine[i] >= '0' && szLine[i] <= '9') {
+                channel[cnt] = szLine[i];
+                ++cnt;
+                ++i;
+            }
+
+            for (forCnt = 0; forCnt < colNum; ++forCnt) {
+                /* skip the space between channel number and the power limit value */
+                while (szLine[i] == ' ' || szLine[i] == '\t')
+                    ++i;
+
+                /* load the power limit value */
+                memset((void *)powerLimit, 0, 10);
+
+                if (szLine[i] == 'N' && szLine[i + 1] == 'A') {
+                    /*
+                    * means channel not available
+                    */
+                    sprintf(powerLimit, "%d", POWER_LIMIT_INVALID_VAL);
+                    i += 2;
+                } else if ((szLine[i] >= '0' && szLine[i] <= '9')
+                    || szLine[i] == '+' || szLine[i] == '-'
+                ) {
+                    /* case of dBm value */
+                    cnt = 0;
+                    while ((szLine[i] >= '0' && szLine[i] <= '9')
+                        || szLine[i] == '+' || szLine[i] == '-'
+                    ) {
+                        powerLimit[cnt] = szLine[i];
+                        ++cnt;
+                        ++i;
+                    }
+                } else {
+                    AICWFDBG(LOGERROR, "Wrong limit expression \"%c%c\"(%d, %d)\n"
+                        , szLine[i], szLine[i + 1], szLine[i], szLine[i + 1]);
+                    goto exit;
+                }
+
+                if (forCnt == colNum_cc) {
+                    /* store the power limit value */
+                    if (GetU1ByteIntegerFromStringInDecimal((char *)channel, &channel_num) == 0
+                        || GetS1ByteIntegerFromStringInDecimal((char *)powerLimit, &powerLimit_val) == 0
+                    ) {
+                        AICWFDBG(LOGERROR, "Illegal index of power limit table [ch %s][val %s]\n", channel, powerLimit);
+                        goto exit;
+                    }
+
+                    if (band_cc == PHY_BAND_2G4) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_24G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_2g4[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_2g4[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_2g4++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_24G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    } else if (band_cc == PHY_BAND_5G) {
+                        uint8_t cur_idx = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+                        AICWFDBG(LOGINFO, "[%d]: ch=%s, pwr=%s\n", cur_idx, channel, powerLimit);
+                        if (cur_idx < MAC_DOMAINCHANNEL_5G_MAX) {
+                            powerlimit_info.txpwr_lmt.ch_num_5g[cur_idx] = channel_num;
+                            powerlimit_info.txpwr_lmt.max_pwr_5g[cur_idx] = powerLimit_val;
+                            powerlimit_info.txpwr_lmt.ch_cnt_5g++;
+                        } else {
+                            AICWFDBG(LOGERROR, "band %d chan_cnt reached %d\n", band_cc, MAC_DOMAINCHANNEL_5G_MAX);
+                            AICWFDBG(LOGERROR, "channel=%s(%d) powerLimit=%s(%d)\n", channel, channel_num, powerLimit, powerLimit_val);
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+exit:
+    return;
+}
+
+/// 5G lower bound freq
+#define PHY_FREQ_5G 5000
+
+uint16_t phy_channel_to_freq(uint8_t band, int channel)
+{
+    if ((band == PHY_BAND_2G4) && (channel >= 1) && (channel <= 14)) {
+        if (channel == 14)
+            return 2484;
+        else
+            return 2407 + channel * 5;
+    } else if ((band == PHY_BAND_5G) && (channel >= 1) && (channel <= 165)) {
+        return PHY_FREQ_5G + channel * 5;
+    }
+    return 0;
+}
+
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (band == PHY_BAND_2G4) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_2G4, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        } else if (band == PHY_BAND_5G) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                uint16_t freq_tmp = phy_channel_to_freq(PHY_BAND_5G, ch_num);
+                if (freq == freq_tmp) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d(freq=%d), pwr=%d\n", idx, ch_num, freq, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: band=%d freq=%d\n", band, freq);
+            }
+        }
+    }
+    return ret;
+}
+
+int8_t get_powerlimit_by_chnum(uint8_t chnum)
+{
+    int8_t ret = POWER_LIMIT_INVALID_VAL;
+    uint8_t idx;
+    if (powerlimit_info.flags & POWER_LIMIT_CC_MATCHED_BIT) {
+        if (chnum <= 14) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_2g4;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                uint8_t ch_num = powerlimit_info.txpwr_lmt.ch_num_2g4[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_2g4[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        } else if (chnum <= 165) {
+            uint8_t idx_cnt = powerlimit_info.txpwr_lmt.ch_cnt_5g;
+            for (idx = 0; idx < idx_cnt; idx++) {
+                int ch_num = powerlimit_info.txpwr_lmt.ch_num_5g[idx];
+                if (chnum == ch_num) {
+                    ret = powerlimit_info.txpwr_lmt.max_pwr_5g[idx];
+                    //AICWFDBG(LOGINFO, "[%d]: ch=%d, pwr=%d\n", idx, ch_num, ret);
+                    break;
+                }
+            }
+            if (idx == idx_cnt) {
+                AICWFDBG(LOGERROR, "powerlimit search failed: chnum=%d\n", chnum);
+            }
+        }
+    }
+    return ret;
+}
+#endif
+
 /**
  * rwnx_plat_userconfig_load  ---Load aic_userconfig.txt
  *@filename name of config
@@ -1928,17 +2920,29 @@ static int rwnx_plat_userconfig_load(struct rwnx_hw *rwnx_hw) {
         rwnx_plat_userconfig_load_8800dw(rwnx_hw);
     }else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80){
 		rwnx_plat_userconfig_load_8800d80(rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+		rwnx_plat_powerlimit_load_8800d80(rwnx_hw);
+#endif
+	}else if(rwnx_hw->sdiodev->chipid == PRODUCT_ID_AIC8800D80X2){
+		rwnx_plat_userconfig_load_8800d80x2(rwnx_hw);
+#ifdef CONFIG_POWER_LIMIT
+		rwnx_plat_powerlimit_load_8800d80x2(rwnx_hw);
+#endif
 	}
 	return 0;
 }
 
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss)
 {
-    txpwr_loss->loss_enable      = userconfig_info.txpwr_loss.loss_enable;
-    txpwr_loss->loss_value       = userconfig_info.txpwr_loss.loss_value;
+	txpwr_loss->loss_enable_2g4 = userconfig_info.txpwr_loss.loss_enable_2g4;
+	txpwr_loss->loss_value_2g4 = userconfig_info.txpwr_loss.loss_value_2g4;
+	txpwr_loss->loss_enable_5g = userconfig_info.txpwr_loss.loss_enable_5g;
+	txpwr_loss->loss_value_5g = userconfig_info.txpwr_loss.loss_value_5g;
+
+	AICWFDBG(LOGDEBUG, "%s:loss_enable_2g4: %d, val_2g4: %d, loss_enable_5g: %d, val_5g: %d\r\n", __func__,
+				txpwr_loss->loss_enable_2g4, txpwr_loss->loss_value_2g4,
+				txpwr_loss->loss_enable_5g, txpwr_loss->loss_value_5g);
 
-    AICWFDBG(LOGINFO, "%s:loss_enable:%d\r\n",     __func__, txpwr_loss->loss_enable);
-    AICWFDBG(LOGINFO, "%s:loss_value:%d\r\n",      __func__, txpwr_loss->loss_value);
 }
 
 /**
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
index 79c91a07242c..93f9fbfcf870 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_platform.h
@@ -117,14 +117,24 @@ void rwnx_platform_unregister_drv(void);
 void get_userconfig_txpwr_idx(txpwr_idx_conf_t *txpwr_idx);
 void get_userconfig_txpwr_ofst(txpwr_ofst_conf_t *txpwr_ofst);
 void get_userconfig_xtal_cap(xtal_cap_conf_t *xtal_cap);
+s8_l get_txpwr_max(s8_l power);
+void set_txpwr_loss_ofst(s8_l value);
 
 void get_userconfig_txpwr_lvl_in_fdrv(txpwr_lvl_conf_t *txpwr_lvl);
 void get_userconfig_txpwr_lvl_v2_in_fdrv(txpwr_lvl_conf_v2_t *txpwr_lvl_v2);
 void get_userconfig_txpwr_lvl_v3_in_fdrv(txpwr_lvl_conf_v3_t *txpwr_lvl_v3);
+void get_userconfig_txpwr_lvl_v4_in_fdrv(txpwr_lvl_conf_v4_t *txpwr_lvl_v4);
 void get_userconfig_txpwr_lvl_adj_in_fdrv(txpwr_lvl_adj_conf_t *txpwr_lvl_adj);
 
+#ifdef CONFIG_POWER_LIMIT
+void rwnx_plat_powerlimit_parsing(char *buffer, int size, char *cc);
+int8_t get_powerlimit_by_freq(uint8_t band, uint16_t freq);
+int8_t get_powerlimit_by_chnum(uint8_t chnum);
+#endif
+
 void get_userconfig_txpwr_ofst_in_fdrv(txpwr_ofst_conf_t *txpwr_ofst);
 void get_userconfig_txpwr_ofst2x_in_fdrv(txpwr_ofst2x_conf_t *txpwr_ofst2x);
+void get_userconfig_txpwr_ofst2x_v2_in_fdrv(txpwr_ofst2x_conf_v2_t *txpwr_ofst2x_v2);
 void get_userconfig_txpwr_loss(txpwr_loss_conf_t *txpwr_loss);
 extern struct device *rwnx_platform_get_dev(struct rwnx_plat *rwnx_plat);
 
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
index c50f2d2b16cc..358e260c5fe2 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_radar.c
@@ -1344,9 +1344,10 @@ static void rwnx_radar_process_pulse(struct work_struct *ws)
 #ifdef CREATE_TRACE_POINTS
 			trace_radar_pulse(chain, p);
 #endif
-			if (dfs_pattern_detector_add_pulse(radar->dpd[chain], chain,
-											   (s16)freq + (2 * p->freq),
-											   p->rep, (p->len * 2), now)) {
+		if (dfs_pattern_detector_add_pulse(radar->dpd[chain], chain,
+								(s16)freq + p->freq, //(2 * p->freq),
+								p->rep, p->len/*(p->len * 2)*/, now)) {
+
 				u16 idx = radar->detected[chain].index;
 
 				if (chain == RWNX_RADAR_RIU) {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
index d740f146a8d1..7b42358c3b1c 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.c
@@ -47,44 +47,23 @@ u16 tx_legrates_lut_rate[] = {
 	540
 };
 
-
-u16 legrates_lut_rate[] = {
-	10,
-	20,
-	55,
-	110,
-	0,
-	0,
-	0,
-	0,
-	480,
-	240,
-	120,
-	60,
-	540,
-	360,
-	180,
-	90
-};
-
-
-const u8 legrates_lut[] = {
-	0,                          /* 0 */
-	1,                          /* 1 */
-	2,                          /* 2 */
-	3,                          /* 3 */
-	-1,                         /* 4 */
-	-1,                         /* 5 */
-	-1,                         /* 6 */
-	-1,                         /* 7 */
-	10,                         /* 8 */
-	8,                          /* 9 */
-	6,                          /* 10 */
-	4,                          /* 11 */
-	11,                         /* 12 */
-	9,                          /* 13 */
-	7,                          /* 14 */
-	5                           /* 15 */
+struct rwnx_legrate legrates_lut[] = {
+	[0] = { .idx = 0, .rate = 10},
+	[1] = { .idx = 1, .rate = 20},
+	[2] = { .idx = 2, .rate = 55},
+	[3] = { .idx = 3, .rate = 110},
+	[4] = { .idx = -1, .rate = 0},
+	[5] = { .idx = -1, .rate = 0},
+	[6] = { .idx = -1, .rate = 0},
+	[7] = { .idx = -1, .rate = 0},
+	[8] = { .idx = 10, .rate = 480},
+	[9] = { .idx = 8, .rate = 240},
+	[10] = { .idx = 6, .rate = 120},
+	[11] = { .idx = 4, .rate = 60},
+	[12] = { .idx = 11, .rate = 540},
+	[13] = { .idx = 9, .rate = 360},
+	[14] = { .idx = 7, .rate = 180},
+	[15] = { .idx = 5, .rate = 90},
 };
 
 struct vendor_radiotap_hdr {
@@ -283,7 +262,7 @@ static void rwnx_rx_statistic(struct rwnx_hw *rwnx_hw, struct hw_rxhdr *hw_rxhdr
 			break;
 		}
 	} else {
-		int idx = legrates_lut[rxvect->leg_rate];
+		int idx = legrates_lut[rxvect->leg_rate].idx;
 		if (idx < 4) {
 			rate_idx = idx * 2 + rxvect->pre_type;
 		} else {
@@ -1021,7 +1000,7 @@ static void rwnx_rx_add_rtap_hdr(struct rwnx_hw *rwnx_hw,
 		struct ieee80211_supported_band *band =
 				rwnx_hw->wiphy->bands[phy_info->phy_band];
 		rtap->it_present |= cpu_to_le32(1 << IEEE80211_RADIOTAP_RATE);
-		BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate]) == -1);
+		BUG_ON((rate_idx = legrates_lut[rxvect->leg_rate].idx) == -1);
 		if (phy_info->phy_band == NL80211_BAND_5GHZ)
 			rate_idx -= 4;  /* rwnx_ratetable_5ghz[0].hw_value == 4 */
 		*pos = DIV_ROUND_UP(band->bitrates[rate_idx].bitrate, 5);
@@ -1435,6 +1414,7 @@ int reord_flush_tid(struct aicwf_rx_priv *rx_priv, struct sk_buff *skb, u8 tid)
 	return 0;
 }
 
+
 void reord_deinit_sta(struct aicwf_rx_priv *rx_priv, struct reord_ctrl_info *reord_info)
 {
 	u8 i = 0;
@@ -1450,6 +1430,13 @@ void reord_deinit_sta(struct aicwf_rx_priv *rx_priv, struct reord_ctrl_info *reo
 	for (i = 0; i < 8; i++) {
 		struct recv_msdu *req, *next;
 		preorder_ctrl = &reord_info->preorder_ctrl[i];
+		if(preorder_ctrl->enable){
+			preorder_ctrl->enable = false;
+			if (timer_pending(&preorder_ctrl->reord_timer)) {
+				ret = del_timer_sync(&preorder_ctrl->reord_timer);
+			}
+			cancel_work_sync(&preorder_ctrl->reord_timer_work);
+		}
 		spin_lock_irqsave(&preorder_ctrl->reord_list_lock, flags);
 		list_for_each_entry_safe(req, next, &preorder_ctrl->reord_list, reord_pending_list) {
 			list_del_init(&req->reord_pending_list);
@@ -1459,12 +1446,11 @@ void reord_deinit_sta(struct aicwf_rx_priv *rx_priv, struct reord_ctrl_info *reo
 			reord_rxframe_free(&rx_priv->freeq_lock, &rx_priv->rxframes_freequeue, &req->rxframe_list);
 		}
 		spin_unlock_irqrestore(&preorder_ctrl->reord_list_lock, flags);
-		if (timer_pending(&preorder_ctrl->reord_timer)) {
-			ret = del_timer_sync(&preorder_ctrl->reord_timer);
-		}
-		cancel_work_sync(&preorder_ctrl->reord_timer_work);
+
 	}
+	spin_lock_bh(&rx_priv->stas_reord_lock);
 	list_del(&reord_info->list);
+	spin_unlock_bh(&rx_priv->stas_reord_lock);
 	kfree(reord_info);
 }
 
@@ -1547,7 +1533,7 @@ int reord_single_frame_ind(struct aicwf_rx_priv *rx_priv, struct recv_msdu *prfr
     	memset(rx_skb->cb, 0, sizeof(rx_skb->cb));
 
 #ifdef CONFIG_FILTER_TCP_ACK
-	filter_rx_tcp_ack(rwnx_vif->rwnx_hw,rx_skb->data, cpu_to_le16(skb->len));
+	filter_rx_tcp_ack(rwnx_vif->rwnx_hw,rx_skb->data, cpu_to_le16(rx_skb->len));
 #endif
 
 #ifdef CONFIG_RX_NETIF_RECV_SKB//AIDEN test
@@ -2008,11 +1994,13 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
 	const struct ethhdr *eth;
 
 	hw_rxhdr = (struct hw_rxhdr *)skb->data;
-
+    
+#ifdef AICWF_RX_REORDER
 	if (hw_rxhdr->is_monitor_vif) {
 		status = RX_STAT_MONITOR;
-		printk("monitor rx\n");
+		//printk("monitor rx\n");
 	}
+#endif
 
 	if (hw_rxhdr->flags_upload)
 		status |= RX_STAT_FORWARD;
@@ -2029,76 +2017,77 @@ u8 rwnx_rxdataind_aicwf(struct rwnx_hw *rwnx_hw, void *hostid, void *rx_priv)
 	}
 
 	/* Check if we need to forward the buffer coming from a monitor interface */
-	if (status & RX_STAT_MONITOR) {
-		struct sk_buff *skb_monitor;
-		struct hw_rxhdr hw_rxhdr_copy;
-		u8 rtap_len;
-		u16 frm_len;
-
-		//Check if monitor interface exists and is open
-		rwnx_vif = rwnx_rx_get_vif(rwnx_hw, rwnx_hw->monitor_vif);
-		if (!rwnx_vif) {
-			dev_err(rwnx_hw->dev, "Received monitor frame but there is no monitor interface open\n");
-			goto check_len_update;
-		}
+    if (status & RX_STAT_MONITOR) {
+        struct sk_buff *skb_monitor = NULL;
+        struct hw_rxhdr hw_rxhdr_copy;
+        u8 rtap_len;
+        u16 frm_len = 0;
+
+        //Check if monitor interface exists and is open
+        rwnx_vif = rwnx_rx_get_vif(rwnx_hw, rwnx_hw->monitor_vif);
+        if (!rwnx_vif) {
+            dev_err(rwnx_hw->dev, "Received monitor frame but there is no monitor interface open\n");
+            goto check_len_update;
+        }
 
-		rwnx_rx_vector_convert(rwnx_hw,
-							   &hw_rxhdr->hwvect.rx_vect1,
-							   &hw_rxhdr->hwvect.rx_vect2);
-		rtap_len = rwnx_rx_rtap_hdrlen(&hw_rxhdr->hwvect.rx_vect1, false);
+        rwnx_rx_vector_convert(rwnx_hw,
+                               &hw_rxhdr->hwvect.rx_vect1,
+                               &hw_rxhdr->hwvect.rx_vect2);
+        rtap_len = rwnx_rx_rtap_hdrlen(&hw_rxhdr->hwvect.rx_vect1, false);
 
-		// Move skb->data pointer to MAC Header or Ethernet header
-		skb->data += (msdu_offset + 2); //sdio/usb word allign
+        if (status == RX_STAT_MONITOR) 
+        {
+            /* Remove the SK buffer from the rxbuf_elems table. It will also
+               unmap the buffer and then sync the buffer for the cpu */
+            //rwnx_ipc_rxbuf_elem_pull(rwnx_hw, skb);
+            skb->data += (msdu_offset + 2); //sdio/usb word allign
 
-		//Save frame length
-		frm_len = le32_to_cpu(hw_rxhdr->hwvect.len);
+            //Save frame length
+            frm_len = le32_to_cpu(hw_rxhdr->hwvect.len);
 
-		// Reserve space for frame
-		skb->len = frm_len;
+            // Reserve space for frame
+            skb->len = frm_len;
 
-		if (status == RX_STAT_MONITOR) {
-			/* Remove the SK buffer from the rxbuf_elems table. It will also
-			   unmap the buffer and then sync the buffer for the cpu */
-			//rwnx_ipc_rxbuf_elem_pull(rwnx_hw, skb);
+            //Check if there is enough space to add the radiotap header
+            if (skb_headroom(skb) > rtap_len) {
 
-			//Check if there is enough space to add the radiotap header
-			if (skb_headroom(skb) > rtap_len) {
-				skb_monitor = skb;
+                skb_monitor = skb;
 
-				//Duplicate the HW Rx Header to override with the radiotap header
-				memcpy(&hw_rxhdr_copy, hw_rxhdr, sizeof(hw_rxhdr_copy));
+                //Duplicate the HW Rx Header to override with the radiotap header
+                memcpy(&hw_rxhdr_copy, hw_rxhdr, sizeof(hw_rxhdr_copy));
 
-				hw_rxhdr = &hw_rxhdr_copy;
-			} else {
-				//Duplicate the skb and extend the headroom
-				skb_monitor = skb_copy_expand(skb, rtap_len, 0, GFP_ATOMIC);
+                hw_rxhdr = &hw_rxhdr_copy;
+            } else {
+                //Duplicate the skb and extend the headroom
+                skb_monitor = skb_copy_expand(skb, rtap_len, 0, GFP_ATOMIC);
 
-				//Reset original skb->data pointer
-				skb->data = (void *)hw_rxhdr;
-			}
-		} else {
-			skb->data = (void *)hw_rxhdr;
+                //Reset original skb->data pointer
+                skb->data = (void*) hw_rxhdr;
+            }
+        } else {
+    #ifdef CONFIG_RWNX_MON_DATA
+        skb_monitor = skb_copy_expand(skb, rtap_len, 0, GFP_ATOMIC);
+        skb_monitor->data += (msdu_offset + 2); //sdio/usb word allign
 
-			wiphy_err(rwnx_hw->wiphy, "RX status %d is invalid when MON_DATA is disabled\n", status);
-			goto check_len_update;
-		}
+        //Save frame length
+        frm_len = le32_to_cpu(hw_rxhdr->hwvect.len);
+    #endif
+        }
 
-		skb_reset_tail_pointer(skb);
-		skb->len = 0;
-		skb_reset_tail_pointer(skb_monitor);
-		skb_monitor->len = 0;
+        skb_reset_tail_pointer(skb_monitor);
+        skb_monitor->len = 0;
+        skb_put(skb_monitor, frm_len);
 
-		skb_put(skb_monitor, frm_len);
-		if (rwnx_rx_monitor(rwnx_hw, rwnx_vif, skb_monitor, hw_rxhdr, rtap_len))
-			dev_kfree_skb(skb_monitor);
+        if (rwnx_rx_monitor(rwnx_hw, rwnx_vif, skb_monitor, hw_rxhdr, rtap_len))
+            dev_kfree_skb(skb_monitor);
+
+        if (status == RX_STAT_MONITOR) {
+            if (skb_monitor != skb) {
+                dev_kfree_skb(skb);
+            }
+        }
+    }
 
-		if (status == RX_STAT_MONITOR) {
-			status |= RX_STAT_ALLOC;
-			if (skb_monitor != skb) {
-				dev_kfree_skb(skb);
-			}
-		}
-	}
 
 check_len_update:
 	/* Check if we need to update the length */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
index 36635350314b..b831bc8e4012 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_rx.h
@@ -319,8 +319,12 @@ struct hw_rxhdr {
 	u32    pattern;
 };
 
-extern const u8 legrates_lut[];
-extern u16 legrates_lut_rate[];
+struct rwnx_legrate {
+	int idx;
+	int rate;
+};
+
+extern struct rwnx_legrate legrates_lut[];
 extern u16 tx_legrates_lut_rate[];
 
 struct DHCPInfo {
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
index c15f3be6cda9..3f36531c38c9 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.c
@@ -18,6 +18,9 @@
 #include "rwnx_events.h"
 #include "rwnx_compat.h"
 #include "aicwf_txrxif.h"
+#ifdef CONFIG_RWNX_MON_XMIT
+#include <net/ieee80211_radiotap.h>
+#endif
 
 /******************************************************************************
  * Power Save functions
@@ -218,8 +221,12 @@ void rwnx_ps_bh_traffic_req(struct rwnx_hw *rwnx_hw, struct rwnx_sta *sta,
 	} else {
 		int i, tid;
 
-		foreach_sta_txq_prio(sta, txq, tid, i, rwnx_hw) {
-			u16 txq_len = skb_queue_len(&txq->sk_list);
+		//foreach_sta_txq_prio(sta, txq, tid, i, rwnx_hw) {
+		for (i = 0; i < NX_NB_TID_PER_STA; i++) {
+			u16 txq_len;
+			tid = nx_tid_prio[i];
+			txq = rwnx_txq_sta_get(sta, tid, rwnx_hw);
+			txq_len = skb_queue_len(&txq->sk_list);
 
 			if (txq->ps_id != ps_id)
 				continue;
@@ -641,10 +648,25 @@ void rwnx_tx_push(struct rwnx_hw *rwnx_hw, struct rwnx_txhdr *txhdr, int flags)
 		sw_txhdr->need_cfm = 1;
 		sw_txhdr->desc.host.hostid = ((1<<31) | rwnx_hw->sdio_env.txdesc_free_idx[0]);
 		aicwf_sdio_host_txdesc_push(&(rwnx_hw->sdio_env), 0, (long)skb);
-		AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p\n", sw_txhdr->desc.host.ethertype, rwnx_hw->sdio_env.txdesc_free_idx[0], skb);
+		if((sw_txhdr->desc.host.flags & TXU_CNTRL_MGMT))
+			AICWFDBG(LOGINFO, "need cfm mgmt:%x,user_idx=%d, skb=%p\n", *(skb->data+sw_txhdr->headroom), rwnx_hw->sdio_env.txdesc_free_idx[0], skb);
+		else
+			AICWFDBG(LOGINFO, "need cfm ethertype:%8x,user_idx=%d, skb=%p\n", sw_txhdr->desc.host.ethertype, rwnx_hw->sdio_env.txdesc_free_idx[0], skb);
 	} else {
 		sw_txhdr->need_cfm = 0;
 		sw_txhdr->desc.host.hostid = 0;
+        if (sw_txhdr->raw_frame) {
+            sw_txhdr->desc.host.flags |= TXU_CNTRL_MGMT;
+            AICWFDBG(LOGDEBUG, "%s TXU_CNTRL_MGMT sw_txhdr->desc.host.flags:%x\r\n", __func__,
+                sw_txhdr->desc.host.flags);
+        }
+        if (sw_txhdr->fixed_rate) {
+            sw_txhdr->desc.host.hostid = (0x01UL << 30) | sw_txhdr->rate_config;
+            AICWFDBG(LOGDEBUG, "%s TXU_CNTRL_MGMT hostid:%x\r\n", __func__,
+                sw_txhdr->desc.host.hostid);
+        } else {
+            sw_txhdr->desc.host.hostid = 0;
+        }
 
 		sw_txhdr->rwnx_vif->net_stats.tx_packets++;
 		sw_txhdr->rwnx_vif->net_stats.tx_bytes += sw_txhdr->frame_len;
@@ -1292,6 +1314,9 @@ int intf_tx(struct rwnx_hw *priv,struct msg_buf *msg)
 	sw_txhdr->amsdu.len = 0;
 	sw_txhdr->amsdu.nb = 0;
 #endif
+	sw_txhdr->raw_frame = 0;
+	sw_txhdr->fixed_rate = 0;
+
 	// Fill-in the descriptor
 	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
 	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
@@ -1395,7 +1420,7 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	struct ethhdr eth_t;
 #ifdef CONFIG_FILTER_TCP_ACK
-	struct msg_buf *msgbuf;
+	struct msg_buf *msgbuf = NULL;
 #endif
 
 #ifdef CONFIG_ONE_TXQ
@@ -1422,6 +1447,7 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		skb->priority = 0;
 
 #ifdef CONFIG_FILTER_TCP_ACK
+	if(cpu_to_le16(skb->len) <= MAX_TCP_ACK){
 		msgbuf=intf_tcp_alloc_msg(msgbuf);
 		msgbuf->rwnx_vif=rwnx_vif;
 		msgbuf->skb=skb;
@@ -1431,6 +1457,7 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			move_tcpack_msg(rwnx_hw,msgbuf);
 			kfree(msgbuf);
 		}
+	}
 #endif
 
 	memcpy(&eth_t, skb->data, sizeof(struct ethhdr));
@@ -1502,6 +1529,9 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	sw_txhdr->amsdu.len = 0;
 	sw_txhdr->amsdu.nb = 0;
 #endif
+    sw_txhdr->raw_frame = 0;
+    sw_txhdr->fixed_rate = 0;
+
 	// Fill-in the descriptor
 	memcpy(&desc->host.eth_dest_addr, eth_t.h_dest, ETH_ALEN);
 	memcpy(&desc->host.eth_src_addr, eth_t.h_source, ETH_ALEN);
@@ -1573,6 +1603,363 @@ netdev_tx_t rwnx_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
+#ifdef CONFIG_RWNX_MON_XMIT
+/**
+ * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb,
+ *                               struct net_device *dev);
+ *	Called when a packet needs to be transmitted.
+ *	Must return NETDEV_TX_OK , NETDEV_TX_BUSY.
+ *        (can also return NETDEV_TX_LOCKED if NETIF_F_LLTX)
+ *
+ *  - Initialize the desciptor for this pkt (stored in skb before data)
+ *  - Push the pkt in the corresponding Txq
+ *  - If possible (i.e. credit available and not in PS) the pkt is pushed
+ *    to fw
+ */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0))
+#define IEEE80211_RADIOTAP_MCS_HAVE_STBC	0x20
+#define IEEE80211_RADIOTAP_MCS_STBC_MASK	0x60
+#define IEEE80211_RADIOTAP_MCS_STBC_SHIFT	5
+#endif
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+#define IEEE80211_RADIOTAP_CODING_LDPC_USER0			0x01
+#endif
+
+char bcast[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+netdev_tx_t rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    int rtap_len, ret, idx;
+    struct ieee80211_radiotap_header *rtap_hdr; // net/ieee80211_radiotap.h
+    struct ieee80211_radiotap_iterator iterator; // net/cfg80211.h
+    u8_l *rtap_buf = (u8_l *)skb->data;
+    u8_l rate;
+
+    struct rwnx_vif *vif = netdev_priv(dev);
+    struct rwnx_hw *rwnx_hw = vif->rwnx_hw;
+    struct rwnx_txhdr *txhdr;
+    struct rwnx_sw_txhdr *sw_txhdr;
+    struct txdesc_api *desc;
+    struct rwnx_sta *sta;
+    struct rwnx_txq *txq;
+    u16_l frame_len, headroom, frame_oft;
+    u8_l tid, rate_fmt = FORMATMOD_NON_HT, rate_idx = 0, txsig_bw = PHY_CHNL_BW_20;
+    u8_l *pframe, *data;
+    bool robust;
+    struct sk_buff *skb_mgmt;
+    bool offchan = false;
+    int nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX;
+
+    rtap_hdr = (struct ieee80211_radiotap_header*)(rtap_buf);
+    rtap_len = ieee80211_get_radiotap_len(rtap_buf);//max_length
+    frame_len = skb->len;
+
+    AICWFDBG(LOGINFO, "rwnx_start_monitor_if_xmit, skb_len=%d, rtap_len=%d\n", skb->len, rtap_len);
+//rwnx_data_dump((char*)__func__, skb->data, skb->len);
+    if((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8801) ||
+        ((g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DC ||
+        g_rwnx_plat->sdiodev->chipid == PRODUCT_ID_AIC8800DW) && chip_id < 3)){
+            nx_off_chan_txq_idx = NX_OFF_CHAN_TXQ_IDX_FOR_OLD_IC;
+    }
+
+
+    if (unlikely(rtap_hdr->it_version)){
+        AICWFDBG(LOGERROR, "%s itv \r\n", __func__);
+        goto free_tag;
+        }
+
+    if (unlikely(skb->len < rtap_len)){
+        AICWFDBG(LOGERROR, "%s skb->len < rtap_len \r\n", __func__);
+        goto free_tag;
+        }
+
+    if (unlikely(rtap_len < sizeof(struct ieee80211_radiotap_header))){
+        AICWFDBG(LOGERROR, "%s rtap_len < sizeof(struct ieee80211_radiotap_header) \r\n", __func__);
+        goto free_tag;
+        }
+
+    frame_len -= rtap_len;
+    pframe = rtap_buf + rtap_len;
+
+    // Parse radiotap for injection items and overwrite attribs as needed
+    ret = ieee80211_radiotap_iterator_init(&iterator, rtap_hdr, rtap_len, NULL);
+    while (!ret) {
+        ret = ieee80211_radiotap_iterator_next(&iterator);
+        if (ret) {
+            continue;
+        }
+        AICWFDBG(LOGDEBUG, "%s iterator.this_arg_index:%d iterator.this_arg:%x\r\n", __func__, 
+            iterator.this_arg_index, *iterator.this_arg);
+        switch (iterator.this_arg_index) {
+            case IEEE80211_RADIOTAP_RATE:
+                // This is basic 802.11b/g rate; use MCS/VHT for higher rates
+                rate = *iterator.this_arg;
+                AICWFDBG(LOGDEBUG, "rate=0x%x\n", rate);
+                for (idx = 0; idx < HW_RATE_MAX; idx++) {
+                    if ((rate * 5) == tx_legrates_lut_rate[idx]) {
+                        AICWFDBG(LOGDEBUG, "%s datarate:%d \r\n", __func__, tx_legrates_lut_rate[idx]);
+                        break;
+                    }
+                }
+                
+                if (idx < HW_RATE_MAX) {
+                    rate_idx = idx;
+                    AICWFDBG(LOGDEBUG, "rate_idx = %d \r\n", rate_idx);
+                } else {
+                    AICWFDBG(LOGERROR, "invalid radiotap rate: %d\n", rate);
+                }
+                break;
+
+            case IEEE80211_RADIOTAP_TX_FLAGS: {
+                u16_l txflags = get_unaligned_le16(iterator.this_arg);
+                AICWFDBG(LOGDEBUG, "txflags=0x%x\n", txflags);
+                if ((txflags & IEEE80211_RADIOTAP_F_TX_NOACK) == 0) {
+                    AICWFDBG(LOGDEBUG, "  TX_NOACK\n");
+                }
+                if (txflags & 0x0010) { // Use preconfigured seq num
+                    // NOTE: this is currently ignored due to qos_en=_FALSE and HW seq num override
+                    AICWFDBG(LOGDEBUG, "  GetSequence\n");
+                }
+            }
+            break;
+
+            case IEEE80211_RADIOTAP_MCS: {
+                u8_l mcs_have = iterator.this_arg[0];
+                AICWFDBG(LOGDEBUG, "mcs_have=0x%x\n", mcs_have);
+                rate_fmt = FORMATMOD_HT_MF;
+                if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_BW) {
+                    u8_l bw = (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_BW_MASK);
+                    u8_l ch_offset = 0;
+                    if (bw == IEEE80211_RADIOTAP_MCS_BW_40) {
+                        txsig_bw = PHY_CHNL_BW_40;
+                    } else if (bw == IEEE80211_RADIOTAP_MCS_BW_20L) {
+                        bw = IEEE80211_RADIOTAP_MCS_BW_20;
+                        ch_offset = 1; // CHNL_OFFSET_LOWER;
+                    } else if (bw == IEEE80211_RADIOTAP_MCS_BW_20U) {
+                        bw = IEEE80211_RADIOTAP_MCS_BW_20;
+                        ch_offset = 2; // CHNL_OFFSET_UPPER;
+                    }
+                    AICWFDBG(LOGDEBUG, "  bw=%d, ch_offset=%d\n", bw, ch_offset);
+                }
+                if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_MCS) {
+                    u8_l fixed_rate = iterator.this_arg[2] & 0x7f;
+                    if (fixed_rate > 31) {
+                        fixed_rate = 0;
+                    }
+                    rate_idx = fixed_rate;
+                    AICWFDBG(LOGDEBUG, "  fixed_rate=0x%x\n", fixed_rate);
+                }
+                if ((mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_GI) && (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_SGI)) {
+                    AICWFDBG(LOGDEBUG, "  sgi\n");
+                }
+                if ((mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_FEC) && (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_FEC_LDPC)) {
+                    AICWFDBG(LOGDEBUG, "  ldpc\n");
+                }
+                if (mcs_have & IEEE80211_RADIOTAP_MCS_HAVE_STBC) {
+                    u8 stbc = (iterator.this_arg[1] & IEEE80211_RADIOTAP_MCS_STBC_MASK) >> IEEE80211_RADIOTAP_MCS_STBC_SHIFT;
+                    AICWFDBG(LOGDEBUG, "  stbc=0x%x\n", stbc);
+                }
+            }
+            break;
+
+            case IEEE80211_RADIOTAP_VHT: {
+                unsigned int mcs, nss;
+                u8 known = iterator.this_arg[0];
+                u8 flags = iterator.this_arg[2];
+                rate_fmt = FORMATMOD_VHT;
+                AICWFDBG(LOGDEBUG, "known=0x%x, flags=0x%x\n", known, flags);
+                // NOTE: this code currently only supports 1SS for radiotap defined rates
+                if ((known & IEEE80211_RADIOTAP_VHT_KNOWN_STBC) && (flags & IEEE80211_RADIOTAP_VHT_FLAG_STBC)) {
+                    AICWFDBG(LOGDEBUG, "  stbc\n");
+                }
+                if ((known & IEEE80211_RADIOTAP_VHT_KNOWN_GI) && (flags & IEEE80211_RADIOTAP_VHT_FLAG_SGI)) {
+                    AICWFDBG(LOGDEBUG, "  sgi\n");
+                }
+                if (known & IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH) {
+                    u8_l bw = iterator.this_arg[3] & 0x1F;
+                    AICWFDBG(LOGDEBUG, "  bw=0x%x\n",bw);
+                    // NOTE: there are various L and U, but we just use straight 20/40/80
+                    // since it's not clear how to set CHNL_OFFSET_LOWER/_UPPER with different
+                    // sideband sizes/configurations.  TODO.
+                    // Also, any 160 is treated as 80 due to lack of WIDTH_160.
+                    txsig_bw = PHY_CHNL_BW_40;
+                    if (bw == 0) {
+                        txsig_bw = PHY_CHNL_BW_20;
+                        AICWFDBG(LOGDEBUG, "  20M\n");
+                    } else if (bw >=1 && bw <= 3) {
+                        AICWFDBG(LOGDEBUG, "  40M\n");
+                    } else if (bw >=4 && bw <= 10) {
+                        AICWFDBG(LOGDEBUG, "  80M\n");
+                    } else if (bw >= 11 && bw <= 25) {
+                        AICWFDBG(LOGDEBUG, "  160M\n");
+                    }
+                }
+                // User 0
+                nss = iterator.this_arg[4] & 0x0F; // Number of spatial streams
+                AICWFDBG(LOGDEBUG, "  nss=0x%x\n", nss);
+                if (nss > 0) {
+                    if (nss > 4) nss = 4;
+                    mcs = (iterator.this_arg[4]>>4) & 0x0F; // MCS rate index
+                    if (mcs > 8) mcs = 9;
+                    rate_idx = mcs;
+                    AICWFDBG(LOGDEBUG, "    mcs=0x%x\n", mcs);
+                    if (iterator.this_arg[8] & IEEE80211_RADIOTAP_CODING_LDPC_USER0) {
+                        AICWFDBG(LOGDEBUG, "    ldpc\n");
+                    }
+                }
+            }
+            break;
+
+            case IEEE80211_RADIOTAP_HE: {
+                u16 data1 = ((u16)iterator.this_arg[1] << 8) | iterator.this_arg[0];
+                u16 data2 = ((u16)iterator.this_arg[3] << 8) | iterator.this_arg[2];
+                u16 data3 = ((u16)iterator.this_arg[5] << 8) | iterator.this_arg[4];
+                u16 data5 = ((u16)iterator.this_arg[9] << 8) | iterator.this_arg[8];
+                u8 fmt_he = data1 & IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MASK;
+                if (fmt_he == IEEE80211_RADIOTAP_HE_DATA1_FORMAT_MU) {
+                    rate_fmt = FORMATMOD_HE_MU;
+                } else if (fmt_he == IEEE80211_RADIOTAP_HE_DATA1_FORMAT_EXT_SU) {
+                    rate_fmt = FORMATMOD_HE_ER;
+                } else {
+                    rate_fmt = FORMATMOD_HE_SU;
+                }
+                if (data1 & IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN) {
+                    u8 mcs = (data3 & IEEE80211_RADIOTAP_HE_DATA3_DATA_MCS) >> 8;
+                    if (mcs > 11) mcs = 11;
+                    rate_idx = mcs;
+                }
+                if (data1 & IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN) {
+                    u8 bw = data5 & IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC;
+                    txsig_bw = (bw == IEEE80211_RADIOTAP_HE_DATA5_DATA_BW_RU_ALLOC_20MHZ) ? PHY_CHNL_BW_20 : PHY_CHNL_BW_40;
+                }
+                if (data2 & IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN) {
+                    u8 gi = (data5 & IEEE80211_RADIOTAP_HE_DATA5_GI) >> 4;
+                    AICWFDBG(LOGDEBUG, "  gi: %d\n", gi);
+                }
+            }
+            break;
+
+            default:
+                AICWFDBG(LOGERROR, "unparsed arg: 0x%x\n",iterator.this_arg_index);
+                break;
+        }
+    }
+
+    #if 0
+    // dump buffer
+    tmp_len = 128;
+    if (skb->len < 128) {
+        tmp_len = skb->len;
+    }
+    for (idx = 0; idx < tmp_len; idx+=16) {
+        printk("[%04X] %02X %02X %02X %02X %02X %02X %02X %02X   %02X %02X %02X %02X %02X %02X %02X %02X\n", idx,
+            rtap_buf[idx+0],rtap_buf[idx+1],rtap_buf[idx+2],rtap_buf[idx+3],
+            rtap_buf[idx+4],rtap_buf[idx+5],rtap_buf[idx+6],rtap_buf[idx+7],
+            rtap_buf[idx+8],rtap_buf[idx+9],rtap_buf[idx+10],rtap_buf[idx+11],
+            rtap_buf[idx+12],rtap_buf[idx+13],rtap_buf[idx+14],rtap_buf[idx+15]);
+    }
+    #endif
+    //rwnx_data_dump((char*)__func__, pframe, frame_len);
+
+    /* Get the STA id and TID information */
+    sta = rwnx_get_tx_priv(vif, skb, &tid);
+    //if (!sta) {
+    //    printk("sta=null, tid=0x%x\n", tid);
+    //}
+    /* Set TID and Queues indexes */
+    if (sta) {
+        txq = rwnx_txq_sta_get(sta, 8, rwnx_hw);
+    } else {
+        if (offchan)
+            txq = &rwnx_hw->txq[nx_off_chan_txq_idx];
+        else
+            txq = rwnx_txq_vif_get(vif, NX_UNK_TXQ_TYPE);
+    }
+    if (txq->idx == TXQ_INACTIVE) {
+        AICWFDBG(LOGERROR, "TXQ_INACTIVE\n");
+        goto free_tag;
+    }
+    // prepare to xmit
+    headroom = sizeof(struct rwnx_txhdr);
+    skb_mgmt = dev_alloc_skb(headroom + frame_len);
+    if (!skb_mgmt) {
+        AICWFDBG(LOGERROR, "skb_mgmt alloc fail\n");
+        goto free_tag;
+    }
+    skb_reserve(skb_mgmt, headroom);
+    data = skb_put(skb_mgmt, frame_len);
+    /* Copy the provided data */
+    memcpy(data, pframe, frame_len);
+    robust = ieee80211_is_robust_mgmt_frame(
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+		(void*)skb_mgmt
+#else
+		skb_mgmt
+#endif
+		);
+    skb_push(skb_mgmt, headroom);
+    /* Fill the TX Header */
+    txhdr = (struct rwnx_txhdr *)skb_mgmt->data;
+    txhdr->hw_hdr.cfm.status.value = 0;
+    /* Fill the SW TX Header */
+    sw_txhdr = kmem_cache_alloc(rwnx_hw->sw_txhdr_cache, GFP_ATOMIC);
+    if (unlikely(sw_txhdr == NULL)) {
+        dev_kfree_skb(skb_mgmt);
+        AICWFDBG(LOGERROR, "sw_txhdr alloc fail\n");
+        goto free_tag;
+    }
+    txhdr->sw_hdr = sw_txhdr;
+    sw_txhdr->txq = txq;
+    sw_txhdr->frame_len = frame_len;
+    sw_txhdr->rwnx_sta = sta;
+    sw_txhdr->rwnx_vif = vif;
+    sw_txhdr->skb = skb_mgmt;
+    sw_txhdr->headroom = headroom;
+    sw_txhdr->map_len = skb_mgmt->len - offsetof(struct rwnx_txhdr, hw_hdr);
+    sw_txhdr->raw_frame = 1;
+    sw_txhdr->fixed_rate = 1;
+    sw_txhdr->rate_config = ((rate_fmt << FORMAT_MOD_TX_RCX_OFT) & FORMAT_MOD_TX_RCX_MASK) |
+                            ((txsig_bw << BW_TX_RCX_OFT) & BW_TX_RCX_MASK) |
+                            ((rate_idx << MCS_INDEX_TX_RCX_OFT) & MCS_INDEX_TX_RCX_MASK); // from radiotap
+    /* Fill the Descriptor to be provided to the MAC SW */
+    desc = &sw_txhdr->desc;
+    desc->host.staid = (sta) ? sta->sta_idx : 0xFF;
+    desc->host.vif_idx = vif->vif_index;
+    desc->host.tid = 0xFF;
+    desc->host.flags = TXU_CNTRL_MGMT;
+    if (robust) {
+        desc->host.flags |= TXU_CNTRL_MGMT_ROBUST;
+    }
+    frame_oft = sizeof(struct rwnx_txhdr) - offsetof(struct rwnx_txhdr, hw_hdr);
+	#if 0
+    #ifdef CONFIG_RWNX_SPLIT_TX_BUF
+    desc->host.packet_addr[0] = sw_txhdr->dma_addr + frame_oft;
+    desc->host.packet_len[0] = frame_len;
+    desc->host.packet_cnt = 1;
+    #else
+    desc->host.packet_addr = sw_txhdr->dma_addr + frame_oft;
+    desc->host.packet_len = frame_len;
+    #endif
+	#else
+	desc->host.packet_len = frame_len;
+	#endif
+
+    desc->host.hostid = sw_txhdr->dma_addr;
+    
+    memcpy(desc->host.eth_dest_addr.array, bcast, ETH_ALEN);
+    
+    spin_lock_bh(&rwnx_hw->tx_lock);
+    AICWFDBG(LOGTRACE, "%s send data\r\n", __func__);
+    if (rwnx_txq_queue_skb(skb_mgmt, txq, rwnx_hw, false))
+        rwnx_hwq_process(rwnx_hw, txq->hwq);
+    spin_unlock_bh(&rwnx_hw->tx_lock);
+
+free_tag:
+    dev_kfree_skb_any(skb);
+    return NETDEV_TX_OK;
+}
+#endif
+
+
 /**
  * rwnx_start_mgmt_xmit - Transmit a management frame
  *
@@ -1730,6 +2117,9 @@ int rwnx_start_mgmt_xmit(struct rwnx_vif *vif, struct rwnx_sta *sta,
 	sw_txhdr->amsdu.len = 0;
 	sw_txhdr->amsdu.nb = 0;
 #endif
+    sw_txhdr->raw_frame = 0;
+    sw_txhdr->fixed_rate = 0;
+
 	//----------------------------------------------------------------------
 
 	/* Fill the Descriptor to be provided to the MAC SW */
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
index a4036dc0c2b0..b7c863ff3284 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_tx.h
@@ -129,6 +129,10 @@ struct rwnx_sw_txhdr {
 	size_t map_len;
 	dma_addr_t dma_addr;
 	struct txdesc_api desc;
+
+    u8 raw_frame;
+    u8 fixed_rate;
+    u16 rate_config;
 };
 
 /**
@@ -163,6 +167,10 @@ int rwnx_start_mgmt_xmit(struct rwnx_vif *vif, struct rwnx_sta *sta,
 					#endif
 						 u64 *cookie);
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0) */
+
+#ifdef CONFIG_RWNX_MON_XMIT
+int rwnx_start_monitor_if_xmit(struct sk_buff *skb, struct net_device *dev);
+#endif
 int rwnx_txdatacfm(void *pthis, void *host_id);
 
 struct rwnx_hw;
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
index ed5429ee9420..df078d3c2487 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_version_gen.h
@@ -1,4 +1,4 @@
 #define RWNX_VERS_REV "241c091M (master)"
 #define RWNX_VERS_MOD "6.4.3.0"
 #define RWNX_VERS_BANNER "rwnx v6.4.3.0 - - 241c091M (master)"
-#define RELEASE_DATE "2024_0327_3561b08f"
+#define RELEASE_DATE "2024_1119_06da8476"
diff --git a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
index 69bcf3f5d784..1d1529627e5e 100644
--- a/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
+++ b/drivers/net/wireless/aic8800/aic8800_fdrv/rwnx_wakelock.c
@@ -82,5 +82,9 @@ void aicwf_wakeup_lock_deinit(struct rwnx_hw *rwnx_hw)
 	rwnx_wakeup_deinit(rwnx_hw->ws_rx);
 	rwnx_wakeup_deinit(rwnx_hw->ws_irqrx);
 	rwnx_wakeup_deinit(rwnx_hw->ws_pwrctrl);
+	rwnx_hw->ws_tx = NULL;
+	rwnx_hw->ws_rx = NULL;
+	rwnx_hw->ws_irqrx = NULL;
+	rwnx_hw->ws_pwrctrl = NULL;
 }
 
-- 
2.43.0

