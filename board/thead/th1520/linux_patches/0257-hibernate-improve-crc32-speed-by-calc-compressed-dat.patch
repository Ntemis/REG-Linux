From 385c83d6c1e72a452ebc55d7d72907154285fbd0 Mon Sep 17 00:00:00 2001
From: xianbing Zhu <xianbing.zhu@linux.alibaba.com>
Date: Sun, 1 Sep 2024 01:33:37 +0800
Subject: [PATCH 257/400] hibernate: improve crc32 speed by calc compressed
 data

This commit introduce crc32 calc data by compressed instead of
uncompressed data. This improve speed of hibernation resume data
about 10% :

------with this commmit-----
PM: hibernation: Read 788072 kbytes in 2.21 seconds (356.59 MB/s)

-----berfore this commit----
PM: hibernation: Read 786300 kbytes in 2.45 seconds (320.93 MB/s)

Before this the crc32 of data is uncompress origin data,which is
huge.
The risk of this change is we not checked the origin data, but
the compressed data is check ok can equal to uncompressed data
ok mostly. For the data become invalid mostly is from disk,
for example : human mistook erasing.

Signed-off-by: xianbing Zhu <xianbing.zhu@linux.alibaba.com>
Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
---
 kernel/power/snapshot.c | 4 ++--
 kernel/power/swap.c     | 5 ++---
 2 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c
index fbb4f53e07df..8a3256d05761 100644
--- a/kernel/power/snapshot.c
+++ b/kernel/power/snapshot.c
@@ -1036,7 +1036,7 @@ int hibernate_register_nosave_region(unsigned long start_pfn, unsigned long end_
 
 	if (start_pfn >= end_pfn)
 	{
-		pr_warn(": start_pfn should smaller than end_pfn\n", __func__);
+		pr_warn("register nosave region : start_pfn should smaller than end_pfn\n");
 		return -1;
 	}
 	region = kmalloc(sizeof(struct nosave_region),
@@ -1052,7 +1052,7 @@ int hibernate_register_nosave_region(unsigned long start_pfn, unsigned long end_
 	mutex_lock(&nosave_regions_list_lock);
 	list_add_tail(&region->list, &nosave_regions);
 	mutex_unlock(&nosave_regions_list_lock);
- Report:
+
 	pr_info("Registered nosave memory: [mem %#010llx-%#010llx]\n",
 		(unsigned long long) start_pfn << PAGE_SHIFT,
 		((unsigned long long) end_pfn << PAGE_SHIFT) - 1);
diff --git a/kernel/power/swap.c b/kernel/power/swap.c
index 37d91b19830d..c10cdd3c16d2 100644
--- a/kernel/power/swap.c
+++ b/kernel/power/swap.c
@@ -638,7 +638,6 @@ static int lzo_compress_threadfn(void *data)
 		                          d->wrk);
 		lzo_head = (struct hib_lzo_header *)d->cmp;
 		lzo_head->cmp_len	= d->cmp_len;
-		lzo_head->unc_crc32 = crc32_le(0,d->unc, d->unc_len);
 		atomic_set_release(&d->stop, 1);
 		wake_up(&d->done);
 	}
@@ -1089,7 +1088,7 @@ static int lzo_decompress_threadfn(void *data)
 		d->ret = lzo1x_decompress_safe(d->cmp + LZO_HEADER, d->cmp_len,
 		                               d->unc, &d->unc_len);
 
-		unc_crc32 = crc32_le(0,d->unc, d->unc_len);
+		unc_crc32 = crc32_le(0,d->cmp + LZO_HEADER, d->cmp_len);
 		if(unc_crc32 != get_header_crc32((struct hib_lzo_header *)&d->cmp) ) {
 			d->crc32_err++;
 		}
@@ -1131,7 +1130,6 @@ static int load_image_lzo(struct swap_map_handle *handle,
 	unsigned long read_pages = 0;
 	unsigned char **page = NULL;
 	struct dec_data *data = NULL;
-	volatile u32 crc32_result[LZO_THREADS];
 	int crc_err = 0;
 
 	hib_init_batch(&hb);
@@ -1254,6 +1252,7 @@ static int load_image_lzo(struct swap_map_handle *handle,
 			ret = hib_wait_io(&hb);
 			disk_total += ktime_sub(ktime_get(), disk_start);
 			disk_start = ktime_get();
+			pr_info(" asked %d wait disk io took %lldms\n",asked,ktime_to_ms(disk_total));
 			if (ret)
 				goto out_finish;
 			have += asked;
-- 
2.43.0

