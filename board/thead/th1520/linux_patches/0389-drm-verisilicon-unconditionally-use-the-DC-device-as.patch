From a1a9625b370f5c380abdf6107e96b12da2ee950b Mon Sep 17 00:00:00 2001
From: Icenowy Zheng <uwu@icenowy.me>
Date: Wed, 16 Jul 2025 16:00:24 +0800
Subject: [PATCH 389/400] drm/verisilicon: unconditionally use the DC device as
 dma_dev

As the display-subsystem is outside of the soc device tree node (where
the dma-noncoherent property is added), it's assumed to be coherent,
and lead to allocated memory being not properly mapped (still cached).

Unconditionally use the DC device (which is in the soc node) as dma_dev
to fix framebuffer mapping issue.

Signed-off-by: Icenowy Zheng <uwu@icenowy.me>
---
 drivers/gpu/drm/verisilicon/vs_dc.c  |  8 ++++----
 drivers/gpu/drm/verisilicon/vs_drv.c | 13 +++++++------
 drivers/gpu/drm/verisilicon/vs_drv.h |  4 ++--
 3 files changed, 13 insertions(+), 12 deletions(-)

diff --git a/drivers/gpu/drm/verisilicon/vs_dc.c b/drivers/gpu/drm/verisilicon/vs_dc.c
index 4f4892c423fb..57da64451bb4 100644
--- a/drivers/gpu/drm/verisilicon/vs_dc.c
+++ b/drivers/gpu/drm/verisilicon/vs_dc.c
@@ -1001,9 +1001,9 @@ static int dc_bind(struct device *dev, struct device *master, void *data)
 	}
 #endif
 
-	ret = vs_drm_iommu_attach_device(drm_dev, dev);
+	ret = vs_drm_dma_attach_device(drm_dev, dev);
 	if (ret < 0) {
-		dev_err(dev, "Failed to attached iommu device.\n");
+		dev_err(dev, "Failed to attached DMA device.\n");
 		goto err_clean_dc;
 	}
 
@@ -1100,7 +1100,7 @@ static int dc_bind(struct device *dev, struct device *master, void *data)
 	drm_for_each_crtc(drm_crtc, drm_dev)
 		vs_crtc_destroy(drm_crtc);
 err_detach_dev:
-	vs_drm_iommu_detach_device(drm_dev, dev);
+	vs_drm_dma_detach_device(drm_dev, dev);
 err_clean_dc:
 	dc_deinit(dev);
 	return ret;
@@ -1112,7 +1112,7 @@ static void dc_unbind(struct device *dev, struct device *master, void *data)
 
 	dc_deinit(dev);
 
-	vs_drm_iommu_detach_device(drm_dev, dev);
+	vs_drm_dma_detach_device(drm_dev, dev);
 }
 
 const struct component_ops dc_component_ops = {
diff --git a/drivers/gpu/drm/verisilicon/vs_drv.c b/drivers/gpu/drm/verisilicon/vs_drv.c
index 704e6e64cae7..fa498994ca72 100644
--- a/drivers/gpu/drm/verisilicon/vs_drv.c
+++ b/drivers/gpu/drm/verisilicon/vs_drv.c
@@ -363,12 +363,14 @@ static struct drm_driver vs_drm_driver = {
 	.minor          = DRV_MINOR,
 };
 
-int vs_drm_iommu_attach_device(struct drm_device *drm_dev,
+int vs_drm_dma_attach_device(struct drm_device *drm_dev,
 				struct device *dev)
 {
 	struct vs_drm_private *priv = drm_dev->dev_private;
 	int ret;
 
+	priv->dma_dev = dev;
+
 	if (!has_iommu)
 		return 0;
 
@@ -376,7 +378,6 @@ int vs_drm_iommu_attach_device(struct drm_device *drm_dev,
 		priv->domain = iommu_get_domain_for_dev(dev);
 		if (IS_ERR(priv->domain))
 			return PTR_ERR(priv->domain);
-		priv->dma_dev = dev;
 	}
 
 	ret = iommu_attach_device(priv->domain, dev);
@@ -388,18 +389,18 @@ int vs_drm_iommu_attach_device(struct drm_device *drm_dev,
 	return 0;
 }
 
-void vs_drm_iommu_detach_device(struct drm_device *drm_dev,
+void vs_drm_dma_detach_device(struct drm_device *drm_dev,
 				struct device *dev)
 {
 	struct vs_drm_private *priv = drm_dev->dev_private;
 
+	if (priv->dma_dev == dev)
+		priv->dma_dev = drm_dev->dev;
+
 	if (!has_iommu)
 		return;
 
 	iommu_detach_device(priv->domain, dev);
-
-	if (priv->dma_dev == dev)
-		priv->dma_dev = drm_dev->dev;
 }
 
 void vs_drm_update_pitch_alignment(struct drm_device *drm_dev,
diff --git a/drivers/gpu/drm/verisilicon/vs_drv.h b/drivers/gpu/drm/verisilicon/vs_drv.h
index 149603b75350..5ef29c41aba1 100644
--- a/drivers/gpu/drm/verisilicon/vs_drv.h
+++ b/drivers/gpu/drm/verisilicon/vs_drv.h
@@ -39,10 +39,10 @@ struct vs_drm_private {
 	unsigned int pitch_alignment;
 };
 
-int vs_drm_iommu_attach_device(struct drm_device *drm_dev,
+int vs_drm_dma_attach_device(struct drm_device *drm_dev,
 				struct device *dev);
 
-void vs_drm_iommu_detach_device(struct drm_device *drm_dev,
+void vs_drm_dma_detach_device(struct drm_device *drm_dev,
 				struct device *dev);
 
 void vs_drm_update_pitch_alignment(struct drm_device *drm_dev,
-- 
2.43.0

