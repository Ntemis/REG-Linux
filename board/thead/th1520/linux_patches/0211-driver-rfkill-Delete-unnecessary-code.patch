From 2ec794562a674cda43a283e54023d4397921f1f0 Mon Sep 17 00:00:00 2001
From: Han Gao <gaohan@iscas.ac.cn>
Date: Sun, 1 Sep 2024 00:47:57 +0800
Subject: [PATCH 211/400] driver : rfkill : Delete unnecessary code

Optimize code to remove unnecessary codes

Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
---
 include/linux/rfkill-bt.h   |   73 ---
 include/linux/rfkill-wlan.h |   94 ----
 net/rfkill/rfkill-bt.c      |  793 +++++----------------------
 net/rfkill/rfkill-wlan.c    | 1032 +++++------------------------------
 4 files changed, 271 insertions(+), 1721 deletions(-)
 delete mode 100755 include/linux/rfkill-bt.h
 delete mode 100644 include/linux/rfkill-wlan.h

diff --git a/include/linux/rfkill-bt.h b/include/linux/rfkill-bt.h
deleted file mode 100755
index c4174b156580..000000000000
--- a/include/linux/rfkill-bt.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (c) 2011, NVIDIA Corporation.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-
-#ifndef __RFKILL_GPIO_H
-#define __RFKILL_GPIO_H
-
-#include <linux/types.h>
-#include <linux/rfkill.h>
-#include <linux/clk.h>
-
-#define RFKILL_RK_GPIO_NAME_SIZE   64
-
-//struct rfkill_rk_iomux {
-//    char    *name;
-//    int     fgpio;
-//    int     fmux;
-//};
-
-struct rfkill_rk_gpio {
-    int     io;
-    char    name[RFKILL_RK_GPIO_NAME_SIZE];
-    int     enable; // disable = !enable
-    struct  pinctrl_state    *gpio_state;
-    struct  pinctrl_state    *default_state;
-};
-
-struct rfkill_rk_irq {
-    char                    name[RFKILL_RK_GPIO_NAME_SIZE];
-    struct rfkill_rk_gpio   gpio;
-    int                     irq;
-};
-
-/**
- * struct rfkill_rk_platform_data - platform data for rfkill gpio device.
- * for unused gpio's, the expected value is -1.
- * @name:               name for the gpio rf kill instance
- * @reset_gpio:         GPIO which is used for reseting rfkill switch
- * @shutdown_gpio:      GPIO which is used for shutdown of rfkill switch
- */
-
-struct rfkill_rk_platform_data {
-    char                    *name;
-    enum rfkill_type        type;
-    bool                    power_toggle;
-    struct pinctrl          *pinctrl;
-    struct rfkill_rk_gpio   poweron_gpio;
-    struct rfkill_rk_gpio   reset_gpio;
-    struct rfkill_rk_gpio   wake_gpio;      // Host wake or sleep BT
-    struct rfkill_rk_irq    wake_host_irq;  // BT wakeup host
-    struct rfkill_rk_gpio   rts_gpio;
-    struct clk              *ext_clk;
-};
-
-int rfkill_get_bt_power_state(int *power, bool *toggle);
-
-#endif /* __RFKILL_GPIO_H */
-
diff --git a/include/linux/rfkill-wlan.h b/include/linux/rfkill-wlan.h
deleted file mode 100644
index 883d0ae1a8bf..000000000000
--- a/include/linux/rfkill-wlan.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef __PLAT_BOARD_H
-#define __PLAT_BOARD_H
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/clk.h>
-
-struct rksdmmc_iomux {
-    char    *name;  //set the MACRO of gpio
-    int     fgpio;
-    int     fmux;
-};
-
-struct rksdmmc_gpio {
-    int     io;                             //set the address of gpio
-    char    name[64];   //
-    int     enable;  // disable = !enable   //set the default value,i.e,GPIO_HIGH or GPIO_LOW
-    struct rksdmmc_iomux  iomux;
-};
-
-struct rksdmmc_pmu {
-    bool power_ctrl_by_pmu;
-    char pmu_regulator[20];
-    int  enable;
-};
-
-struct rksdmmc_gpio_wifi_moudle {
-    int sdio_vol;    //sdio reference voltage
-    bool vref_ctrl_enble;
-    bool wifi_power_remain;
-    struct rksdmmc_pmu    mregulator;
-    struct rksdmmc_pmu    ioregulator;
-    struct rksdmmc_gpio   vbat_n;
-    struct rksdmmc_gpio   power_n;  //PMU_EN  
-    struct rksdmmc_gpio   reset_n;  //SYSRET_B, DAIRST 
-    struct rksdmmc_gpio   vddio;
-    struct rksdmmc_gpio   bgf_int_b;
-    struct rksdmmc_gpio   wifi_int_b;
-    struct rksdmmc_gpio   gps_sync;
-    struct rksdmmc_gpio   ANTSEL2;  //pin5--ANTSEL2  
-    struct rksdmmc_gpio   ANTSEL3;  //pin6--ANTSEL3 
-    struct rksdmmc_gpio   GPS_LAN;  //pin33--GPS_LAN
-    struct regmap *grf;
-	struct clk *ext_clk;
-};
-
-enum {
-    WIFI_RK901,
-    WIFI_RK903,
-    WIFI_AP6181,
-    WIFI_AP6210,
-    WIFI_AP6212,
-    WIFI_AP6234,
-    WIFI_AP6255,
-    WIFI_AP6256,
-    WIFI_AP6330,
-    WIFI_AP6335,
-    WIFI_AP6354,
-    WIFI_AP6441,
-    WIFI_AP6476,
-    WIFI_AP6493,
-    WIFI_AP6XXX_SERIES,
-    WIFI_RTL8188EU,
-    WIFI_RTL8192DU,
-    WIFI_RTL8723AS,
-    WIFI_RTL8723BS,
-    WIFI_RTL8723BS_VQ0,
-    WIFI_RTL8723CS,
-    WIFI_RTL8723DS,
-    WIFI_RTL8723BU,
-    WIFI_RTL8723AU,
-    WIFI_RTL8189ES,
-    WIFI_RTL8189FS,
-    WIFI_RTL8812AU,
-    WIFI_RTL_SERIES,
-    WIFI_ESP8089,
-    WIFI_MVL88W8977,
-    WIFI_SSV6051,
-    TYPE_MAX,
-};
-
-int rfkill_get_wifi_power_state(int *power, int *vref_ctrl_enable);
-void *rockchip_mem_prealloc(int section, unsigned long size);
-int rockchip_wifi_ref_voltage(int on);
-int rockchip_wifi_power(int on);
-int rockchip_wifi_set_carddetect(int val);
-int rockchip_wifi_get_oob_irq(void);
-int rockchip_wifi_get_oob_irq_flag(void);
-int rockchip_wifi_reset(int on);
-int rockchip_wifi_mac_addr(unsigned char *buf);
-void *rockchip_wifi_country_code(char *ccode);
-#endif
diff --git a/net/rfkill/rfkill-bt.c b/net/rfkill/rfkill-bt.c
index cf4fd79ded2e..9d0df1d45af5 100644
--- a/net/rfkill/rfkill-bt.c
+++ b/net/rfkill/rfkill-bt.c
@@ -1,40 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
+ * Copyright (C) 2021-2022 Alibaba Group Holding Limited.
+ * Copyright (C) 2021-2022 Jiandong Yu <yjd01941629@alibaba-inc.com>
  */
-/* Rock-chips rfkill driver for bluetooth
- *
-*/
 
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/module.h>
 #include <linux/rfkill.h>
-#include <linux/init.h>
-#include <linux/slab.h>
 #include <linux/delay.h>
-#include <linux/rfkill-bt.h>
-#include <linux/rfkill-wlan.h>
-#include <linux/interrupt.h>
-#include <asm/irq.h>
-#include <linux/suspend.h>
-#include <linux/proc_fs.h>
-#include <linux/uaccess.h>
-#include <linux/gpio.h>
-#include <linux/fs.h>
-#include <linux/errno.h>
 #include <dt-bindings/gpio/gpio.h>
-#include <uapi/linux/rfkill.h>
-#include <linux/pinctrl/consumer.h>
 #include "../../drivers/gpio/gpiolib-of.h"
 #ifdef CONFIG_OF
 #include <linux/of.h>
@@ -50,99 +22,36 @@
 
 #define LOG(x...)   printk(KERN_INFO "[BT_RFKILL]: "x)
 
-#define BT_WAKEUP_TIMEOUT           10000
-#define BT_IRQ_WAKELOCK_TIMEOUT     10*1000
-
-#define BT_BLOCKED     true
-#define BT_UNBLOCK     false
-#define BT_SLEEP       true
-#define BT_WAKEUP      false
-
-enum {
-    IOMUX_FNORMAL=0,
-    IOMUX_FGPIO,
-    IOMUX_FMUX,
+struct rfkill_bt_data {
+	struct rfkill_platform_data	*pdata;
+	struct platform_device      *pdev;
+	struct rfkill				*rfkill_dev;
 };
 
-enum of_gpio_flags {
-	OF_GPIO_ACTIVE_LOW = 0x1,
-	OF_GPIO_SINGLE_ENDED = 0x2,
-	OF_GPIO_OPEN_DRAIN = 0x4,
-	OF_GPIO_TRANSITORY = 0x8,
-	OF_GPIO_PULL_UP = 0x10,
-	OF_GPIO_PULL_DOWN = 0x20,
-	OF_GPIO_PULL_DISABLE = 0x40,
+#define NAME_SIZE   64
+struct ctrl_gpio {
+	int     io;
+	char    name[NAME_SIZE];
+	int     enable;
 };
 
-struct rfkill_rk_data {
-	struct rfkill_rk_platform_data	*pdata;
-    struct platform_device      *pdev;
-	struct rfkill				*rfkill_dev;
-    // struct wake_lock            bt_irq_wl;
-    struct delayed_work         bt_sleep_delay_work;
+struct rfkill_platform_data {
+	char                 *name;
+	enum rfkill_type     type;
+	struct ctrl_gpio   power_n;
 };
 
-static struct rfkill_rk_data *g_rfkill = NULL;
-
-static const char bt_name[] = 
-#if defined (CONFIG_BCM4330)
-    #if defined (CONFIG_BT_MODULE_NH660)
-        "nh660"
-    #else
-        "bcm4330"
-    #endif
-#elif defined (CONFIG_RK903)
-    #if defined(CONFIG_RKWIFI_26M)
-        "rk903_26M"
-    #else
-        "rk903"
-    #endif
-#elif defined(CONFIG_BCM4329)
-        "bcm4329"
-#elif defined(CONFIG_MV8787)
-        "mv8787"
-#elif defined(CONFIG_AP6210)
-    #if defined(CONFIG_RKWIFI_26M)
-        "ap6210"
-    #else
-        "ap6210_24M"
-    #endif
-#elif defined(CONFIG_AP6330)
-		"ap6330"
-#elif defined(CONFIG_AP6476)
-		"ap6476"
-#elif defined(CONFIG_AP6493)
-		"ap6493"
-#elif defined(CONFIG_AP6441)
-        "ap6441"
-#elif defined(CONFIG_AP6335)
-        "ap6335"
-#elif defined(CONFIG_GB86302I)
-        "gb86302i"
-#else
-        "bt_default"
-#endif
-;
+static struct rfkill_bt_data *g_rfkill = NULL;
 
-static irqreturn_t rfkill_rk_wake_host_irq(int irq, void *dev)
-{
-    // struct rfkill_rk_data *rfkill = dev;
-    // LOG("BT_WAKE_HOST IRQ fired\n");
-    
-    // DBG("BT IRQ wakeup, request %dms wakelock\n", BT_IRQ_WAKELOCK_TIMEOUT);
-
-    // wake_lock_timeout(&rfkill->bt_irq_wl, 
-    //                 msecs_to_jiffies(BT_IRQ_WAKELOCK_TIMEOUT));
-    
-	return IRQ_HANDLED;
-}
+static const char bt_name[] = "bt";
 
-static int rfkill_rk_setup_gpio(struct platform_device *pdev, struct rfkill_rk_gpio* gpio, 
-	const char* prefix, const char* name)
+static int rfkill_setup_gpio(struct platform_device *pdev, struct ctrl_gpio *gpio,
+							const char *prefix, const char *name)
 {
 	if (gpio_is_valid(gpio->io)) {
-        int ret=0;
-        sprintf(gpio->name, "%s_%s", prefix, name);
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
 		ret = devm_gpio_request(&pdev->dev, gpio->io, gpio->name);
 		if (ret) {
 			LOG("Failed to get %s gpio.\n", gpio->name);
@@ -150,644 +59,186 @@ static int rfkill_rk_setup_gpio(struct platform_device *pdev, struct rfkill_rk_g
 		}
 	}
 
-    return 0;
-}
-
-static int rfkill_rk_setup_wake_irq(struct rfkill_rk_data* rfkill)
-{
-    int ret=0;
-    struct rfkill_rk_irq* irq = &(rfkill->pdata->wake_host_irq);
-    
-    ret = rfkill_rk_setup_gpio(rfkill->pdev, &irq->gpio, rfkill->pdata->name, "wake_host");
-    if (ret) goto fail1;
-    if (gpio_is_valid(irq->gpio.io))
-    {
-        //ret = gpio_pull_updown(irq->gpio.io, (irq->gpio.enable==GPIO_ACTIVE_LOW)?GPIOPullUp:GPIOPullDown);
-        //if (ret) goto fail2;
-        LOG("Request irq for bt wakeup host\n");
-        irq->irq = gpio_to_irq(irq->gpio.io);
-        sprintf(irq->name, "%s_irq", irq->gpio.name);
-        ret = request_irq(irq->irq,
-                    rfkill_rk_wake_host_irq,
-                    (irq->gpio.enable==GPIO_ACTIVE_LOW)?IRQF_TRIGGER_FALLING:IRQF_TRIGGER_RISING,
-                    irq->name,
-                    rfkill);
-        if (ret) goto fail2;
-        LOG("** disable irq\n");
-        disable_irq(irq->irq);
-        ret = enable_irq_wake(irq->irq);
-        if (ret) goto fail3;
-    }
-
-    return ret;
-
-fail3:
-    free_irq(irq->gpio.io, rfkill);
-fail2:
-    gpio_free(irq->gpio.io);
-fail1:
-    return ret;
-}
-
-static inline void rfkill_rk_sleep_bt_internal(struct rfkill_rk_data *rfkill, bool sleep)
-{
-    struct rfkill_rk_gpio *wake = &rfkill->pdata->wake_gpio;
-    
-    DBG("*** bt sleep: %d ***\n", sleep);
-#ifndef CONFIG_BK3515A_COMBO
-    gpio_direction_output(wake->io, sleep?!wake->enable:wake->enable);
-#else
-    if(!sleep)
-    {
-        DBG("HOST_UART0_TX pull down 10us\n");
-        if (rfkill_rk_setup_gpio(rfkill->pdev, wake, rfkill->pdata->name, "wake") != 0) {
-            return;
-        }
-
-        gpio_direction_output(wake->io, wake->enable);
-        udelay(10);
-        gpio_direction_output(wake->io, !wake->enable);
-
-        gpio_free(wake->io);
-    }
-#endif
-}
-
-static void rfkill_rk_delay_sleep_bt(struct work_struct *work)
-{
-    struct rfkill_rk_data *rfkill = NULL;
-    DBG("Enter %s\n",__FUNCTION__);
-
-    rfkill = container_of(work, struct rfkill_rk_data, bt_sleep_delay_work.work);
-
-    rfkill_rk_sleep_bt_internal(rfkill, BT_SLEEP);
-}
-
-void rfkill_rk_sleep_bt(bool sleep)
-{
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_gpio *wake;
-    bool ret;
-    DBG("Enter %s\n",__FUNCTION__);
-    
-    if (rfkill==NULL)
-    {
-        LOG("*** RFKILL is empty???\n");
-        return;
-    }
-
-    wake = &rfkill->pdata->wake_gpio;
-    if (!gpio_is_valid(wake->io))
-    {
-        DBG("*** Not support bt wakeup and sleep\n");
-        return;
-    }
-
-    ret = cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
-
-    rfkill_rk_sleep_bt_internal(rfkill, sleep);
-
-#ifdef CONFIG_BT_AUTOSLEEP
-    if (sleep==BT_WAKEUP)
-    {
-        schedule_delayed_work(&rfkill->bt_sleep_delay_work, 
-                            msecs_to_jiffies(BT_WAKEUP_TIMEOUT));
-    }
-#endif
+	return 0;
 }
-EXPORT_SYMBOL(rfkill_rk_sleep_bt);
 
-static int bt_power_state = 0;
-int rfkill_get_bt_power_state(int *power, bool *toggle)
+static int rfkill_set_power(void *data, bool blocked)
 {
-    struct rfkill_rk_data *mrfkill = g_rfkill;
-
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-bt driver has not Successful initialized\n", __func__);
-        return -1;
-    }
+	struct rfkill_bt_data *rfkill = data;
+	struct ctrl_gpio *poweron = &rfkill->pdata->power_n;
 
-    *toggle = mrfkill->pdata->power_toggle;
-    *power = bt_power_state;
-
-    return 0;
-}
-
-static int rfkill_rk_set_power(void *data, bool blocked)
-{
-	struct rfkill_rk_data *rfkill = data;
-	struct rfkill_rk_gpio *wake_host = &rfkill->pdata->wake_host_irq.gpio;
-    struct rfkill_rk_gpio *poweron = &rfkill->pdata->poweron_gpio;
-    struct rfkill_rk_gpio *reset = &rfkill->pdata->reset_gpio;
-    struct rfkill_rk_gpio* rts = &rfkill->pdata->rts_gpio;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
-    int power = 0, vref_ctrl_enable = 0;
-    bool toggle = false;
-
-    DBG("Enter %s\n", __func__);
-
-    DBG("Set blocked:%d\n", blocked);
-
-    toggle = rfkill->pdata->power_toggle;
-    if (!rfkill_get_wifi_power_state(&power, &vref_ctrl_enable)) {
-        if (true == toggle && 1 == power) {
-            LOG("%s: bt shouldn't control the power, it was enabled by wifi!\n", __func__);
-            return 0;
-        }
-    } else {
-        LOG("%s: cannot get wifi power state!\n", __func__);
-        return -1;
-    }
-
-	if (false == blocked) { 
-
-        rfkill_rk_sleep_bt(BT_WAKEUP); // ensure bt is wakeup
-	if (gpio_is_valid(wake_host->io)) {
-		LOG("%s: set bt wake_host pin output high!\n", __func__);
-		gpio_direction_output(wake_host->io, 1);
-		msleep(20);
-	}
+	DBG("blocked state:%d\n", blocked);
 
-	if (gpio_is_valid(poweron->io))
-        {
-		gpio_direction_output(poweron->io, !poweron->enable);
-		msleep(20);
-		gpio_direction_output(poweron->io, poweron->enable);
-		msleep(20);
-		// gpio_direction_input(wake_host->io);
-		LOG("%s: set bt wake_host pin input!\n", __func__);
-        }
-		if (gpio_is_valid(reset->io))
-        {
-			gpio_direction_output(reset->io, !reset->enable);
-            msleep(20);
-			gpio_direction_output(reset->io, reset->enable);
-        }
-
-        if (pinctrl != NULL && gpio_is_valid(rts->io))
-        {
-            pinctrl_select_state(pinctrl, rts->gpio_state);
-            LOG("ENABLE UART_RTS\n");
-            gpio_direction_output(rts->io, rts->enable);
-            msleep(100);
-            LOG("DISABLE UART_RTS\n");
-            gpio_direction_output(rts->io, !rts->enable);
-            pinctrl_select_state(pinctrl, rts->default_state);
-        }
-
-        bt_power_state = 1;
-    	LOG("bt turn on power\n");
+	if (!blocked) {
+		if (gpio_is_valid(poweron->io)) {
+			gpio_direction_output(poweron->io, !poweron->enable);
+			msleep(20);
+			gpio_direction_output(poweron->io, poweron->enable);
+			msleep(20);
+			}
+		LOG("Turn on the power of the BT module\n");
 	} else {
-            if (gpio_is_valid(poweron->io))
-            {      
-                gpio_direction_output(poweron->io, !poweron->enable);
-                msleep(20);
-            }
-
-            bt_power_state = 0;
-    		LOG("bt shut off power\n");
-		if (gpio_is_valid(reset->io))
-        {      
-			gpio_direction_output(reset->io, !reset->enable);/* bt reset active*/
-            msleep(20);
-        }
+		if (gpio_is_valid(poweron->io)) {
+			gpio_direction_output(poweron->io, !poweron->enable);
+			msleep(20);
+		}
 
+		LOG("Turn off the power of the BT module\n");
 	}
 
 	return 0;
 }
 
-static int rfkill_rk_pm_prepare(struct device *dev)
-{
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_gpio* rts;
-    struct rfkill_rk_irq*  wake_host_irq;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
-
-    DBG("Enter %s\n",__FUNCTION__);
-
-    if (!rfkill)
-        return 0;
-
-    rts = &rfkill->pdata->rts_gpio;
-    wake_host_irq = &rfkill->pdata->wake_host_irq;
-
-    //To prevent uart to receive bt data when suspended
-    if (pinctrl != NULL && gpio_is_valid(rts->io))
-    {
-        DBG("Disable UART_RTS\n");
-        pinctrl_select_state(pinctrl, rts->gpio_state);
-        gpio_direction_output(rts->io, !rts->enable);
-    }
-
-#ifdef CONFIG_BT_AUTOSLEEP
-    rfkill_rk_sleep_bt(BT_SLEEP);
-#endif
-
-    // enable bt wakeup host
-    if (gpio_is_valid(wake_host_irq->gpio.io))
-    {
-        DBG("enable irq for bt wakeup host\n");
-        enable_irq(wake_host_irq->irq);
-    }
-
-#ifdef CONFIG_RFKILL_RESET
-    rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
-    rfkill_rk_set_power(rfkill, BT_BLOCKED);
-#endif
-
-    return 0;
-}
-
-static void rfkill_rk_pm_complete(struct device *dev)
-{
-    struct rfkill_rk_data *rfkill = g_rfkill;
-    struct rfkill_rk_irq*  wake_host_irq;
-    struct rfkill_rk_gpio* rts;
-    struct pinctrl *pinctrl = rfkill->pdata->pinctrl;
-
-    DBG("Enter %s\n",__FUNCTION__);
-
-    if (!rfkill)
-        return;
-
-    wake_host_irq = &rfkill->pdata->wake_host_irq;
-    rts = &rfkill->pdata->rts_gpio;
-
-    if (gpio_is_valid(wake_host_irq->gpio.io))
-    {
-        LOG("** disable irq\n");
-        disable_irq(wake_host_irq->irq);
-    }
-
-    if (pinctrl != NULL && gpio_is_valid(rts->io))
-    {
-        DBG("Enable UART_RTS\n");
-        gpio_direction_output(rts->io, rts->enable);
-        pinctrl_select_state(pinctrl, rts->default_state);
-    }
-}
-
-static const struct rfkill_ops rfkill_rk_ops = {
-    .set_block = rfkill_rk_set_power,
+static const struct rfkill_ops rfkill_ops = {
+	.set_block = rfkill_set_power,
 };
 
-#define PROC_DIR	"bluetooth/sleep"
-
-static struct proc_dir_entry *bluetooth_dir, *sleep_dir;
-
-static ssize_t bluesleep_read_proc_lpm(struct file *file, char __user *buffer,
-				       size_t count, loff_t *data)
-{
-    return sprintf(buffer, "unsupported to read\n");
-}
-
-static ssize_t bluesleep_write_proc_lpm(struct file *file,
-					const char __user *buffer,
-					size_t count, loff_t *data)
-{
-    return count;
-}
-
-static ssize_t bluesleep_read_proc_btwrite(struct file *file,
-					   char __user *buffer,
-					   size_t count, loff_t *data)
-{
-    return sprintf(buffer, "unsupported to read\n");
-}
-
-static ssize_t bluesleep_write_proc_btwrite(struct file *file,
-					    const char __user *buffer,
-					    size_t count, loff_t *data)
-{
-    char b;
-
-    if (count < 1)
-        return -EINVAL;
-
-    if (copy_from_user(&b, buffer, 1))
-        return -EFAULT;
-
-    DBG("btwrite %c\n", b);
-    /* HCI_DEV_WRITE */
-    if (b != '0') {
-        rfkill_rk_sleep_bt(BT_WAKEUP);
-    }
-
-    return count;
-}
-
 #ifdef CONFIG_OF
-static int bluetooth_platdata_parse_dt(struct device *dev,
-                  struct rfkill_rk_platform_data *data)
-{
-    struct device_node *node = dev->of_node;
-    struct gpio_desc *desc;
-    int gpio;
-    unsigned long flags;
-
-    if (!node)
-        return -ENODEV;
-
-    memset(data, 0, sizeof(*data));
-
-    if (of_find_property(node, "wifi-bt-power-toggle", NULL)) {
-        data->power_toggle = true;
-        LOG("%s: get property wifi-bt-power-toggle.\n", __func__);
-    } else {
-        data->power_toggle = false;
-    }
-
-    gpio = -EINVAL;
-    desc = of_find_gpio(node, "uart_rts", 0, &flags);
-    if (!IS_ERR(desc))
-        gpio = desc_to_gpio(desc);
-    if (gpio_is_valid(gpio)) {
-        data->rts_gpio.io = gpio;
-        data->rts_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: uart_rts-gpios = %d.\n", __func__, gpio);
-        data->pinctrl = devm_pinctrl_get(dev);
-        if (!IS_ERR(data->pinctrl)) {
-            data->rts_gpio.default_state = pinctrl_lookup_state(data->pinctrl, "default");
-            data->rts_gpio.gpio_state = pinctrl_lookup_state(data->pinctrl, "rts_gpio");
-        } else {
-            data->pinctrl = NULL;
-            LOG("%s: dts does't define the uart rts iomux.\n", __func__);
-            return -EINVAL;
-        }
-    } else {
-        data->pinctrl = NULL;
-        data->rts_gpio.io = -EINVAL;
-        LOG("%s: uart_rts_gpios is no-in-use.\n", __func__);
-    }
-
-    gpio = -EINVAL;
-    desc = of_find_gpio(node, "BT,power", 0, &flags);
-    if (!IS_ERR(desc))
-        gpio = desc_to_gpio(desc);
-    LOG("%s: BT,power-gpios = %d\n", __func__, gpio);
-    if (gpio_is_valid(gpio)){
-        data->poweron_gpio.io = gpio;
-        data->poweron_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,power-gpios = %d.\n", __func__, gpio);
-    } else data->poweron_gpio.io = -1;
-
-    gpio = -EINVAL;
-    desc = of_find_gpio(node, "BT,reset", 0, &flags);
-    if (!IS_ERR(desc))
-        gpio = desc_to_gpio(desc);
-    if (gpio_is_valid(gpio)){
-        data->reset_gpio.io = gpio;
-        data->reset_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,reset-gpios = %d.\n", __func__, gpio);
-    } else data->reset_gpio.io = -1;
-
-    gpio = -EINVAL;
-    desc = of_find_gpio(node, "BT,wake", 0, &flags);
-    if (!IS_ERR(desc))
-        gpio = desc_to_gpio(desc);
-    if (gpio_is_valid(gpio)){
-        data->wake_gpio.io = gpio;
-        data->wake_gpio.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-        LOG("%s: get property: BT,wake-gpios = %d.\n", __func__, gpio);
-    } else data->wake_gpio.io = -1;
-
-    gpio = -EINVAL;
-    desc = of_find_gpio(node, "BT,wake_host_irq", 0, &flags);
-    if (!IS_ERR(desc))
-        gpio = desc_to_gpio(desc);
-    if (gpio_is_valid(gpio)) {
-        data->wake_host_irq.gpio.io = gpio;
-        data->wake_host_irq.gpio.enable = flags;
-        LOG("%s: get property: BT,wake_host_irq-gpios = %d.\n", __func__, gpio);
-    } else data->wake_host_irq.gpio.io = -1;
-
-	data->ext_clk = devm_clk_get(dev, "ext_clock");
-	if (IS_ERR(data->ext_clk)) {
-		LOG("%s: clk_get failed!!!.\n", __func__);
+static int bluetooth_platdata_parse_dt(struct device *dev, struct rfkill_platform_data *data)
+{
+	struct device_node *node = dev->of_node;
+	struct gpio_desc *desc;
+	int gpio;
+	unsigned long flags;
+
+	if (!node)
+		return -ENODEV;
+
+	memset(data, 0, sizeof(*data));
+
+	gpio = -EINVAL;
+	desc = of_find_gpio(node, "BT,power", 0, &flags);
+	if (!IS_ERR(desc))
+		gpio = desc_to_gpio(desc);
+	LOG("%s: BT,power-gpios = %d\n", __func__, gpio);
+	if (gpio_is_valid(gpio)) {
+		data->power_n.io = gpio;
+		data->power_n.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: BT,power-gpios = %d.\n", __func__, gpio);
 	} else {
-		clk_prepare_enable(data->ext_clk);
+		data->power_n.io = -1;
 	}
+
 	return 0;
 }
 #endif //CONFIG_OF
 
-static const struct proc_ops bluesleep_lpm = {
-    // .owner = THIS_MODULE,
-    .proc_read = bluesleep_read_proc_lpm,
-    .proc_write = bluesleep_write_proc_lpm,
-};
-
-static const struct proc_ops bluesleep_btwrite = {
-    // .owner = THIS_MODULE,
-    .proc_read = bluesleep_read_proc_btwrite,
-    .proc_write = bluesleep_write_proc_btwrite,
-};
-
-static int rfkill_rk_probe(struct platform_device *pdev)
+static int rfkill_probe(struct platform_device *pdev)
 {
-	struct rfkill_rk_data *rfkill;
-	struct rfkill_rk_platform_data *pdata = pdev->dev.platform_data;
+	struct rfkill_bt_data *rfkill;
+	struct rfkill_platform_data *pdata = pdev->dev.platform_data;
 	int ret = 0;
-    struct proc_dir_entry *ent;
-
-    DBG("Enter %s\n", __func__);
-
-    if (!pdata) {
-#ifdef CONFIG_OF
-        pdata = devm_kzalloc(&pdev->dev, sizeof(struct rfkill_rk_platform_data), GFP_KERNEL);
-        if (!pdata)
-            return -ENOMEM;
 
-        ret = bluetooth_platdata_parse_dt(&pdev->dev, pdata);
-        if (ret < 0) {
-#endif
-            LOG("%s: No platform data specified\n", __func__);
-            return ret;
-#ifdef CONFIG_OF
-        }
-#endif
-    }
+	if (!pdata) {
+	#ifdef CONFIG_OF
+		pdata = devm_kzalloc(&pdev->dev, sizeof(struct rfkill_platform_data), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
+
+		ret = bluetooth_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
+	#endif
+			LOG("%s: Invalid platform data\n", __func__);
+			return ret;
+	#ifdef CONFIG_OF
+		}
+	#endif
+	}
 
-    pdata->name = (char*)bt_name;
-    pdata->type = RFKILL_TYPE_BLUETOOTH;
+	pdata->name = (char *)bt_name;
+	pdata->type = RFKILL_TYPE_BLUETOOTH;
 
 	rfkill = devm_kzalloc(&pdev->dev, sizeof(*rfkill), GFP_KERNEL);
 	if (!rfkill)
 		return -ENOMEM;
 
 	rfkill->pdata = pdata;
-    rfkill->pdev = pdev;
-    g_rfkill = rfkill;
-
-    bluetooth_dir = proc_mkdir("bluetooth", NULL);
-    if (bluetooth_dir == NULL) {
-        LOG("Unable to create /proc/bluetooth directory");
-        return -ENOMEM;
-    }
-
-    sleep_dir = proc_mkdir("sleep", bluetooth_dir);
-    if (sleep_dir == NULL) {
-        LOG("Unable to create /proc/%s directory", PROC_DIR);
-        return -ENOMEM;
-    }
-
-	/* read/write proc entries */
-    ent = proc_create("lpm", 0, sleep_dir, &bluesleep_lpm);
-    if (ent == NULL) {
-        LOG("Unable to create /proc/%s/lpm entry", PROC_DIR);
-        ret = -ENOMEM;
-        goto fail_alloc;
-    }
-
-    /* read/write proc entries */
-    ent = proc_create("btwrite", 0, sleep_dir, &bluesleep_btwrite);
-    if (ent == NULL) {
-        LOG("Unable to create /proc/%s/btwrite entry", PROC_DIR);
-        ret = -ENOMEM;
-        goto fail_alloc;
-    }
-
-    DBG("init gpio\n");
-
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->poweron_gpio, pdata->name, "poweron");
-    if (ret) goto fail_gpio;
-
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->reset_gpio, pdata->name, "reset");
-    if (ret) goto fail_gpio;
+	rfkill->pdev = pdev;
+	g_rfkill = rfkill;
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->wake_gpio, pdata->name, "wake");
-    if (ret) goto fail_gpio;
+	DBG("setup gpio\n");
 
-    ret = rfkill_rk_setup_gpio(pdev, &pdata->rts_gpio, rfkill->pdata->name, "rts"); 
-    if (ret) goto fail_gpio;
+	ret = rfkill_setup_gpio(pdev, &pdata->power_n, pdata->name, "bt_power_en");
+	if (ret)
+		goto fail_gpio;
 
-    // wake_lock_init(&(rfkill->bt_irq_wl), WAKE_LOCK_SUSPEND, "rfkill_rk_irq_wl");
-
-    ret = rfkill_rk_setup_wake_irq(rfkill);
-    if (ret) goto fail_gpio;
-
-    DBG("setup rfkill\n");
+	DBG("alloc rfkill\n");
 	rfkill->rfkill_dev = rfkill_alloc(pdata->name, &pdev->dev, pdata->type,
-				&rfkill_rk_ops, rfkill);
+									&rfkill_ops, rfkill);
 	if (!rfkill->rfkill_dev)
 		goto fail_alloc;
 
-    rfkill_set_states(rfkill->rfkill_dev, BT_BLOCKED, false);
+	rfkill_set_states(rfkill->rfkill_dev, true, false);
 	ret = rfkill_register(rfkill->rfkill_dev);
 	if (ret < 0)
 		goto fail_rfkill;
 
-    INIT_DELAYED_WORK(&rfkill->bt_sleep_delay_work, rfkill_rk_delay_sleep_bt);
-
-    //rfkill_rk_set_power(rfkill, BT_BLOCKED);
-    // bt turn off power
-    if (gpio_is_valid(pdata->poweron_gpio.io))
-    {
-        gpio_direction_output(pdata->poweron_gpio.io, !pdata->poweron_gpio.enable);
-    }
-    if (gpio_is_valid(pdata->reset_gpio.io))
-    {
-        gpio_direction_output(pdata->reset_gpio.io, !pdata->reset_gpio.enable);
-    }
+	// bt turn off power
+	if (gpio_is_valid(pdata->power_n.io))
+		gpio_direction_output(pdata->power_n.io, !pdata->power_n.enable);
 
 	platform_set_drvdata(pdev, rfkill);
 
-    LOG("%s device registered.\n", pdata->name);
+	LOG("%s device registered.\n", pdata->name);
 
 	return 0;
 
 fail_rfkill:
-	rfkill_destroy(rfkill->rfkill_dev);
 fail_alloc:
+	rfkill_destroy(rfkill->rfkill_dev);
 
-	remove_proc_entry("btwrite", sleep_dir);
-	remove_proc_entry("lpm", sleep_dir);
 fail_gpio:
+	g_rfkill = NULL;
 
-        g_rfkill = NULL;
 	return ret;
 }
 
-static int rfkill_rk_remove(struct platform_device *pdev)
+static int rfkill_remove(struct platform_device *pdev)
 {
-	struct rfkill_rk_data *rfkill = platform_get_drvdata(pdev);
-
-    LOG("Enter %s\n", __func__);
+	struct rfkill_bt_data *rfkill = platform_get_drvdata(pdev);
 
 	rfkill_unregister(rfkill->rfkill_dev);
 	rfkill_destroy(rfkill->rfkill_dev);
 
-    
-    cancel_delayed_work_sync(&rfkill->bt_sleep_delay_work);
-
-    // free gpio
-    if (gpio_is_valid(rfkill->pdata->rts_gpio.io))
-        gpio_free(rfkill->pdata->rts_gpio.io);
-    
-    if (gpio_is_valid(rfkill->pdata->wake_host_irq.gpio.io)){
-        free_irq(rfkill->pdata->wake_host_irq.irq, rfkill);
-#ifndef CONFIG_BK3515A_COMBO
-        gpio_free(rfkill->pdata->wake_host_irq.gpio.io);
-#endif
-    }
-    
-#ifndef CONFIG_BK3515A_COMBO
-    if (gpio_is_valid(rfkill->pdata->wake_gpio.io))
-        gpio_free(rfkill->pdata->wake_gpio.io);
-#endif
-    
-    if (gpio_is_valid(rfkill->pdata->reset_gpio.io))
-        gpio_free(rfkill->pdata->reset_gpio.io);
-    
-    if (gpio_is_valid(rfkill->pdata->poweron_gpio.io))
-		gpio_free(rfkill->pdata->poweron_gpio.io);
-	clk_disable_unprepare(rfkill->pdata->ext_clk);
-    g_rfkill = NULL;
+	// free gpio
+	if (gpio_is_valid(rfkill->pdata->power_n.io))
+		gpio_free(rfkill->pdata->power_n.io);
+
+	g_rfkill = NULL;
 
 	return 0;
 }
 
-static const struct dev_pm_ops rfkill_rk_pm_ops = {
-	.prepare = rfkill_rk_pm_prepare,
-	.complete = rfkill_rk_pm_complete,
-};
-
 #ifdef CONFIG_OF
-static struct of_device_id bt_platdata_of_match[] = {
-    { .compatible = "bluetooth-platdata" },
-    { }
+static const struct of_device_id bt_platdata_of_match[] = {
+	{ .compatible = "bluetooth-platdata" },
+	{ }
 };
 MODULE_DEVICE_TABLE(of, bt_platdata_of_match);
 #endif //CONFIG_OF
 
-static struct platform_driver rfkill_rk_driver = {
-	.probe = rfkill_rk_probe,
-	.remove = rfkill_rk_remove,
+static struct platform_driver rfkill_driver = {
+	.probe = rfkill_probe,
+	.remove = rfkill_remove,
 	.driver = {
 		.name = "rfkill_bt",
 		.owner = THIS_MODULE,
-		.pm = &rfkill_rk_pm_ops,
-        .of_match_table = of_match_ptr(bt_platdata_of_match),
+		.of_match_table = of_match_ptr(bt_platdata_of_match),
 	},
 };
 
-static int __init rfkill_rk_init(void)
+static int __init rfkill_init(void)
 {
-    LOG("Enter %s\n", __func__);
-	return platform_driver_register(&rfkill_rk_driver);
+	return platform_driver_register(&rfkill_driver);
 }
 
-static void __exit rfkill_rk_exit(void)
+static void __exit rfkill_exit(void)
 {
-    LOG("Enter %s\n", __func__);
-	platform_driver_unregister(&rfkill_rk_driver);
+	platform_driver_unregister(&rfkill_driver);
 }
 
-module_init(rfkill_rk_init);
-module_exit(rfkill_rk_exit);
+module_init(rfkill_init);
+module_exit(rfkill_exit);
 
-MODULE_DESCRIPTION("rock-chips rfkill for Bluetooth v0.3");
-MODULE_AUTHOR("cmy@rock-chips.com, gwl@rock-chips.com");
+MODULE_DESCRIPTION("rfkill for Bluetooth");
 MODULE_LICENSE("GPL");
-
diff --git a/net/rfkill/rfkill-wlan.c b/net/rfkill/rfkill-wlan.c
index 819230e75e61..c217716e2e59 100644
--- a/net/rfkill/rfkill-wlan.c
+++ b/net/rfkill/rfkill-wlan.c
@@ -1,42 +1,12 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
- * Copyright (C) 2012 ROCKCHIP, Inc.
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
+ * Copyright (C) 2021-2022 Alibaba Group Holding Limited.
+ * Copyright (C) 2021-2022 Jiandong Yu <yjd01941629@alibaba-inc.com>
  */
-/* Rock-chips rfkill driver for wifi
-*/
 
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <linux/module.h>
 #include <linux/rfkill.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/regulator/consumer.h>
 #include <linux/delay.h>
-#include <linux/rfkill-wlan.h>
-#include <linux/rfkill-bt.h>
-#include <linux/interrupt.h>
-#include <asm/irq.h>
-#include <linux/suspend.h>
-#include <linux/proc_fs.h>
-#include <linux/uaccess.h>
-#include <linux/gpio.h>
 #include <dt-bindings/gpio/gpio.h>
-#include <linux/skbuff.h>
-#include <linux/fb.h>
-#include <linux/regmap.h>
-#include <linux/mfd/syscon.h>
-#include <linux/mmc/host.h>
-#include <linux/pinctrl/consumer.h>
 #include "../../drivers/gpio/gpiolib-of.h"
 #ifdef CONFIG_OF
 #include <linux/of.h>
@@ -44,842 +14,181 @@
 #include <linux/of_gpio.h>
 #endif
 
-#if 0
-#define DBG(x...)   printk(KERN_INFO "[WLAN_RFKILL]: "x)
-#else
-#define DBG(x...)
-#endif
-
 #define LOG(x...)   printk(KERN_INFO "[WLAN_RFKILL]: "x)
 
-extern struct mmc_host *primary_sdio_host;
-extern void mmc_pwrseq_power_off(struct mmc_host *host);
-
 struct rfkill_wlan_data {
-	struct rksdmmc_gpio_wifi_moudle *pdata;
-    // struct wake_lock            wlan_irq_wl;
+	struct wifi_moudle_gpios *pdata;
 };
 
-static struct rfkill_wlan_data *g_rfkill = NULL;
-static int power_set_time = 0;
-static int support_power_ctrl = 0; //Used to control whether power switch control is supported.
-
-static const char wlan_name[] = 
-#if defined (CONFIG_BCM4330)
-    #if defined (CONFIG_BT_MODULE_NH660)
-        "nh660"
-    #else
-        "bcm4330"
-    #endif
-#elif defined (CONFIG_RK903)
-    #if defined(CONFIG_RKWIFI_26M)
-        "rk903_26M"
-    #else
-        "rk903"
-    #endif
-#elif defined(CONFIG_BCM4329)
-        "bcm4329"
-#elif defined(CONFIG_MV8787)
-        "mv8787"
-#elif defined(CONFIG_AP6210)
-    #if defined(CONFIG_RKWIFI_26M)
-        "ap6210"
-    #else
-        "ap6210_24M"
-    #endif
-#elif defined(CONFIG_AP6330)
-		"ap6330"
-#elif defined(CONFIG_AP6476)
-		"ap6476"
-#elif defined(CONFIG_AP6493)
-		"ap6493"
-#elif defined(CONFIG_MVL88W8977)
-        "mvl88w8977"
-#else
-        "wlan_default"
-#endif
-;
-
-static char wifi_chip_type_string[64];
-int get_wifi_chip_type(void)
-{
-    int type;
-    if (strcmp(wifi_chip_type_string, "ap6210") == 0) {
-        type = WIFI_AP6210;
-    } else if (strcmp(wifi_chip_type_string, "ap6212") == 0) {
-        type = WIFI_AP6212;
-    } else if (strcmp(wifi_chip_type_string, "rk901") == 0) {
-        type = WIFI_RK901;    
-    } else if (strcmp(wifi_chip_type_string, "rk903") == 0) {
-        type = WIFI_RK903;  
-    } else if (strcmp(wifi_chip_type_string, "ap6181") == 0) {
-        type = WIFI_AP6181;
-    } else if (strcmp(wifi_chip_type_string, "ap6234") == 0) {
-	type = WIFI_AP6234;
-    } else if (strcmp(wifi_chip_type_string, "ap6255") == 0) {
-	type = WIFI_AP6255;
-    } else if (strcmp(wifi_chip_type_string, "ap6256") == 0) {
-	type = WIFI_AP6256;
-    } else if (strcmp(wifi_chip_type_string, "ap6330") == 0) {
-        type = WIFI_AP6330;
-    } else if (strcmp(wifi_chip_type_string, "ap6335") == 0) {
-        type = WIFI_AP6335;
-    } else if (strcmp(wifi_chip_type_string, "ap6354") == 0) {
-        type = WIFI_AP6354;
-    } else if (strcmp(wifi_chip_type_string, "ap6441") == 0) {
-        type = WIFI_AP6441;
-    } else if (strcmp(wifi_chip_type_string, "ap6476") == 0) {
-        type = WIFI_AP6476;    
-    } else if (strcmp(wifi_chip_type_string, "ap6493") == 0) {
-        type = WIFI_AP6493;                    
-    } else if (strcmp(wifi_chip_type_string, "rtl8188eu") == 0) {
-        type = WIFI_RTL8188EU;
-    } else if (strcmp(wifi_chip_type_string, "rtl8192du") == 0) {
-        type = WIFI_RTL8192DU;
-    } else if (strcmp(wifi_chip_type_string, "rtl8723as") == 0) {
-        type = WIFI_RTL8723AS;        
-    } else if (strcmp(wifi_chip_type_string, "rtl8723bs_vq0") == 0) {
-        type = WIFI_RTL8723BS_VQ0;        
-    } else if (strcmp(wifi_chip_type_string, "rtl8723bs") == 0) {
-        type = WIFI_RTL8723BS;
-    } else if (strcmp(wifi_chip_type_string, "rtl8723cs") == 0) {
-	type = WIFI_RTL8723CS;
-    } else if (strcmp(wifi_chip_type_string, "rtl8723ds") == 0) {
-	type = WIFI_RTL8723DS;
-    } else if (strcmp(wifi_chip_type_string, "rtl8723au") == 0) {
-        type = WIFI_RTL8723AU;        
-    } else if (strcmp(wifi_chip_type_string, "rtl8723bu") == 0) {
-        type = WIFI_RTL8723BU;
-    } else if (strcmp(wifi_chip_type_string, "rtl8189es") == 0) {
-        type = WIFI_RTL8189ES;
-    } else if (strcmp(wifi_chip_type_string, "rtl8189fs") == 0) {
-        type = WIFI_RTL8189FS;
-    } else if (strcmp(wifi_chip_type_string, "rtl8812au") == 0) {
-        type = WIFI_RTL8812AU;                        
-    } else if (strcmp(wifi_chip_type_string, "esp8089") == 0) {
-        type = WIFI_ESP8089;
-    } else if (strcmp(wifi_chip_type_string, "mvl88w8977") == 0) {
-        type = WIFI_MVL88W8977;
-    } else if (strcmp(wifi_chip_type_string, "ssv6051") == 0) {
-        type = WIFI_SSV6051;
-    } else {
-        type = WIFI_AP6210;
-    }
-    return type;
-}
-EXPORT_SYMBOL(get_wifi_chip_type);
-
-/***********************************************************
- * 
- * Broadcom Wifi Static Memory
- * 
- **********************************************************/
-#ifdef CONFIG_RKWIFI
-#define BCM_STATIC_MEMORY_SUPPORT 0
-#else
-#define BCM_STATIC_MEMORY_SUPPORT 0
-#endif
-//===========================
-#if BCM_STATIC_MEMORY_SUPPORT
-#define PREALLOC_WLAN_SEC_NUM           4
-#define PREALLOC_WLAN_BUF_NUM           160
-#define PREALLOC_WLAN_SECTION_HEADER    0
-#define WLAN_SKB_BUF_NUM        16
-
-#define WLAN_SECTION_SIZE_0     (12 * 1024)
-#define WLAN_SECTION_SIZE_1     (12 * 1024)
-#define WLAN_SECTION_SIZE_2     (32 * 1024)
-#define WLAN_SECTION_SIZE_3     (136* 1024)
-#define WLAN_SECTION_SIZE_4     (4  * 1024)
-#define WLAN_SECTION_SIZE_5     (64 * 1024)
-#define WLAN_SECTION_SIZE_6     (4  * 1024)
-#define WLAN_SECTION_SIZE_7     (4  * 1024)
-
-static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM+1];
-
-struct wifi_mem_prealloc {
-    void *mem_ptr;
-    unsigned long size;
+struct ctrl_gpio {
+	int     io; //The number of GPIO
+	char    name[64];
+	int     enable; //Effective level of GPIO
 };
 
-static struct wifi_mem_prealloc wifi_mem_array[8] = {
-    {NULL, (WLAN_SECTION_SIZE_0)},
-    {NULL, (WLAN_SECTION_SIZE_1)},
-    {NULL, (WLAN_SECTION_SIZE_2)},
-    {NULL, (WLAN_SECTION_SIZE_3)},
-    {NULL, (WLAN_SECTION_SIZE_4)},
-    {NULL, (WLAN_SECTION_SIZE_5)},
-    {NULL, (WLAN_SECTION_SIZE_6)},
-    {NULL, (WLAN_SECTION_SIZE_7)}
+struct wifi_moudle_gpios {
+	bool power_remain;
+	struct ctrl_gpio   power_n; //PMU_EN
 };
 
-static int rockchip_init_wifi_mem(void)
-{
-    int i;
-    int j;
-
-    for (i = 0 ; i < WLAN_SKB_BUF_NUM ; i++) {
-        wlan_static_skb[i] = dev_alloc_skb(
-               ((i < (WLAN_SKB_BUF_NUM / 2)) ? (PAGE_SIZE*1) : (PAGE_SIZE*2)));
-
-        if (!wlan_static_skb[i])
-            goto err_skb_alloc;
-    }
-
-    wlan_static_skb[i] = dev_alloc_skb((PAGE_SIZE*4));
-    if (!wlan_static_skb[i])
-        goto err_skb_alloc;
-
-    for (i = 0 ; i <= 7; i++) {
-        wifi_mem_array[i].mem_ptr =
-               kmalloc(wifi_mem_array[i].size, GFP_KERNEL);
-
-        if (!wifi_mem_array[i].mem_ptr)
-            goto err_mem_alloc;
-    }
-    return 0;
-
-err_mem_alloc:
-    pr_err("Failed to mem_alloc for WLAN\n");
-    for (j = 0 ; j < i ; j++)
-        kfree(wifi_mem_array[j].mem_ptr);
-    i = WLAN_SKB_BUF_NUM;
-err_skb_alloc:
-    pr_err("Failed to skb_alloc for WLAN\n");
-    for (j = 0 ; j < i ; j++)
-        dev_kfree_skb(wlan_static_skb[j]);
-    dev_kfree_skb(wlan_static_skb[j]);
-
-    return -ENOMEM;
-}
+static struct rfkill_wlan_data *g_rfkill = NULL;
+static int power_on_time = 0;
+static int power_on_when_resume = 0; //Used to control whether power switch control is supported.
 
-void *rockchip_mem_prealloc(int section, unsigned long size)
-{
-    //printk("rockchip_mem_prealloc: section = %d, size = %d\n", section, size);
-    if (section == PREALLOC_WLAN_SEC_NUM)
-        return wlan_static_skb;
+static const char wlan_name[] =  "wifi";
 
-    if ((section < 0) || (section > 7))
-        return NULL;
+int wifi_power(int on)
+{
+	struct rfkill_wlan_data *rfkill = g_rfkill;
+	struct ctrl_gpio *power_on;
 
-    if (wifi_mem_array[section].size < size)
-        return NULL;
+	LOG("%s: %d\n", __func__, on);
 
-    return wifi_mem_array[section].mem_ptr;
-}
-#else
-void *rockchip_mem_prealloc(int section, unsigned long size) { return NULL;}
-#endif
-EXPORT_SYMBOL(rockchip_mem_prealloc);
-
-/**************************************************************************
- *
- * get wifi power state Func
- *
- *************************************************************************/
-static int wifi_power_state = 0;
-int rfkill_get_wifi_power_state(int *power, int *vref_ctrl_enable)
-{
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
+	if (!rfkill) {
+		LOG("%s: rfkill_wlan_data initialization failed\n", __func__);
+		return -1;
+	}
 
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
+	if (rfkill->pdata->power_remain && power_on_time) {
+		LOG("%s: The power supply of the WiFi module is set to normally open. Skip power control", __func__);
+		return 0;
+	} else {
+		power_on_time++;
+	}
 
-    *power = wifi_power_state;
+	power_on = &rfkill->pdata->power_n;
 
-    return 0;
-}
+	if (on) {
+		if (gpio_is_valid(power_on->io)) {
+			gpio_direction_output(power_on->io, power_on->enable);
+			msleep(500);
+		}
 
-/**************************************************************************
- *
- * Wifi Power Control Func
- * 0 -> power off
- * 1 -> power on
- *
- *************************************************************************/
-int rockchip_wifi_power(int on)
-{
-	struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *poweron, *reset;
-    struct regulator *ldo = NULL;
-    int power = 0;
-    bool toggle = false;
-
-    LOG("%s: %d\n", __func__, on);
-
-	// if (!on && primary_sdio_host)
-	// 	mmc_pwrseq_power_off(primary_sdio_host);
-
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
-
-    if (mrfkill->pdata->wifi_power_remain && power_set_time) {
-        LOG("%s: wifi power is setted to be remain on. skip anything to the power control", __func__);
-        return 0;
-    } else power_set_time++;
-
-    if (!rfkill_get_bt_power_state(&power, &toggle)) {
-        if (toggle == true && power == 1) {
-            LOG("%s: wifi shouldn't control the power, it was enabled by BT!\n", __func__);
-            return 0;
-        }
-    }
-
-    if (mrfkill->pdata->mregulator.power_ctrl_by_pmu) {
-        int ret = -1;
-        char *ldostr;
-        int level = mrfkill->pdata->mregulator.enable;
-
-        ldostr = mrfkill->pdata->mregulator.pmu_regulator;
-        if (ldostr == NULL) {
-            LOG("%s: wifi power set to be controled by pmic, but which one?\n", __func__);
-            return -1;
-        }
-        ldo = regulator_get(NULL, ldostr);
-        if (ldo == NULL || IS_ERR(ldo)) {
-            LOG("\n\n\n%s get ldo error,please mod this\n\n\n", __func__);
-            return -1;
-        } else {
-			if (on == level) {
-				regulator_set_voltage(ldo, 3000000, 3000000);
-			    LOG("%s: %s enabled\n", __func__, ldostr);
-				ret = regulator_enable(ldo);
-                wifi_power_state = 1;
-			    LOG("wifi turn on power.\n");
-            } else {
-				LOG("%s: %s disabled\n", __func__, ldostr);
-                while (regulator_is_enabled(ldo) > 0) {
-				    ret = regulator_disable(ldo);
-                }
-                wifi_power_state = 0;
-			    LOG("wifi shut off power.\n");
-			}
-			regulator_put(ldo);
+		LOG("Turn on the power of the WiFi module. %d\n", power_on->io);
+	} else {
+		if (gpio_is_valid(power_on->io)) {
+			gpio_direction_output(power_on->io, !(power_on->enable));
 			msleep(100);
 		}
-    } else {
-		poweron = &mrfkill->pdata->power_n;
-		reset = &mrfkill->pdata->reset_n;
-
-		if (on){
-			if (gpio_is_valid(poweron->io)) {
-				gpio_direction_output(poweron->io, poweron->enable);
-				msleep(500);
-			}
-
-			if (gpio_is_valid(reset->io)) {
-				gpio_direction_output(reset->io, reset->enable);
-				msleep(100);
-			}
-
-            wifi_power_state = 1;
-			LOG("wifi turn on power. %d\n", poweron->io);
-		}else{
-			if (gpio_is_valid(poweron->io)) {
-				gpio_direction_output(poweron->io, !(poweron->enable));
-				msleep(100);
-			}
-
-			if (gpio_is_valid(reset->io)) {
-				gpio_direction_output(reset->io, !(reset->enable));
-			}
-
-            wifi_power_state = 0;
-			LOG("wifi shut off power.\n");
-		}
-    }
 
-    return 0;
-}
-EXPORT_SYMBOL(rockchip_wifi_power);
-
-/**************************************************************************
- *
- * Wifi Sdio Detect Func
- *
- *************************************************************************/
-extern int mmc_host_rescan(struct mmc_host *host, int val, int irq_type);
-int rockchip_wifi_set_carddetect(int val)
-{
-	// return mmc_host_rescan(NULL, val, 1);
-    return 0;
-}
-EXPORT_SYMBOL(rockchip_wifi_set_carddetect);
-
-/**************************************************************************
- *
- * Wifi Get Interrupt irq Func
- *
- *************************************************************************/
-int rockchip_wifi_get_oob_irq(void)
-{
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *wifi_int_irq;
-
-    LOG("%s: Enter\n", __func__);
-
-    if (mrfkill == NULL) {
-        LOG("%s: rfkill-wlan driver has not Successful initialized\n", __func__);
-        return -1;
-    }
-    
-    wifi_int_irq = &mrfkill->pdata->wifi_int_b;
-    if (gpio_is_valid(wifi_int_irq->io)) {
-        return gpio_to_irq(wifi_int_irq->io);
-        //return wifi_int_irq->io;
-    } else {
-        LOG("%s: wifi OOB pin isn't defined.\n", __func__);
-    }
-    
-    return -1;
-}
-EXPORT_SYMBOL(rockchip_wifi_get_oob_irq);
-
-int rockchip_wifi_get_oob_irq_flag(void)
-{
-	struct rfkill_wlan_data *mrfkill = g_rfkill;
-	struct rksdmmc_gpio *wifi_int_irq;
-	int gpio_flags = -1;
-
-	if (mrfkill) {
-		wifi_int_irq = &mrfkill->pdata->wifi_int_b;
-		if (gpio_is_valid(wifi_int_irq->io))
-			gpio_flags = wifi_int_irq->enable;
+		LOG("Turn off the power of the WiFi module.\n");
 	}
 
-	return gpio_flags;
-}
-EXPORT_SYMBOL(rockchip_wifi_get_oob_irq_flag);
-
-/**************************************************************************
- *
- * Wifi Reset Func
- *
- *************************************************************************/
-int rockchip_wifi_reset(int on)
-{
-    return 0;
+	return 0;
 }
-EXPORT_SYMBOL(rockchip_wifi_reset);
-
-/**************************************************************************
- *
- * Wifi MAC custom Func
- *
- *************************************************************************/
-#include <linux/etherdevice.h>
-#include <linux/errno.h>
-u8 wifi_custom_mac_addr[6] = {0,0,0,0,0,0};
-
-//#define RANDOM_ADDRESS_SAVE
-// static int get_wifi_addr_vendor(unsigned char *addr)
-// {
-// 	int ret;
-// 	int count = 5;
-
-// 	while (count-- > 0) {
-// 		if (is_rk_vendor_ready())
-// 			break;
-// 		/* sleep 500ms wait rk vendor driver ready */
-// 		msleep(500);
-// 	}
-// 	ret = rk_vendor_read(WIFI_MAC_ID, addr, 6);
-// 	if (ret != 6 || is_zero_ether_addr(addr)) {
-// 		LOG("%s: rk_vendor_read wifi mac address failed (%d)\n",
-// 		    __func__, ret);
-// #ifdef CONFIG_WIFI_GENERATE_RANDOM_MAC_ADDR
-// 		random_ether_addr(addr);
-// 		LOG("%s: generate random wifi mac address: "
-// 		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
-// 		    __func__, addr[0], addr[1], addr[2],
-// 		    addr[3], addr[4], addr[5]);
-// 		ret = rk_vendor_write(WIFI_MAC_ID, addr, 6);
-// 		if (ret != 0) {
-// 			LOG("%s: rk_vendor_write"
-// 				" wifi mac address failed (%d)\n",
-// 				__func__, ret);
-// 			memset(addr, 0, 6);
-// 			return -1;
-// 		}
-// #else
-// 		return -1;
-// #endif
-// 	} else {
-// 		LOG("%s: rk_vendor_read wifi mac address: "
-// 		    "%02x:%02x:%02x:%02x:%02x:%02x\n",
-// 		    __func__, addr[0], addr[1], addr[2],
-// 		    addr[3], addr[4], addr[5]);
-// 	}
-// 	return 0;
-// }
-
-int rockchip_wifi_mac_addr(unsigned char *buf)
-{
-	char mac_buf[20] = {0};
-
-	LOG("%s: enter.\n", __func__);
-
-	// from vendor storage
-	// if (is_zero_ether_addr(wifi_custom_mac_addr)) {
-	// 	if (get_wifi_addr_vendor(wifi_custom_mac_addr) != 0)
-	// 		return -1;
-	// }
-
-	sprintf(mac_buf, "%02x:%02x:%02x:%02x:%02x:%02x",
-		wifi_custom_mac_addr[0], wifi_custom_mac_addr[1],
-		wifi_custom_mac_addr[2], wifi_custom_mac_addr[3],
-		wifi_custom_mac_addr[4], wifi_custom_mac_addr[5]);
-	LOG("falsh wifi_custom_mac_addr=[%s]\n", mac_buf);
 
-	if (is_valid_ether_addr(wifi_custom_mac_addr)) {
-		if (!strncmp(wifi_chip_type_string, "rtl", 3))
-			wifi_custom_mac_addr[0] &= ~0x2; // for p2p
-	} else {
-		LOG("This mac address is not valid, ignored...\n");
-		return -1;
+static int rfkill_setup_gpio(struct ctrl_gpio *gpio, const char *prefix, const char *name)
+{
+	if (gpio_is_valid(gpio->io)) {
+		int ret = 0;
+
+		sprintf(gpio->name, "%s_%s", prefix, name);
+		ret = gpio_request(gpio->io, gpio->name);
+		if (ret) {
+			LOG("Failed to get %s gpio.\n", gpio->name);
+			return -1;
+		}
 	}
 
-	memcpy(buf, wifi_custom_mac_addr, 6);
-
 	return 0;
 }
-EXPORT_SYMBOL(rockchip_wifi_mac_addr);
-
-/**************************************************************************
- *
- * wifi get country code func
- *
- *************************************************************************/
-struct cntry_locales_custom {
-    char iso_abbrev[4];  /* ISO 3166-1 country abbreviation */
-    char custom_locale[4];   /* Custom firmware locale */
-    int custom_locale_rev;        /* Custom local revisin default -1 */
-};
-
-static struct cntry_locales_custom country_cloc;
 
-void *rockchip_wifi_country_code(char *ccode)
+#ifdef CONFIG_OF
+static int wlan_platdata_parse_dt(struct device *dev, struct wifi_moudle_gpios *data)
 {
-    struct cntry_locales_custom *mcloc;
-
-    LOG("%s: set country code [%s]\n", __func__, ccode);
-    mcloc = &country_cloc;
-    memcpy(mcloc->custom_locale, ccode, 4);
-    mcloc->custom_locale_rev = 0;
+	struct device_node *node = dev->of_node;
+	struct gpio_desc *desc;
+	int gpio;
+	unsigned long flags;
 
-    return mcloc;
-}
-EXPORT_SYMBOL(rockchip_wifi_country_code);
-/**************************************************************************/
+	if (!node)
+		return -ENODEV;
 
-static int rfkill_rk_setup_gpio(struct rksdmmc_gpio *gpio, const char* prefix, const char* name)
-{
-    if (gpio_is_valid(gpio->io)) {
-        int ret=0;
-        sprintf(gpio->name, "%s_%s", prefix, name);
-        ret = gpio_request(gpio->io, gpio->name);
-        if (ret) {
-            LOG("Failed to get %s gpio.\n", gpio->name);
-            return -1;
-        }
-    }
-
-    return 0;
-}
+	memset(data, 0, sizeof(*data));
 
-#ifdef CONFIG_OF
-static int wlan_platdata_parse_dt(struct device *dev,
-                  struct rksdmmc_gpio_wifi_moudle *data)
-{
-    struct device_node *node = dev->of_node;
-    struct gpio_desc *desc;
-    const char *strings;
-    u32 value;
-    int gpio,ret;
-    unsigned long flags;
-	u32 ext_clk_value = 0;
-
-    if (!node)
-        return -ENODEV;
-
-    memset(data, 0, sizeof(*data));
-
-#ifdef CONFIG_MFD_SYSCON
-    data->grf = syscon_regmap_lookup_by_phandle(node, "rockchip,grf");
-    if (IS_ERR(data->grf)) {
-            LOG("can't find rockchip,grf property\n");
-            //return -1;
-    }
-#endif
+	if (of_find_property(node, "power_on_after_init", NULL)) {
+		data->power_remain = true;
+		LOG("%s: WiFi module maintains power on normally after initialization.\n", __func__);
+	} else {
+		data->power_remain = false;
+		LOG("%s: Enable power control of WiFi modules.\n", __func__);
+	}
 
-    ret = of_property_read_string(node, "wifi_chip_type", &strings);
-    if (ret) {
-        LOG("%s: Can not read wifi_chip_type, set default to rkwifi.\n", __func__);
-        strcpy(wifi_chip_type_string, "rkwifi");
-    } else {
-        strcpy(wifi_chip_type_string, strings);
-    }
-    LOG("%s: wifi_chip_type = %s\n", __func__, wifi_chip_type_string);
-
-    if (of_find_property(node, "keep_wifi_power_on", NULL)) {
-        data->wifi_power_remain = true;
-        LOG("%s: wifi power will enabled while kernel starting and keep on.\n", __func__);
-    } else {
-        data->wifi_power_remain = false;
-        LOG("%s: enable wifi power control.\n", __func__);
-    }
-
-    if (of_find_property(node, "power_ctrl_by_pmu", NULL)) {
-        data->mregulator.power_ctrl_by_pmu = true;
-        ret = of_property_read_string(node, "power_pmu_regulator", &strings);
-        if (ret) {
-            LOG("%s: Can not read property: power_pmu_regulator.\n", __func__);
-            data->mregulator.power_ctrl_by_pmu = false;
-        } else {
-            LOG("%s: wifi power controled by pmu(%s).\n", __func__, strings);
-            sprintf(data->mregulator.pmu_regulator, "%s", strings);
-        }
-        ret = of_property_read_u32(node, "power_pmu_enable_level", &value);
-        if (ret) {
-            LOG("%s: Can not read property: power_pmu_enable_level.\n", __func__);
-            data->mregulator.power_ctrl_by_pmu = false;
-        } else {
-            LOG("%s: wifi power controled by pmu(level = %s).\n", __func__, (value == 1)?"HIGH":"LOW");
-            data->mregulator.enable = value;
-        }
+	gpio = -EINVAL;
+	desc = of_find_gpio(node, "WIFI,poweren", 0, &flags);
+	if (!IS_ERR(desc))
+		gpio = desc_to_gpio(desc);
+	LOG("%s: The power of the WiFi module is controlled by GPIO.\n", __func__);
+	if (gpio_is_valid(gpio)) {
+		data->power_n.io = gpio;
+		data->power_n.enable = (flags == GPIO_ACTIVE_HIGH) ? 1 : 0;
+		LOG("%s: get property: WIFI,poweren-gpios = %d, flags = %d.\n", __func__, gpio, flags);
 	} else {
-		data->mregulator.power_ctrl_by_pmu = false;
-
-        gpio = -EINVAL;
-        desc = of_find_gpio(node, "WIFI,poweren", 0, &flags);
-        if (!IS_ERR(desc))
-            gpio = desc_to_gpio(desc);
-        LOG("%s: wifi power controled by gpio.\n", __func__);
-        if (gpio_is_valid(gpio)){
-			data->power_n.io = gpio;
-			data->power_n.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-			LOG("%s: get property: WIFI,poweren-gpios = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->power_n.io = -1;
-
-        if (of_find_property(node, "support_power_ctrl", NULL)) {
-            support_power_ctrl = true;
-            LOG("%s: Turn off the power during suspension and turn it on when resuming, support_power_ctrl = %d.\n", __func__, support_power_ctrl);
-        } else {
-            support_power_ctrl = false;
-            LOG("%s: power is only turned on during initialization and is not controlled afterwards, support_power_ctrl = %d.\n", __func__, support_power_ctrl);
-        }
-
-        gpio = -EINVAL;
-        desc = of_find_gpio(node, "WIFI,vbat", 0, &flags);
-        if (!IS_ERR(desc))
-            gpio = desc_to_gpio(desc);
-        if (gpio_is_valid(gpio)) {
-                data->vbat_n.io = gpio;
-                data->vbat_n.enable = (flags == GPIO_ACTIVE_HIGH) ? 1:0;
-                LOG("%s: get property: WIFI,vbat-gpios = %d, flags = %d.\n", __func__, gpio, flags);
-        } else {
-            data->vbat_n.io = -1;
-        }
-
-        gpio = -EINVAL;
-        desc = of_find_gpio(node, "WIFI,reset", 0, &flags);
-        if (!IS_ERR(desc))
-            gpio = desc_to_gpio(desc);
-        if (gpio_is_valid(gpio)){
-			data->reset_n.io = gpio;
-			data->reset_n.enable = (flags == GPIO_ACTIVE_HIGH)? 1:0;
-			LOG("%s: get property: WIFI,reset-gpios = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->reset_n.io = -1;
-
-        gpio = -EINVAL;
-        desc = of_find_gpio(node, "WIFI,host_wake_irq", 0, &flags);
-        if (!IS_ERR(desc))
-            gpio = desc_to_gpio(desc);
-        if (gpio_is_valid(gpio)){
-			data->wifi_int_b.io = gpio;
-			data->wifi_int_b.enable = !flags;
-			LOG("%s: get property: WIFI,host_wake_irq-gpios = %d, flags = %d.\n", __func__, gpio, flags);
-        } else data->wifi_int_b.io = -1;
+		data->power_n.io = -1;
 	}
 
-	data->ext_clk = devm_clk_get(dev, "clk_wifi");
-	if (IS_ERR(data->ext_clk)) {
-		LOG("%s: The ref_wifi_clk not found !\n", __func__);
+	if (of_find_property(node, "power_on_when_resume", NULL)) {
+		power_on_when_resume = true;
+		LOG("%s: Turn off the power during suspension and turn it on when resuming, power_on_when_resume = %d.\n", __func__, power_on_when_resume);
 	} else {
-		of_property_read_u32(node, "ref-clock-frequency",
-				     &ext_clk_value);
-		if (ext_clk_value > 0) {
-			ret = clk_set_rate(data->ext_clk, ext_clk_value);
-			if (ret)
-				LOG("%s: set ref clk error!\n", __func__);
-			ret = clk_prepare_enable(data->ext_clk);
-			if (ret)
-				LOG("%s: enable ref clk error!\n", __func__);
-			/* WIFI clock (REF_CLKOUT) output enable.
-			 * 1'b0: drive disable
-			 * 1'b1: output enable
-			 */
-			if (of_machine_is_compatible("rockchip,rk3308"))
-				regmap_write(data->grf, 0x0314, 0x00020002);
-		}
+		power_on_when_resume = false;
+		LOG("%s: power is only turned on during initialization and is not controlled afterwards, power_on_when_resume = %d.\n", __func__, power_on_when_resume);
 	}
 
-    return 0;
+	return 0;
 }
 #endif //CONFIG_OF
 
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-#include <linux/earlysuspend.h>
-
-static void wlan_early_suspend(struct early_suspend *h)
-{
-    LOG("%s :enter\n", __func__);
-
-    return;
-}
-
-static void wlan_late_resume(struct early_suspend *h)
-{
-    LOG("%s :enter\n", __func__);
-
-    return;
-}
-
-struct early_suspend wlan_early_suspend {
-    .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
-    .suspend = wlan_early_suspend;
-    .resume = wlan_late_resume; 
-}
-#endif
-
-static void rfkill_wlan_early_suspend(void)
-{
-    //LOG("%s :enter\n", __func__);
-
-    return;
-}
-
-static void rfkill_wlan_later_resume(void)
-{
-    //LOG("%s :enter\n", __func__);
-
-    return;
-}
-
-static int rfkill_wlan_fb_event_notify(struct notifier_block *self,
-                       unsigned long action, void *data)
-{
-
-    struct fb_event *event = data;
-    int blank_mode = *((int *)event->data);
-
-    switch (blank_mode) {
-    case FB_BLANK_UNBLANK:
-        rfkill_wlan_later_resume();
-        break;
-    case FB_BLANK_NORMAL:
-        rfkill_wlan_early_suspend();
-        break;
-    default:
-        rfkill_wlan_early_suspend();
-        break;
-    }
-
-    return 0;
-}
-
-static struct notifier_block rfkill_wlan_fb_notifier = {
-    .notifier_call = rfkill_wlan_fb_event_notify,
-};
-
-
 static int rfkill_wlan_probe(struct platform_device *pdev)
 {
 	struct rfkill_wlan_data *rfkill;
-	struct rksdmmc_gpio_wifi_moudle *pdata = pdev->dev.platform_data;
+	struct wifi_moudle_gpios *pdata = pdev->dev.platform_data;
 	int ret = -1;
 
-    LOG("Enter %s\n", __func__);
-
 	if (!pdata) {
 #ifdef CONFIG_OF
-        pdata = kzalloc(sizeof(struct rksdmmc_gpio_wifi_moudle), GFP_KERNEL);
-        if (!pdata)
-            return -ENOMEM;
+		pdata = kzalloc(sizeof(struct wifi_moudle_gpios), GFP_KERNEL);
+		if (!pdata)
+			return -ENOMEM;
 
-        ret = wlan_platdata_parse_dt(&pdev->dev, pdata);
-        if (ret < 0) {
+		ret = wlan_platdata_parse_dt(&pdev->dev, pdata);
+		if (ret < 0) {
 #endif
-		    LOG("%s: No platform data specified\n", __func__);
-            return ret;
+			LOG("%s: Invalid platform data\n", __func__);
+			return ret;
 #ifdef CONFIG_OF
-        }
+		}
 #endif
 	}
 
 	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);
 	if (!rfkill)
-        goto rfkill_alloc_fail;
+		goto rfkill_alloc_fail;
 
 	rfkill->pdata = pdata;
-    g_rfkill = rfkill;
-
-    LOG("%s: init gpio\n", __func__);
-
-    if (!pdata->mregulator.power_ctrl_by_pmu) {
-	ret = rfkill_rk_setup_gpio(&pdata->vbat_n, wlan_name, "wlan_vbat");
-	if (ret)
-		goto fail_alloc;
+	g_rfkill = rfkill;
 
-        ret = rfkill_rk_setup_gpio(&pdata->power_n, wlan_name, "wlan_poweren");
-	if (ret)
-		goto fail_alloc;
+	LOG("%s: setup gpio\n", __func__);
 
-        ret = rfkill_rk_setup_gpio(&pdata->reset_n, wlan_name, "wlan_reset");
+	ret = rfkill_setup_gpio(&pdata->power_n, wlan_name, "wlan_power_en");
 	if (ret)
 		goto fail_alloc;
-    }
-
-    // wake_lock_init(&(rfkill->wlan_irq_wl), WAKE_LOCK_SUSPEND, "rfkill_wlan_wake");
-
-    if (gpio_is_valid(pdata->vbat_n.io)) {
-	gpio_direction_output(pdata->vbat_n.io, pdata->vbat_n.enable);
-    }
-    // Turn off wifi power as default
-    if (gpio_is_valid(pdata->power_n.io))
-    {
-        gpio_direction_output(pdata->power_n.io, !pdata->power_n.enable);
-    }
-
-    if (pdata->wifi_power_remain)
-    {
-        rockchip_wifi_power(1);
-    }
-
-#if BCM_STATIC_MEMORY_SUPPORT
-    rockchip_init_wifi_mem();
-#endif
 
-#if defined(CONFIG_HAS_EARLYSUSPEND)
-    register_early_suspend(wlan_early_suspend);
-#endif
-    
-    fb_register_client(&rfkill_wlan_fb_notifier);
+	// Turn off wifi power as default
+	if (gpio_is_valid(pdata->power_n.io))
+		gpio_direction_output(pdata->power_n.io, !pdata->power_n.enable);
 
-    LOG("Exit %s\n", __func__);
+	if (pdata->power_remain)
+		wifi_power(1);
 
 	return 0;
 
 fail_alloc:
 	kfree(rfkill);
 rfkill_alloc_fail:
-    kfree(pdata);
+	kfree(pdata);
 
-    g_rfkill = NULL;
+	g_rfkill = NULL;
 
 	return ret;
 }
@@ -888,99 +197,59 @@ static int rfkill_wlan_remove(struct platform_device *pdev)
 {
 	struct rfkill_wlan_data *rfkill = platform_get_drvdata(pdev);
 
-    LOG("Enter %s\n", __func__);
-
-    // wake_lock_destroy(&rfkill->wlan_irq_wl);
-
-    fb_unregister_client(&rfkill_wlan_fb_notifier);
-    
-    if (gpio_is_valid(rfkill->pdata->power_n.io))
-        gpio_free(rfkill->pdata->power_n.io);
-    
-    if (gpio_is_valid(rfkill->pdata->reset_n.io))
-        gpio_free(rfkill->pdata->reset_n.io);
-    
-//    if (gpio_is_valid(rfkill->pdata->vddio.io))
-//        gpio_free(rfkill->pdata->vddio.io);
-//
-//    if (gpio_is_valid(rfkill->pdata->bgf_int_b.io))
-//        gpio_free(rfkill->pdata->bgf_int_b.io);
-//    
-//    if (gpio_is_valid(rfkill->pdata->gps_sync.io))
-//        gpio_free(rfkill->pdata->gps_sync.io);
-//    
-//    if (gpio_is_valid(rfkill->pdata->ANTSEL2.io))
-//        gpio_free(rfkill->pdata->ANTSEL2.io);
-//
-//    if (gpio_is_valid(rfkill->pdata->ANTSEL3.io))
-//        gpio_free(rfkill->pdata->ANTSEL3.io);
-//    
-//    if (gpio_is_valid(rfkill->pdata->GPS_LAN.io))
-//        gpio_free(rfkill->pdata->GPS_LAN.io);
-
-    kfree(rfkill);
-    g_rfkill = NULL;
+	if (gpio_is_valid(rfkill->pdata->power_n.io))
+		gpio_free(rfkill->pdata->power_n.io);
+
+	kfree(rfkill);
+	g_rfkill = NULL;
 
 	return 0;
 }
 
 static int rfkill_wlan_suspend(struct platform_device *pdev, pm_message_t state)
 {
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *poweron, *reset;
-    poweron = &mrfkill->pdata->power_n;
-    reset = &mrfkill->pdata->reset_n;
-
-    // turn off the wifi's power
-    if( support_power_ctrl ){
-        if (gpio_is_valid(poweron->io)) {
-            gpio_set_value(poweron->io, !(poweron->enable));
-            msleep(100);
-        }
-
-        if (gpio_is_valid(reset->io)) {
-            gpio_set_value(reset->io, !(reset->enable));
-        }
-
-        wifi_power_state = 0;
-        LOG("wifi shut off power.\n");
-    }
-
-    LOG("Enter %s\n", __func__);
-    return 0;
+	struct rfkill_wlan_data *rfkill = g_rfkill;
+	struct ctrl_gpio *power_on;
+
+	power_on = &rfkill->pdata->power_n;
+
+	// turn off the wifi's power
+	if (power_on_when_resume) {
+		if (gpio_is_valid(power_on->io)) {
+			gpio_set_value(power_on->io, !(power_on->enable));
+			msleep(100);
+		}
+
+		LOG("Turn off the power of the WiFi module.\n");
+	}
+
+	return 0;
 }
 
 static int rfkill_wlan_resume(struct platform_device *pdev)
 {
-    struct rfkill_wlan_data *mrfkill = g_rfkill;
-    struct rksdmmc_gpio *poweron, *reset;
-    poweron = &mrfkill->pdata->power_n;
-    reset = &mrfkill->pdata->reset_n;
-
-    // turn on the wifi's power
-    if( support_power_ctrl ){
-        if (gpio_is_valid(poweron->io)) {
-            gpio_set_value(poweron->io, poweron->enable);
-            msleep(500);
-        }
-
-        if (gpio_is_valid(reset->io)) {
-            gpio_set_value(reset->io, reset->enable);
-            msleep(100);
-        }
-
-        wifi_power_state = 1;
-        LOG("wifi turn on power. %d\n", poweron->io);
-    }
-
-    LOG("Enter %s\n", __func__);
-    return 0;
+	struct rfkill_wlan_data *rfkill = g_rfkill;
+	struct ctrl_gpio *power_on;
+
+	power_on = &rfkill->pdata->power_n;
+
+	// turn on the wifi's power
+	if (power_on_when_resume) {
+		if (gpio_is_valid(power_on->io)) {
+			gpio_set_value(power_on->io, power_on->enable);
+			msleep(500);
+		}
+
+		LOG("Turn on the power of the WiFi module. %d\n", power_on->io);
+	}
+
+	return 0;
 }
 
 #ifdef CONFIG_OF
-static struct of_device_id wlan_platdata_of_match[] = {
-    { .compatible = "wlan-platdata" },
-    { }
+static const struct of_device_id wlan_platdata_of_match[] = {
+	{ .compatible = "wlan-platdata" },
+	{ }
 };
 MODULE_DEVICE_TABLE(of, wlan_platdata_of_match);
 #endif //CONFIG_OF
@@ -988,30 +257,27 @@ MODULE_DEVICE_TABLE(of, wlan_platdata_of_match);
 static struct platform_driver rfkill_wlan_driver = {
 	.probe = rfkill_wlan_probe,
 	.remove = rfkill_wlan_remove,
-    .suspend = rfkill_wlan_suspend,
-    .resume = rfkill_wlan_resume,
+	.suspend = rfkill_wlan_suspend,
+	.resume = rfkill_wlan_resume,
 	.driver = {
 		.name = "wlan-platdata",
 		.owner = THIS_MODULE,
-        .of_match_table = of_match_ptr(wlan_platdata_of_match),
+		.of_match_table = of_match_ptr(wlan_platdata_of_match),
 	},
 };
 
 static int __init rfkill_wlan_init(void)
 {
-    LOG("Enter %s\n", __func__);
 	return platform_driver_register(&rfkill_wlan_driver);
 }
 
 static void __exit rfkill_wlan_exit(void)
 {
-    LOG("Enter %s\n", __func__);
 	platform_driver_unregister(&rfkill_wlan_driver);
 }
 
 module_init(rfkill_wlan_init);
 module_exit(rfkill_wlan_exit);
 
-MODULE_DESCRIPTION("rock-chips rfkill for wifi v0.1");
-MODULE_AUTHOR("gwl@rock-chips.com");
+MODULE_DESCRIPTION("rfkill for wifi");
 MODULE_LICENSE("GPL");
-- 
2.43.0

