From 675400a76b9b3bdb88df703179dfc9fe85555364 Mon Sep 17 00:00:00 2001
From: David Li <davidli.li@linux.alibaba.com>
Date: Sat, 31 Aug 2024 23:47:33 +0800
Subject: [PATCH 176/400] audio: th1520: add tdm driver for XuanTie TH1520 SoC

1. add 'xuantie,th1520-tdm' dt-bindings
2. add tdm driver code
3. add tdm node in dts
4. enable tdm config

Signed-off-by: David Li <davidli.li@linux.alibaba.com>
Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
---
 .../bindings/sound/xuantie,th1520-tdm.yaml    |  86 +++
 arch/riscv/boot/dts/thead/th1520.dtsi         | 144 +++++
 arch/riscv/configs/th1520_defconfig           |   2 +
 sound/soc/xuantie/Kconfig                     |   9 +
 sound/soc/xuantie/Makefile                    |   2 +
 sound/soc/xuantie/th1520-tdm.c                | 610 ++++++++++++++++++
 sound/soc/xuantie/th1520-tdm.h                | 122 ++++
 7 files changed, 975 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/sound/xuantie,th1520-tdm.yaml
 create mode 100644 sound/soc/xuantie/th1520-tdm.c
 create mode 100644 sound/soc/xuantie/th1520-tdm.h

diff --git a/Documentation/devicetree/bindings/sound/xuantie,th1520-tdm.yaml b/Documentation/devicetree/bindings/sound/xuantie,th1520-tdm.yaml
new file mode 100644
index 000000000000..17835597e8ec
--- /dev/null
+++ b/Documentation/devicetree/bindings/sound/xuantie,th1520-tdm.yaml
@@ -0,0 +1,86 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/sound/xuantie,th1520-tdm.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: TH1520 TDM Controller
+
+description:
+  The TH1520 TDM Controller is a Time Division Multiplexed
+  audio interface in TH1520 SoCs, allowing up to 8 channels
+  of audio over a serial interface.
+
+maintainers:
+  - nanli.yd <nanli.yd@alibaba-inc.com>
+
+properties:
+  compatible:
+    enum:
+      - xuantie,th1520-tdm
+
+  reg:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+  dmas:
+    maxItems: 1
+
+  dma-names:
+    maxItems: 1
+    items:
+      enum:
+        - rx
+
+  clocks:
+    minItems: 1
+    items:
+      - description: tdm_pclk
+
+  clock-names:
+    minItems: 1
+    items:
+      - const: pclk
+
+  resets:
+    maxItems: 1
+    description: reset tdm
+
+  reset-names:
+    maxItems: 1
+
+  audio-cpr-regmap:
+    description:
+      The phandle of the syscon node for the CPR register.
+
+  "#sound-dai-cells":
+    const: 0
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - dmas
+  - dma-names
+  - clocks
+  - clock-names
+  - resets
+  - reset-names
+  - "#sound-dai-cells"
+
+examples:
+  - |
+    tdm: audio_tdm@ffcb012000 {
+        compatible = "xuantie,th1520-tdm";
+        reg = <0xff 0xcb012000 0x0 0x1000>;
+        audio-cpr-regmap = <&audio_cpr>;
+        interrupts = <178, IRQ_TYPE_LEVEL_HIGH>;
+        dmas = <&dmac2 28>;
+        dma-names = "rx";
+        clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+        clock-names = "pclk";
+        resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+        #sound-dai-cells = <0>;
+    };
diff --git a/arch/riscv/boot/dts/thead/th1520.dtsi b/arch/riscv/boot/dts/thead/th1520.dtsi
index 966b9b9ca0bb..70aa20121206 100644
--- a/arch/riscv/boot/dts/thead/th1520.dtsi
+++ b/arch/riscv/boot/dts/thead/th1520.dtsi
@@ -624,6 +624,150 @@ i2s_8ch_sd3: i2s-8ch-sd3@ffcb017000 {
 			status = "disabled";
 		};
 
+		tdm_slot1: tdm1@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <1>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 28>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot2: tdm2@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <2>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 29>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot3: tdm3@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <3>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 30>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot4: tdm4@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <4>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 31>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot5: tdm5@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <5>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 32>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot6: tdm6@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <6>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 33>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot7: tdm7@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <7>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 34>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
+		tdm_slot8: tdm8@ffcb012000 {
+			#sound-dai-cells = <0>;
+			compatible = "xuantie,th1520-tdm";
+			reg = <0xff 0xcb012000 0x0 0x1000>;
+			audio-cpr-regmap = <&audio_cpr>;
+			pinctrl-names = "default";
+			th1520,tdm_slots = <8>;
+			th1520,tdm_slot_num = <8>;
+			interrupts = <178 IRQ_TYPE_LEVEL_HIGH>;
+			dmas = <&dmac2 35>;
+			dma-names = "rx";
+			#dma-cells = <1>;
+			clocks = <&audiosys_clk_gate TH1520_CLKGEN_AUDIO_TDM>;
+			clock-names = "pclk";
+			resets = <&audiosys_rst TH1520_RESET_AUD_TDM>;
+			status = "disabled";
+		};
+
 		plic: interrupt-controller@ffd8000000 {
 			compatible = "thead,th1520-plic", "thead,c900-plic";
 			reg = <0xff 0xd8000000 0x0 0x01000000>;
diff --git a/arch/riscv/configs/th1520_defconfig b/arch/riscv/configs/th1520_defconfig
index e4b1eeefe551..6c4517f182e6 100644
--- a/arch/riscv/configs/th1520_defconfig
+++ b/arch/riscv/configs/th1520_defconfig
@@ -267,3 +267,5 @@ CONFIG_LOCK_TORTURE_TEST=m
 CONFIG_RCU_TORTURE_TEST=m
 # CONFIG_RCU_TRACE is not set
 CONFIG_TEST_BPF=m
+# TH1520 tdm
+CONFIG_SND_SOC_XUANTIE_TH1520_TDM=y
diff --git a/sound/soc/xuantie/Kconfig b/sound/soc/xuantie/Kconfig
index 068e2040baaf..12b5cbd828cd 100644
--- a/sound/soc/xuantie/Kconfig
+++ b/sound/soc/xuantie/Kconfig
@@ -33,3 +33,12 @@ config SND_SOC_XUANTIE_TH1520_HDMI_PCM
         help
           Say Y or M if you want to add support for HDMI PCM to the XuanTie
           TH1520 interface
+
+config SND_SOC_XUANTIE_TH1520_TDM
+        tristate "XuanTie TH1520 audio tdm feature Support"
+	depends on SND_SOC_XUANTIE
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	default n
+        help
+          Say Y or M if you want to add support for codecs attached to the
+          XuanTie TH1520 interface
diff --git a/sound/soc/xuantie/Makefile b/sound/soc/xuantie/Makefile
index 699178d181d2..d874185081a0 100644
--- a/sound/soc/xuantie/Makefile
+++ b/sound/soc/xuantie/Makefile
@@ -11,3 +11,5 @@ snd-soc-xuantie-th1520-i2s-ch8-objs := th1520-i2s-common.o	\
 obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_I2S_CH8) += snd-soc-xuantie-th1520-i2s-ch8.o
 
 obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_HDMI_PCM) += th1520-hdmi-pcm.o
+
+obj-$(CONFIG_SND_SOC_XUANTIE_TH1520_TDM) += th1520-tdm.o
diff --git a/sound/soc/xuantie/th1520-tdm.c b/sound/soc/xuantie/th1520-tdm.c
new file mode 100644
index 000000000000..41d4d8d759b9
--- /dev/null
+++ b/sound/soc/xuantie/th1520-tdm.c
@@ -0,0 +1,610 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 Alibaba Group Holding Limited.
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/pm_runtime.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/scatterlist.h>
+#include <linux/sh_dma.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/sh_fsi.h>
+#include "th1520-pcm.h"
+#include "th1520-audio-cpr.h"
+#include "th1520-tdm.h"
+#include <linux/dmaengine.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/mfd/syscon.h>
+
+#define TH1520_RATES SNDRV_PCM_RATE_8000_384000
+#define I2S_DMA_MAXBURST    (4)
+#define TH1520_FMTS (SNDRV_PCM_FMTBIT_S32_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S8)
+
+static int th1520_tdm_dai_probe(struct snd_soc_dai *dai)
+{
+    struct th1520_tdm_priv *tdm = snd_soc_dai_get_drvdata(dai);
+
+    if (tdm) {
+        snd_soc_dai_init_dma_data(dai, NULL, &tdm->dma_params_rx);
+    } else {
+        return -EIO;
+    }
+
+    return 0;
+}
+
+static int th1520_tdm_dai_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *dai)
+{
+    struct th1520_tdm_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+    
+    return pm_runtime_get_sync(dai->dev);
+}
+
+static void th1520_tdm_snd_rxctrl(struct th1520_tdm_priv *priv, char on)
+{
+    u32 dmactl;
+    u32 tdmen;
+
+    if (priv->slot_num != 1) {
+        return;
+    }
+
+    regmap_update_bits(priv->regmap, TDM_DMACTL,
+            DMACTL_DMAEN_MSK, DMACTL_DMAEN_SEL(on));
+    regmap_update_bits(priv->regmap, TDM_TDMEN,
+            TDMCTL_TDMEN_MSK, TDMCTL_TDMEN_SEL(on));
+    regmap_read(priv->regmap, TDM_DMACTL, &dmactl);
+    regmap_read(priv->regmap, TDM_TDMEN, &tdmen);
+    pr_debug("%s TDM_DMACTL=0x%x TDM_TDMEN=0x%x\n", __func__, dmactl, tdmen);
+    return;
+}
+
+static void th1520_tdm_dai_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct th1520_tdm_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    if (priv->slot_num != 1) {
+        return;
+    }
+
+    if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		th1520_tdm_snd_rxctrl(priv, 0);
+
+	pm_runtime_put(dai->dev);
+    return;
+}
+
+static int th1520_tdm_dai_trigger(struct snd_pcm_substream *substream, int cmd, struct snd_soc_dai *dai)
+{
+    int ret = 0;
+    struct th1520_tdm_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    switch(cmd) {
+        case SNDRV_PCM_TRIGGER_START:
+        case SNDRV_PCM_TRIGGER_RESUME:
+        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+            th1520_tdm_snd_rxctrl(priv, 1);
+            priv->state = TDM_STATE_RUNNING;
+            break;
+        case SNDRV_PCM_TRIGGER_STOP:
+        case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+            priv->state = TDM_STATE_IDLE;
+        case SNDRV_PCM_TRIGGER_SUSPEND:
+            th1520_tdm_snd_rxctrl(priv, 0);
+            break;
+        default:
+            return -EINVAL;
+    }    
+
+    return ret;
+}
+
+static int th1520_tdm_set_fmt_dai(struct snd_soc_dai *dai, unsigned int fmt)
+{
+    struct th1520_tdm_priv *priv = snd_soc_dai_get_drvdata(dai);
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+
+    pm_runtime_resume_and_get(priv->dev);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		priv->mode = TDM_MODE_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		priv->mode = TDM_MODE_SLAVE;
+		break;
+	default:
+		pr_err("Unknown fmt dai\n");
+		return -EINVAL;
+	}
+
+    switch(fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+        case SND_SOC_DAIFMT_DSP_B:
+            break;
+        default:
+            pr_err("Unknown fmt dai\n");
+            return -EIO;
+    }
+
+	regmap_update_bits(priv->regmap, TDM_TDMCTL,
+			TDMCTL_MODE_MSK,
+			TDMCTL_MODE_SEL(TDM_MODE_MASTER));
+	regmap_update_bits(priv->regmap, TDM_TDMCTL,
+			TDMCTL_SPEDGE_MSK,
+			TDMCTL_SPEDGE_SEL(1));
+    regmap_update_bits(priv->regmap, TDM_DMADL,
+            DMACTL_DMADL_MSK, DMACTL_DMADL_SEL(0));
+
+    pm_runtime_put_sync(priv->dev);
+
+    return 0;
+}
+
+static u32 th1520_special_sample_rates[] = { 11025, 22050, 44100, 88200 };
+#define AUDIO_DIVCLK0  49152000
+#define AUDIO_DIVCLK1 135475200
+
+static void th1520_tdm_set_div(struct th1520_tdm_priv *priv, struct snd_pcm_hw_params *params)
+{
+    bool is_divclk1 = false; //audio_divclk1 for 44.1k...etc. audio_divclk0 for 48k....etc
+    u32 src_clk;
+    u32 div0, i, width;
+    u32 sample_rate = params_rate(params);
+
+    switch(params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            width = 16;
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            width = 24;
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+            width = 32;
+            break;
+        default:
+            pr_err("Unknown data format\n");
+            return;
+    }
+
+    for (i = 0; i < ARRAY_SIZE(th1520_special_sample_rates); i++) {
+        if (th1520_special_sample_rates[i] == sample_rate) {
+            is_divclk1 = true;
+            break;
+        }
+    }
+
+    if (is_divclk1 == false) { // audio_divclk0=49152000 for 48k
+        regmap_update_bits(priv->audio_cpr_regmap,
+                        CPR_PERI_CLK_SEL_REG, CPR_TDM_SRC_SEL_MSK, CPR_TDM_SRC_SEL(0));
+        src_clk = AUDIO_DIVCLK0;
+    } else { // audio_divclk1=135475200 for 44.1k
+        regmap_update_bits(priv->audio_cpr_regmap,
+                        CPR_PERI_CLK_SEL_REG, CPR_TDM_SRC_SEL_MSK, CPR_TDM_SRC_SEL(2));
+        src_clk = AUDIO_DIVCLK1;
+    }
+    div0 = src_clk / (sample_rate * (width * priv->slots));
+	regmap_update_bits(priv->regmap, TDM_DIV0_LEVEL,
+			TDMCTL_DIV0_MASK, div0);
+    pr_debug("src_clk=%d sample_rate=%d priv->slots=%d width=%d div0=%d\n", src_clk, sample_rate, priv->slots, width, div0);
+}
+
+
+static int th1520_tdm_dai_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+    struct th1520_tdm_priv *priv =  snd_soc_dai_get_drvdata(dai);
+    u32 datawth, chn_num;
+    u32 tdmctl;
+
+    if ( params_channels(params) != 1) {
+        pr_err("Not support channel num\n");
+        return -EINVAL;
+    }
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+
+    switch(params_format(params)) {
+        case SNDRV_PCM_FORMAT_S16_LE:
+            datawth = TDMCTL_DATAWTH_16BIT_PACKED; // TDMCTL_DATAWTH_16BIT
+            break;
+        case SNDRV_PCM_FORMAT_S24_LE:
+            datawth = TDMCTL_DATAWTH_24BIT;
+            break;
+        case SNDRV_PCM_FORMAT_S32_LE:
+            datawth = TDMCTL_DATAWTH_32BIT;
+            break;
+        default:
+            pr_err("Unknown data format\n");
+            return -EINVAL;
+    }
+
+    switch(priv->slots) {
+        case 2:
+            chn_num = TDMCTL_CHNUM_2;
+            break;
+        case 4:
+            chn_num = TDMCTL_CHNUM_4;
+            break;
+        case 6:
+            chn_num = TDMCTL_CHNUM_6;
+            break;
+        case 8:
+            chn_num = TDMCTL_CHNUM_8;
+            break;
+        default:
+            pr_err("Not support slot num\n");
+            return -EINVAL;
+    }
+
+	regmap_update_bits(priv->regmap, TDM_TDMCTL,
+			TDMCTL_DATAWTH_MSK, TDMCTL_DATAWTH_SEL(datawth));
+	regmap_update_bits(priv->regmap, TDM_TDMCTL,
+			TDMCTL_CHNUM_MSK, TDMCTL_CHNUM_SEL(chn_num));
+    regmap_read(priv->regmap, TDM_TDMCTL, &tdmctl);
+    pr_debug("%s TDM_TDMCTL=0x%x\n", __func__, tdmctl); 
+    th1520_tdm_set_div(priv, params);
+
+    return 0;
+}
+
+
+static const struct snd_soc_dai_ops th1520_tdm_dai_ops = {
+    .startup = th1520_tdm_dai_startup,
+    .shutdown = th1520_tdm_dai_shutdown,
+    .trigger = th1520_tdm_dai_trigger,
+    .set_fmt = th1520_tdm_set_fmt_dai,
+    .hw_params = th1520_tdm_dai_hw_params,
+};
+
+static struct snd_soc_dai_driver th1520_tdm_soc_dai = {
+    .capture = {
+        .rates = TH1520_RATES,
+        .formats = TH1520_FMTS,
+        .channels_min = 1,
+        .channels_max = 1,
+    },
+    .ops = &th1520_tdm_dai_ops,
+};
+
+static const struct snd_soc_component_driver th1520_tdm_soc_component = {
+	.name		= "th1520_tdm",
+};
+
+static bool th1520_tdm_wr_reg(struct device *dev, unsigned int reg)
+{
+    return true;
+}
+
+static bool th1520_tdm_rd_reg(struct device *dev, unsigned int reg)
+{
+	return true;
+}
+
+static const struct regmap_config th1520_tdm_regmap_config = {
+        .reg_bits = 32,
+        .reg_stride = 4,
+        .val_bits = 32,
+        .max_register = TDM_DIV0_LEVEL,
+        .writeable_reg = th1520_tdm_wr_reg,
+        .readable_reg = th1520_tdm_rd_reg,
+        .cache_type = REGCACHE_NONE,
+};
+
+static int th1520_tdm_runtime_suspend(struct device *dev)
+{
+    struct th1520_tdm_priv *priv = dev_get_drvdata(dev);
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+
+    clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static int th1520_tdm_runtime_resume(struct device *dev)
+{
+    struct th1520_tdm_priv *priv = dev_get_drvdata(dev);
+    int ret;
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+
+    ret = clk_prepare_enable(priv->clk);
+    if (ret) {
+            dev_err(priv->dev, "clock enable failed %d\n", ret);
+            return ret;
+    }
+
+    return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int th1520_tdm_suspend(struct device *dev)
+{
+    struct th1520_tdm_priv *priv = dev_get_drvdata(dev);
+
+    if (priv->slot_num != 1)  {
+        return 0;
+    }
+
+    pm_runtime_get_sync(dev);
+    
+	regmap_read(priv->regmap, TDM_TDMCTL, &priv->suspend_tdmctl);
+	regmap_read(priv->regmap, TDM_CHOFFSET1, &priv->suspend_choffset1);
+	regmap_read(priv->regmap, TDM_CHOFFSET2, &priv->suspend_choffset2);
+	regmap_read(priv->regmap, TDM_CHOFFSET3, &priv->suspend_choffset3);
+	regmap_read(priv->regmap, TDM_CHOFFSET4, &priv->suspend_choffset4);
+	regmap_read(priv->regmap, TDM_FIFOTL1, &priv->suspend_fifotl1);
+	regmap_read(priv->regmap, TDM_FIFOTL2, &priv->suspend_fifotl2);
+	regmap_read(priv->regmap, TDM_FIFOTL3, &priv->suspend_fifotl3);
+	regmap_read(priv->regmap, TDM_FIFOTL4, &priv->suspend_fifotl4);
+	regmap_read(priv->regmap, TDM_IMR, &priv->suspend_imr);
+	regmap_read(priv->regmap, TDM_DMADL, &priv->suspend_dmadl);
+	regmap_read(priv->regmap, TDM_DIV0_LEVEL, &priv->suspend_div0level);
+
+    regmap_read(priv->audio_cpr_regmap, CPR_PERI_DIV_SEL_REG, &priv->cpr_peri_div_sel);
+    regmap_read(priv->audio_cpr_regmap, CPR_PERI_CLK_SEL_REG, &priv->cpr_peri_clk_sel);
+    reset_control_assert(priv->rst);
+
+    pm_runtime_put_sync(dev);
+
+	return 0;
+}
+
+static int th1520_tdm_resume(struct device *dev)
+{
+    struct th1520_tdm_priv *priv = dev_get_drvdata(dev);
+    int ret;
+
+    if (priv->slot_num != 1) {
+        return 0;
+    }
+    pm_runtime_get_sync(dev);
+
+    reset_control_deassert(priv->rst);
+    regmap_write(priv->audio_cpr_regmap, CPR_PERI_DIV_SEL_REG, priv->cpr_peri_div_sel);
+    regmap_write(priv->audio_cpr_regmap, CPR_PERI_CLK_SEL_REG, priv->cpr_peri_clk_sel);
+
+
+	regmap_write(priv->regmap, TDM_TDMCTL, priv->suspend_tdmctl);
+	regmap_write(priv->regmap, TDM_CHOFFSET1, priv->suspend_choffset1);
+	regmap_write(priv->regmap, TDM_CHOFFSET2, priv->suspend_choffset2);
+	regmap_write(priv->regmap, TDM_CHOFFSET3, priv->suspend_choffset3);
+	regmap_write(priv->regmap, TDM_CHOFFSET4, priv->suspend_choffset4);
+	regmap_write(priv->regmap, TDM_FIFOTL1, priv->suspend_fifotl1);
+	regmap_write(priv->regmap, TDM_FIFOTL2, priv->suspend_fifotl2);
+	regmap_write(priv->regmap, TDM_FIFOTL3, priv->suspend_fifotl3);
+	regmap_write(priv->regmap, TDM_FIFOTL4, priv->suspend_fifotl4);
+	regmap_write(priv->regmap, TDM_IMR, priv->suspend_imr);
+	regmap_write(priv->regmap, TDM_DMADL, priv->suspend_dmadl);
+	regmap_write(priv->regmap, TDM_DIV0_LEVEL, priv->suspend_div0level);
+
+    pm_runtime_put_sync(dev);
+
+    return ret;
+}
+#endif
+
+static const struct of_device_id th1520_tdm_of_match[] = {
+	{ .compatible = "xuantie,th1520-tdm"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, th1520_tdm_of_match);
+
+irqreturn_t tdm_interrupt(int irq, void* dev_id)
+{
+    //struct th1520_tdm_priv* priv = (struct th1520_tdm_priv*)dev_id;
+    return IRQ_HANDLED;
+}
+
+static int th1520_tdm_probe(struct platform_device *pdev)
+{
+    struct device_node *np = pdev->dev.of_node;
+    const char *sprop;
+    const uint32_t *iprop;
+    struct th1520_tdm_priv *tdm_priv;
+    struct resource *res;
+    struct device *dev = &pdev->dev;
+    struct reset_control *resets;
+
+    int data_register, ret = 0;
+
+    tdm_priv = devm_kzalloc(&pdev->dev, sizeof(struct th1520_tdm_priv), GFP_KERNEL);
+    if (!tdm_priv) {
+        return -ENOMEM;
+    }
+
+    tdm_priv->dev = dev;
+
+    iprop = of_get_property(np, "th1520,tdm_slots", NULL);
+    if (iprop) {
+        if (be32_to_cpup(iprop) == 2 || be32_to_cpup(iprop) == 4 || be32_to_cpup(iprop) == 6 || be32_to_cpup(iprop) == 8) {
+            tdm_priv->slots = be32_to_cpup(iprop);
+        } else {
+            dev_err(dev, "invalid th1520,tdm_slots\n");
+            return -EINVAL;
+        }
+    } else {
+        tdm_priv->slots = 8;
+    }
+
+    iprop = of_get_property(np, "th1520,tdm_slot_num", NULL);
+    if (iprop) {
+        if (be32_to_cpup(iprop) >=1 && be32_to_cpup(iprop) <=8 ) {
+            tdm_priv->slot_num = be32_to_cpup(iprop);
+        } else {
+            dev_err(dev, "invalid th1520,tdm_slot_num\n");
+            return -EINVAL;
+        }
+    } else {
+        dev_err(dev, "invalid th1520,tdm_slot_num\n");
+        return -EINVAL;
+    }
+
+    dev_set_drvdata(dev, tdm_priv);
+
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+
+
+    if (tdm_priv->slot_num == 1) {
+        tdm_priv->clk = devm_clk_get(&pdev->dev, "pclk");
+        if (IS_ERR(tdm_priv->clk))
+                    return PTR_ERR(tdm_priv->clk);
+
+        tdm_priv->regs = devm_ioremap_resource(dev, res);
+        if (IS_ERR(tdm_priv->regs)) {
+            return PTR_ERR(tdm_priv->regs);
+        }
+
+        tdm_priv->regmap = devm_regmap_init_mmio(dev, tdm_priv->regs,
+                                                    &th1520_tdm_regmap_config);
+        if (IS_ERR(tdm_priv->regmap)) {
+            dev_err(dev, "Failed to initialise managed register map\n");
+            return PTR_ERR(tdm_priv->regmap);
+        }
+
+        tdm_priv->audio_cpr_regmap = syscon_regmap_lookup_by_phandle(np, "audio-cpr-regmap");
+        if (IS_ERR(tdm_priv->audio_cpr_regmap)) {
+            dev_err(dev, "cannot find regmap for audio cpr register\n");
+            return -EINVAL;
+        }
+        //AUDIO_DIV1 set to 1/6. 812.8512MHz / 6 = 135.4752MHz
+        regmap_update_bits(tdm_priv->audio_cpr_regmap,
+                                CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV1_SEL_MSK, CPR_AUDIO_DIV1_SEL(5));
+        //AUDIO_DIV0 set to 1/6. 294.912MHz / 6 = 49.152MHz
+        regmap_update_bits(tdm_priv->audio_cpr_regmap,
+                                CPR_PERI_DIV_SEL_REG, CPR_AUDIO_DIV0_SEL_MSK, CPR_AUDIO_DIV0_SEL(5));
+
+        resets = devm_reset_control_get_optional_shared(&pdev->dev, NULL);
+        if (IS_ERR(resets)) {
+            ret = PTR_ERR(resets);
+            return ret;
+        }
+        tdm_priv->rst = resets;
+
+        reset_control_deassert(tdm_priv->rst);
+
+        pm_runtime_enable(&pdev->dev);
+        pm_runtime_resume_and_get(&pdev->dev); // clk gate is enabled by hardware as default register value
+        pm_runtime_put_sync(&pdev->dev);
+
+        tdm_priv->irq = platform_get_irq(pdev, 0);
+        if (tdm_priv->irq== 0) {
+            dev_err(dev, "could not map IRQ.\n");
+            return -ENXIO;
+        }
+
+        //ret = request_irq(tdm_priv->irq , tdm_interrupt,
+        //		IRQF_SHARED|IRQF_TRIGGER_RISING, "AUDIO_TDM_IRQ", (char *)tdm_priv);
+        //if (ret) {
+        //	dev_err(dev, "%s[%d]:request irq error!\n", __func__, __LINE__);
+        //	return ret;
+        //}
+    }
+
+    switch(tdm_priv->slot_num) {
+        case 1:
+            data_register = TDM_LDR1;
+            break;
+        case 2:
+            data_register = TDM_RDR1;
+            break;
+        case 3:
+            data_register = TDM_LDR2;
+            break;
+        case 4:
+            data_register = TDM_RDR2;
+            break;
+        case 5:
+            data_register = TDM_LDR3;
+            break;
+        case 6:
+            data_register = TDM_RDR3;
+            break;
+        case 7:
+            data_register = TDM_LDR4;
+            break;
+        case 8:
+            data_register = TDM_RDR4;
+            break;
+        default:
+            dev_err(dev, "invalid slot_num\n");
+            return -EINVAL;
+    }
+
+    tdm_priv->dma_params_rx.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+    tdm_priv->dma_params_rx.maxburst = I2S_DMA_MAXBURST;
+    tdm_priv->dma_params_rx.addr = res->start + data_register;
+
+    ret = th1520_pcm_dma_init(pdev, TH1520_TDM_DMABUF_SIZE);
+	if (ret) {
+		dev_err(dev, "th1520_pcm_dma_init error\n");
+		return -EIO;
+	}
+
+    ret = devm_snd_soc_register_component(dev, &th1520_tdm_soc_component,
+                        &th1520_tdm_soc_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd component register\n");
+	}
+
+    return ret;
+}
+
+static int th1520_tdm_remove(struct platform_device *pdev)
+{
+    struct th1520_tdm_priv *tdm_priv = dev_get_drvdata(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
+    if (!pm_runtime_status_suspended(&pdev->dev))
+            th1520_tdm_runtime_suspend(&pdev->dev);
+    clk_disable_unprepare(tdm_priv->clk);
+    return 0;
+}
+
+static const struct dev_pm_ops th1520_tdm_pm_ops = {
+    SET_RUNTIME_PM_OPS(th1520_tdm_runtime_suspend, th1520_tdm_runtime_resume, NULL)
+    SET_SYSTEM_SLEEP_PM_OPS(th1520_tdm_suspend,
+                    th1520_tdm_resume)
+};
+
+static struct platform_driver th1520_tdm_driver = {
+    .driver = {
+        .name = "th1520-tdm-audio",
+        .pm = &th1520_tdm_pm_ops,
+        .of_match_table = th1520_tdm_of_match,
+    },
+    .probe = th1520_tdm_probe,
+    .remove = th1520_tdm_remove,
+};
+
+module_platform_driver(th1520_tdm_driver);
+
+MODULE_AUTHOR("nanli.yd <nanli.yd@linux.alibaba.com>");
+MODULE_DESCRIPTION("XuanTie TH1520 audio driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/xuantie/th1520-tdm.h b/sound/soc/xuantie/th1520-tdm.h
new file mode 100644
index 000000000000..32f8ac5cd272
--- /dev/null
+++ b/sound/soc/xuantie/th1520-tdm.h
@@ -0,0 +1,122 @@
+#ifndef _TH1520_TDM_H
+#define _TH1520_TDM_H
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/scatterlist.h>
+#include <linux/sh_dma.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+#include <sound/pcm.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "th1520-pcm.h"
+#include <linux/spinlock.h>
+
+#define TDM_TDMEN   0x00
+#define TDM_TDMCTL  0x04
+#define TDM_CHOFFSET1   0x08
+#define TDM_CHOFFSET2   0x0c
+#define TDM_CHOFFSET3   0x10
+#define TDM_CHOFFSET4   0x14
+#define TDM_FIFOTL1	0x18
+#define TDM_FIFOTL2	0x1C
+#define TDM_FIFOTL3	0x20
+#define TDM_FIFOTL4	0x24
+#define TDM_SR	0x28
+#define TDM_IMR	0x2C
+#define TDM_ISR	0x30
+#define TDM_RISR	0x34
+#define TDM_ICR	0x38
+#define TDM_DMACTL	0x3C
+#define TDM_DMADL	0x40
+#define TDM_LDR1	0x44
+#define TDM_RDR1	0x48
+#define TDM_LDR2	0x4C
+#define TDM_RDR2	0x50
+#define TDM_LDR3	0x54
+#define TDM_RDR3	0x58
+#define TDM_LDR4	0x5C
+#define TDM_RDR4	0x60
+#define TDM_DIV0_LEVEL	0x64
+
+#define TDM_MODE_MASTER 0x1
+#define TDM_MODE_SLAVE 0x0
+#define TDMCTL_MODE_POS                             (0U) 
+#define TDMCTL_MODE_MSK                         (0x1U << TDMCTL_MODE_POS)
+#define TDMCTL_MODE_SEL(X)                  (X << TDMCTL_MODE_POS)
+#define TDMCTL_DATAWTH_POS                  (4U)
+#define TDMCTL_DATAWTH_MSK              (0x3U << TDMCTL_DATAWTH_POS)
+#define TDMCTL_DATAWTH_SEL(X)                (X << TDMCTL_DATAWTH_POS)
+#define TDMCTL_CHNUM_POS                        (8U)
+#define TDMCTL_CHNUM_MSK              (0x3U << TDMCTL_CHNUM_POS)
+#define TDMCTL_CHNUM_SEL(X)                (X << TDMCTL_CHNUM_POS)
+#define TDMCTL_CHNUM_2                      0x0
+#define TDMCTL_CHNUM_4                      0x1
+#define TDMCTL_CHNUM_6                      0x2
+#define TDMCTL_CHNUM_8                      0x3
+#define TDMCTL_SPEDGE_POS                        (13U)
+#define TDMCTL_SPEDGE_MSK              (0x1U << TDMCTL_SPEDGE_POS)
+#define TDMCTL_SPEDGE_SEL(X)                (X << TDMCTL_SPEDGE_POS)
+
+#define TDMCTL_DATAWTH_16BIT_PACKED 0x0
+#define TDMCTL_DATAWTH_16BIT 0x1
+#define TDMCTL_DATAWTH_24BIT    0x2
+#define TDMCTL_DATAWTH_32BIT 0x3
+
+#define TDMCTL_DIV0_MASK 0xFFF
+
+#define DMACTL_DMAEN_POS                          (0U)
+#define DMACTL_DMAEN_MSK                          (0x1U << DMACTL_DMAEN_POS)
+#define DMACTL_DMAEN_SEL(X)                            (X << DMACTL_DMAEN_POS)
+
+#define DMACTL_DMADL_POS                          (0U)
+#define DMACTL_DMADL_MSK                          (0x3U << DMACTL_DMADL_POS)
+#define DMACTL_DMADL_SEL(X)                            (X << DMACTL_DMADL_POS)
+
+#define TDMCTL_TDMEN_POS                          (0U)
+#define TDMCTL_TDMEN_MSK                          (0x1U << TDMCTL_TDMEN_POS)
+#define TDMCTL_TDMEN_SEL(X)                            (X << TDMCTL_TDMEN_POS)
+
+#define TH1520_TDM_DMABUF_SIZE     (64 * 1024)
+#define TDM_STATE_IDLE				0
+#define TDM_STATE_RUNNING	1
+
+struct th1520_tdm_priv {
+    void __iomem *regs;
+    struct regmap *regmap;
+    struct regmap *audio_cpr_regmap;
+    struct reset_control *rst;
+    struct clk *clk;
+    struct snd_dmaengine_dai_dma_data dma_params_rx;
+    unsigned int cfg_off;
+    struct device *dev; 
+    char mode;
+    char slots;
+    char slot_num;
+    unsigned int irq;
+    u32 suspend_tdmctl;
+    u32 suspend_choffset1;
+    u32 suspend_choffset2;
+    u32 suspend_choffset3;
+    u32 suspend_choffset4;
+    u32 suspend_fifotl1;
+    u32 suspend_fifotl2;
+    u32 suspend_fifotl3;
+    u32 suspend_fifotl4;
+    u32 suspend_imr;
+    u32 suspend_dmadl;
+    u32 suspend_div0level;
+	u32 cpr_peri_div_sel;
+	u32 cpr_peri_clk_sel;
+    u32 state;
+};
+
+
+#endif
-- 
2.43.0

