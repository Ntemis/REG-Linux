#!/bin/bash

BOOTCONF="/boot/batocera-boot.conf"
LOG="/tmp/resize.log"

# only at start
test "$1" != "start" && exit 0

TOTALSTEPS=0		# To help with progress bar
CURRENTSTEP=0		# use multiples of 100 (100, 200, 300, etc., instead of 1, 2, 3, etc.)
if grep -qE '^[ ]*autoresize[ ]*=[ ]*true[ ]*$' "${BOOTCONF}"; then
	((TOTALSTEPS+=10))
fi
if grep -qE '^[ ]*format-internal[ ]*=' "${BOOTCONF}"; then
	((TOTALSTEPS+=6))
fi
if grep -qE '^[ ]*newbootuuid[ ]*=[ ]*true[ ]*$' "${BOOTCONF}"; then
	((TOTALSTEPS+=4))
fi

# Greater than 0 only if there is something to do
if [ $TOTALSTEPS -gt 0 ]; then
	# Plymouth changed for update
	/usr/bin/plymouth change-mode --updates
else
	exit 0
fi

# Remove the trigger(s)
remove_trigger() {
	local trigger="$1"
	mount -o remount,rw /boot
	sed -i -e "s/^[ ]*${trigger}/#${trigger}/g" "${BOOTCONF}"
	mount -o remount,ro /boot
}

# UI Output with plymouth
function plymouth_output() {
	local percent="$1"
	local text="$2"

	/usr/bin/plymouth system-update --progress "$percent"
	/usr/bin/plymouth display-message --text="$text"
}

# Display error with timeout
function display_error() {
	/usr/bin/plymouth display-message --text="Resize Error - Please check the resize log at: /tmp/resize.log"
	exit 1
}

# Executing parameters and watch background pid
# Changes text messages parsed to dialog --mixedgauge
function cmdoutput()
{
	local text="$3"
	local cmd="$2"
	local percent="$1"
	local pid ret

	echo "cmd:$cmd" >> "$LOG"
	$cmd >> "$LOG" 2>&1 &
	pid=$!
	plymouth_output "$percent" "$text"
	wait $pid
	ret=$?
	echo "cmd code:$ret" >> "$LOG"
	if [ $ret -ne 0 ]; then
		display_error
	fi
	return $ret
}

# Edit given file with new boot partition UUID
replaceuuid() {
	mount -o remount,rw /boot
	# First try to replace label=REGLINUX with uuid=*, just in case we are updating a very old disk
	find "/boot/" -type f \( -iname "extlinux.conf" -o -iname "cmdline.txt" -o -iname "boot.ini" -o -iname "uEnv.txt" -o -iname "syslinux.cfg" -o -iname "grub.cfg" \) -exec sed -i "s/label=REGLINUX/uuid=$NEWUUID/g;s/uuid=$OLDUUID/uuid=$NEWUUID/g" {} \+
	mount -o remount,ro /boot
}

# only when resizing is wanted
if grep -qE '^[ ]*autoresize[ ]*=[ ]*true[ ]*$' "${BOOTCONF}"; then

	# /userdata partition
	PART=$(batocera-part "share_internal")
	PARTNUM=$(batocera-part "share_internal_num")
	echo "Partition name: $PART & number: $PARTNUM" >> "$LOG"

	# boot disk
	DISK=$(batocera-part prefix "${PART}")
	echo "Disk = $DISK" >> "$LOG"

	# only for ext4
	PARTTYPE=$(blkid -o value -s TYPE "${PART}")
	echo "Partition type = ${PARTTYPE}" >> "$LOG"
	if [ "${PARTTYPE}" = "ext4" ]; then
        # partition table
        TABLETYPE=$(blkid -o value -s PTTYPE "${DISK}")
        echo "Disk partition table type = $TABLETYPE" >> "$LOG"

        # if GPT, move backup data structures to the end of the disk
        ((CURRENTSTEP+=100))
        if [ "${TABLETYPE}" = "gpt" ]; then
            echo "Moving 2nd GPT table to the end of the disk" >> "$LOG"
            cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "sgdisk -e ${DISK}" "Aligning GPT table..."
        fi

        # resize the partition
        echo "Resizing the partition to 100%" >> "$LOG"
        ((CURRENTSTEP+=200))
        cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "parted -s -m -f ${DISK} resizepart ${PARTNUM} 100%" "Resizing partition..."

        # update the kernel
        echo "Updating the kernel" >> "$LOG"
        ((CURRENTSTEP+=100))
        cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "partprobe ${DISK}" "Informing the Kernel..."

        # check & resize the ext4 file system
        echo "Checking ext4 file system" >> "$LOG"
        ((CURRENTSTEP+=100))
        cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "e2fsck -f -p ${PART}" "Checking /userdata integrity..."

        echo "Expanding ext4 the file system" >> "$LOG"
        ((CURRENTSTEP+=200))
        cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "resize2fs ${PART}" "Expanding the file system..."

        echo "Checking ext4 file system" >> "$LOG"
        ((CURRENTSTEP+=100))
        cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "e2fsck -f -p ${PART}" "Checking ext4 file system..."
    fi
	# remove the trigger
	((CURRENTSTEP+=100))
	cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "remove_trigger autoresize" "Removing trigger..............."
fi

# format internal share if wanted
FORMAT_INTERNAL_TYPE=$(grep -m 1 -E '^[ ]*format-internal[ ]*=.*$' "${BOOTCONF}" | sed -e "s+^[ ]*format-internal[ ]*=[ ]*\(.*\)[ ]*$+\1+")
if [ -n "${FORMAT_INTERNAL_TYPE}" ]; then
	((CURRENTSTEP+=400))
	PART=$(batocera-part "share_internal")
	case "${FORMAT_INTERNAL_TYPE}" in
	"btrfs")
		cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "mkfs.btrfs -L SHARE -f ${PART}" "Formatting to btrfs..."
	;;
	"ext4")
		cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "mkfs.ext4 -L SHARE -q -F -F ${PART}" "Formatting to ext4..."
	;;
	"exfat")
		cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "mkfs.exfat -n SHARE ${PART}" "Formatting to exfat..."
	;;
	*)
		# do nothing
	;;
	esac
	# remove the trigger
	((CURRENTSTEP+=100))
	cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "remove_trigger format-internal" "Removing trigger..."
fi


# only when random UUID for boot partition is wanted (first boot)
if grep -qE '^[ ]*newbootuuid[ ]*=[ ]*true[ ]*$' "${BOOTCONF}"; then

	BOOTPART="$(/usr/bin/batocera-part boot)"
	OLDUUID=$(blkid -c /dev/null -o value -s UUID "$BOOTPART")

	echo "Changing UUID of boot partition to a new random UUID" >> "$LOG"
	((CURRENTSTEP+=100))
	cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "fatlabel -i -r $BOOTPART" "Changing boot partition UUID..."
	NEWUUID=$(blkid -c /dev/null -o value -s UUID "$BOOTPART")
	echo "Previous UUID: $OLDUUID" >> "$LOG"
	echo "Current UUID: $NEWUUID" >> "$LOG"

	((CURRENTSTEP+=100))
	if [ -n "$OLDUUID" ] && [ -n "$NEWUUID" ]
	then
		echo "Updating boot files with new UUID" >> "$LOG"
		cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "replaceuuid" "Updating boot files with new UUID..."
	else
		display_error
	fi

	# remove the trigger
	((CURRENTSTEP+=100))
	cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "remove_trigger newbootuuid" "Removing trigger..............."
fi

# finally disk sync
echo "Final sync" >> "$LOG"
((CURRENTSTEP+=50))
cmdoutput $((CURRENTSTEP / TOTALSTEPS)) "sync" "Syncing disk data.............."

#Cleanup, restore screen, set progress of last item to 100%
/usr/bin/plymouth system-update --progress 100

# Plymouth continues the boot
/usr/bin/plymouth change-mode --boot-up
/usr/bin/plymouth display-message --text=" "

exit 0
